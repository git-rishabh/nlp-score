As in all other computer languages, the elements of Java do not exist in isolation.
Rather, they work together to form the language as a whole. However, this
interrelatedness can make it difficult to describe one aspect of Java without
involving several others. Often a discussion of one feature implies prior knowledge of
another. For this reason, this chapter presents a quick overview of several key features
of Java. The material described here will give you a foothold that will allow you to write
and understand simple programs. Most of the topics discussed will be examined in greater
detail in the remaining chapters of Part I.
Object-Oriented Programming
Object-oriented programming (OOP) is at the core of Java. In fact, all Java programs are to at
least some extent object-oriented. OOP is so integral to Java that it is best to understand its
basic principles before you begin writing even simple Java programs. Therefore, this chapter
begins with a discussion of the theoretical aspects of OOP.
Two Paradigms
All computer programs consist of two elements: code and data. Furthermore, a program can
be conceptually organized around its code or around its data. That is, some programs are
written around “what is happening” and others are written around “who is being affected.”
These are the two paradigms that govern how a program is constructed. The first way is
called the process-oriented model. This approach characterizes a program as a series of linear
steps (that is, code). The process-oriented model can be thought of as code acting on data.
Procedural languages such as C employ this model to considerable success. However, as
mentioned in Chapter 1, problems with this approach appear as programs grow larger and
more complex.
To manage increasing complexity, the second approach, called object-oriented programming,
was conceived. Object-oriented programming organizes a program around its data (that is,
objects) and a set of well-defined interfaces to that data. An object-oriented program can be
characterized as data controlling access to code. As you will see, by switching the controlling
entity to data, you can achieve several organizational benefits.
1516
Part I:
The Java Language
Abstraction
An essential element of object-oriented programming is abstraction. Humans manage
complexity through abstraction. For example, people do not think of a car as a set of tens
of thousands of individual parts. They think of it as a well-defined object with its own
unique behavior. This abstraction allows people to use a car to drive to the grocery store
without being overwhelmed by the complexity of the parts that form the car. They can
ignore the details of how the engine, transmission, and braking systems work. Instead,
they are free to utilize the object as a whole.
A powerful way to manage abstraction is through the use of hierarchical classifications.
This allows you to layer the semantics of complex systems, breaking them into more
manageable pieces. From the outside, the car is a single object. Once inside, you see that
the car consists of several subsystems: steering, brakes, sound system, seat belts, heating,
cellular phone, and so on. In turn, each of these subsystems is made up of more specialized
units. For instance, the sound system consists of a radio, a CD player, and/or a tape player.
The point is that you manage the complexity of the car (or any other complex system)
through the use of hierarchical abstractions.
Hierarchical abstractions of complex systems can also be applied to computer programs.
The data from a traditional process-oriented program can be transformed by abstraction
into its component objects. A sequence of process steps can become a collection of messages
between these objects. Thus, each of these objects describes its own unique behavior. You
can treat these objects as concrete entities that respond to messages telling them to do something.
This is the essence of object-oriented programming.
Object-oriented concepts form the heart of Java just as they form the basis for human
understanding. It is important that you understand how these concepts translate into
programs. As you will see, object-oriented programming is a powerful and natural paradigm
for creating programs that survive the inevitable changes accompanying the life cycle of any
major software project, including conception, growth, and aging. For example, once you
have well-defined objects and clean, reliable interfaces to those objects, you can gracefully
decommission or replace parts of an older system without fear.
The Three OOP Principles
All object-oriented programming languages provide mechanisms that help you implement
the object-oriented model. They are encapsulation, inheritance, and polymorphism. Let’s take
a look at these concepts now.
Encapsulation
Encapsulation is the mechanism that binds together code and the data it manipulates, and
keeps both safe from outside interference and misuse. One way to think about encapsulation
is as a protective wrapper that prevents the code and data from being arbitrarily accessed
by other code defined outside the wrapper. Access to the code and data inside the wrapper
is tightly controlled through a well-defined interface. To relate this to the real world, consider
the automatic transmission on an automobile. It encapsulates hundreds of bits of information
about your engine, such as how much you are accelerating, the pitch of the surface you are
on, and the position of the shift lever. You, as the user, have only one method of affectingChapter 2:
An Overview of Java
this complex encapsulation: by moving the gear-shift lever. You can’t affect the transmission
by using the turn signal or windshield wipers, for example. Thus, the gear-shift lever is a
well-defined (indeed, unique) interface to the transmission. Further, what occurs inside the
transmission does not affect objects outside the transmission. For example, shifting gears
does not turn on the headlights! Because an automatic transmission is encapsulated, dozens
of car manufacturers can implement one in any way they please. However, from the driver’s
point of view, they all work the same. This same idea can be applied to programming.
The power of encapsulated code is that everyone knows how to access it and thus can use
it regardless of the implementation details—and without fear of unexpected side effects.
In Java, the basis of encapsulation is the class. Although the class will be examined in great
detail later in this book, the following brief discussion will be helpful now. A class defines
the structure and behavior (data and code) that will be shared by a set of objects. Each object
of a given class contains the structure and behavior defined by the class, as if it were stamped
out by a mold in the shape of the class. For this reason, objects are sometimes referred to as
instances of a class. Thus, a class is a logical construct; an object has physical reality.
When you create a class, you will specify the code and data that constitute that class.
Collectively, these elements are called members of the class. Specifically, the data defined by
the class are referred to as member variables or instance variables. The code that operates on
that data is referred to as member methods or just methods. (If you are familiar with C/C++, it
may help to know that what a Java programmer calls a method, a C/C++ programmer calls a
function.) In properly written Java programs, the methods define how the member variables
can be used. This means that the behavior and interface of a class are defined by the methods
that operate on its instance data.
Since the purpose of a class is to encapsulate complexity, there are mechanisms for
hiding the complexity of the implementation inside the class. Each method or variable in a
class may be marked private or public. The public interface of a class represents everything
that external users of the class need to know, or may know. The private methods and data
can only be accessed by code that is a member of the class. Therefore, any other code that
is not a member of the class cannot access a private method or variable. Since the private
members of a class may only be accessed by other parts of your program through the class’
public methods, you can ensure that no improper actions take place. Of course, this means
that the public interface should be carefully designed not to expose too much of the inner
workings of a class (see Figure 2-1).
Inheritance
Inheritance is the process by which one object acquires the properties of another object. This
is important because it supports the concept of hierarchical classification. As mentioned
earlier, most knowledge is made manageable by hierarchical (that is, top-down) classifications.
For example, a Golden Retriever is part of the classification dog, which in turn is part of the
mammal class, which is under the larger class animal. Without the use of hierarchies, each
object would need to define all of its characteristics explicitly. However, by use of inheritance,
an object need only define those qualities that make it unique within its class. It can inherit
its general attributes from its parent. Thus, it is the inheritance mechanism that makes it
possible for one object to be a specific instance of a more general case. Let’s take a closer
look at this process.
1718
Part I:
The Java Language
F IGURE 2-1
Encapsulation:
public methods
can be used to
protect private
data
Most people naturally view the world as made up of objects that are related to each
other in a hierarchical way, such as animals, mammals, and dogs. If you wanted to describe
animals in an abstract way, you would say they have some attributes, such as size, intelligence,
and type of skeletal system. Animals also have certain behavioral aspects; they eat, breathe,
and sleep. This description of attributes and behavior is the class definition for animals.
If you wanted to describe a more specific class of animals, such as mammals, they would
have more specific attributes, such as type of teeth, and mammary glands. This is known as
a subclass of animals, where animals are referred to as mammals’ superclass.
Since mammals are simply more precisely specified animals, they inherit all of the attributes
from animals. A deeply inherited subclass inherits all of the attributes from each of its ancestors
in the class hierarchy.Chapter 2:
An Overview of Java
Inheritance interacts with encapsulation as well. If a given class encapsulates some
attributes, then any subclass will have the same attributes plus any that it adds as part of its
specialization (see Figure 2-2). This is a key concept that lets object-oriented programs grow
in complexity linearly rather than geometrically. A new subclass inherits all of the attributes
of all of its ancestors. It does not have unpredictable interactions with the majority of the rest
of the code in the system.
Polymorphism
Polymorphism (from Greek, meaning “many forms”) is a feature that allows one interface to
be used for a general class of actions. The specific action is determined by the exact nature
F IGURE 2-2
Labrador inherits the encapsulation of all its superclasses
1920
Part I:
The Java Language
of the situation. Consider a stack (which is a last-in, first-out list). You might have a program
that requires three types of stacks. One stack is used for integer values, one for floating-point
values, and one for characters. The algorithm that implements each stack is the same, even
though the data being stored differs. In a non–object-oriented language, you would be
required to create three different sets of stack routines, with each set using different names.
However, because of polymorphism, in Java you can specify a general set of stack routines
that all share the same names.
More generally, the concept of polymorphism is often expressed by the phrase “one
interface, multiple methods.” This means that it is possible to design a generic interface to
a group of related activities. This helps reduce complexity by allowing the same interface
to be used to specify a general class of action. It is the compiler’s job to select the specific action
(that is, method) as it applies to each situation. You, the programmer, do not need to make
this selection manually. You need only remember and utilize the general interface.
Extending the dog analogy, a dog’s sense of smell is polymorphic. If the dog smells a cat,
it will bark and run after it. If the dog smells its food, it will salivate and run to its bowl.
The same sense of smell is at work in both situations. The difference is what is being smelled,
that is, the type of data being operated upon by the dog’s nose! This same general concept
can be implemented in Java as it applies to methods within a Java program.
Polymorphism, Encapsulation, and Inheritance Work Together
When properly applied, polymorphism, encapsulation, and inheritance combine to produce
a programming environment that supports the development of far more robust and scalable
programs than does the process-oriented model. A well-designed hierarchy of classes is the
basis for reusing the code in which you have invested time and effort developing and testing.
Encapsulation allows you to migrate your implementations over time without breaking the
code that depends on the public interface of your classes. Polymorphism allows you to create
clean, sensible, readable, and resilient code.
Of the two real-world examples, the automobile more completely illustrates the power
of object-oriented design. Dogs are fun to think about from an inheritance standpoint, but
cars are more like programs. All drivers rely on inheritance to drive different types (subclasses)
of vehicles. Whether the vehicle is a school bus, a Mercedes sedan, a Porsche, or the family
minivan, drivers can all more or less find and operate the steering wheel, the brakes, and
the accelerator. After a bit of gear grinding, most people can even manage the difference
between a stick shift and an automatic, because they fundamentally understand their common
superclass, the transmission.
People interface with encapsulated features on cars all the time. The brake and gas pedals
hide an incredible array of complexity with an interface so simple you can operate them
with your feet! The implementation of the engine, the style of brakes, and the size of the
tires have no effect on how you interface with the class definition of the pedals.
The final attribute, polymorphism, is clearly reflected in the ability of car manufacturers
to offer a wide array of options on basically the same vehicle. For example, you can get an
antilock braking system or traditional brakes, power or rack-and-pinion steering, and 4-, 6-,
or 8-cylinder engines. Either way, you will still press the brake pedal to stop, turn the steering
wheel to change direction, and press the accelerator when you want to move. The same
interface can be used to control a number of different implementations.Chapter 2:
An Overview of Java
As you can see, it is through the application of encapsulation, inheritance, and
polymorphism that the individual parts are transformed into the object known as a car.
The same is also true of computer programs. By the application of object-oriented principles,
the various parts of a complex program can be brought together to form a cohesive, robust,
maintainable whole.
As mentioned at the start of this section, every Java program is object-oriented. Or, put
more precisely, every Java program involves encapsulation, inheritance, and polymorphism.
Although the short example programs shown in the rest of this chapter and in the next few
chapters may not seem to exhibit all of these features, they are nevertheless present. As you
will see, many of the features supplied by Java are part of its built-in class libraries, which
do make extensive use of encapsulation, inheritance, and polymorphism.
A First Simple Program
Now that the basic object-oriented underpinning of Java has been discussed, let’s look at
some actual Java programs. Let’s start by compiling and running the short sample program
shown here. As you will see, this involves a little more work than you might imagine.
/*
This is a simple Java program.
Call this file "Example.java".
*/
class Example 
N OTE The descriptions that follow use the standard Java SE 6 Development Kit (JDK 6), which is
available from Sun Microsystems. If you are using a different Java development environment,
then you may need to follow a different procedure for compiling and executing Java programs.
In this case, consult your compiler’s documentation for details.
Entering the Program
For most computer languages, the name of the file that holds the source code to a program
is immaterial. However, this is not the case with Java. The first thing that you must learn
about Java is that the name you give to a source file is very important. For this example,
the name of the source file should be Example.java. Let’s see why.
In Java, a source file is officially called a compilation unit. It is a text file that contains one
or more class definitions. The Java compiler requires that a source file use the .java filename
extension.
As you can see by looking at the program, the name of the class defined by the program
is also Example. This is not a coincidence. In Java, all code must reside inside a class. By
convention, the name of that class should match the name of the file that holds the program.
You should also make sure that the capitalization of the filename matches the class name.
2122
Part I:
The Java Language
The reason for this is that Java is case-sensitive. At this point, the convention that filenames
correspond to class names may seem arbitrary. However, this convention makes it easier to
maintain and organize your programs.
Compiling the Program
To compile the Example program, execute the compiler, javac, specifying the name of the
source file on the command line, as shown here:
C:\>javac Example.java
The javac compiler creates a file called Example.class that contains the bytecode version
of the program. As discussed earlier, the Java bytecode is the intermediate representation of
your program that contains instructions the Java Virtual Machine will execute. Thus, the
output of javac is not code that can be directly executed.
To actually run the program, you must use the Java application launcher, called java.
To do so, pass the class name Example as a command-line argument, as shown here:
C:\>java Example
When the program is run, the following output is displayed:
This is a simple Java program.
When Java source code is compiled, each individual class is put into its own output file
named after the class and using the .class extension. This is why it is a good idea to give
your Java source files the same name as the class they contain—the name of the source file
will match the name of the .class file. When you execute java as just shown, you are actually
specifying the name of the class that you want to execute. It will automatically search for
a file by that name that has the .class extension. If it finds the file, it will execute the code
contained in the specified class.
A Closer Look at the First Sample Program
Although Example.java is quite short, it includes several key features that are common to
all Java programs. Let’s closely examine each part of the program.
The program begins with the following lines:
/*
This is a simple Java program.
Call this file "Example.java".
*/
This is a comment. Like most other programming languages, Java lets you enter a remark into
a program’s source file. The contents of a comment are ignored by the compiler. Instead, a
comment describes or explains the operation of the program to anyone who is reading its
source code. In this case, the comment describes the program and reminds you that the source
file should be called Example.java. Of course, in real applications, comments generally explain
how some part of the program works or what a specific feature does.Chapter 2:
An Overview of Java
Java supports three styles of comments. The one shown at the top of the program is called
a multiline comment. This type of comment must begin with /* and end with */. Anything
between these two comment symbols is ignored by the compiler. As the name suggests, a
multiline comment may be several lines long.
The next line of code in the program is shown here:
class Example 
args[]) {
/ c) - (d * s);
" + " + (i / c) + " - " + (d * s));
" + result);
Let’s look closely at the type promotions that occur in this line from the program:
double result = (f * b) + (i / c) - (d * s);
In the first subexpression, f * b, b is promoted to a float and the result of the subexpression
is float. Next, in the subexpression i / c, c is promoted to int, and the result is of type int. Then,
in d * s, the value of s is promoted to double, and the type of the subexpression is double.
Finally, these three intermediate values, float, int, and double, are considered. The outcome
of float plus an int is a float. Then the resultant float minus the last double is promoted to
double, which is the type for the final result of the expression.
Arrays
An array is a group of like-typed variables that are referred to by a common name. Arrays of
any type can be created and may have one or more dimensions. A specific element in an array
is accessed by its index. Arrays offer a convenient means of grouping related information.
N OTE If you are familiar with C/C++, be careful. Arrays in Java work differently than they do in
those languages.
One-Dimensional Arrays
A one-dimensional array is, essentially, a list of like-typed variables. To create an array, you first
must create an array variable of the desired type. The general form of a one-dimensional
array declaration is
type var-name[ ];
Here, type declares the base type of the array. The base type determines the data type of each
element that comprises the array. Thus, the base type for the array determines what type of
data the array will hold. For example, the following declares an array named month_days
with the type “array of int”:
int month_days[];Chapter 3:
D a t a Ty p e s , Va r i a b l e s , a n d A r r a y s
Although this declaration establishes the fact that month_days is an array variable, no
array actually exists. In fact, the value of month_days is set to null, which represents an array
with no value. To link month_days with an actual, physical array of integers, you must allocate
one using new and assign it to month_days. new is a special operator that allocates memory.
You will look more closely at new in a later chapter, but you need to use it now to allocate
memory for arrays. The general form of new as it applies to one-dimensional arrays appears
as follows:
array-var = new type[size];
Here, type specifies the type of data being allocated, size specifies the number of elements in
the array, and array-var is the array variable that is linked to the array. That is, to use new to
allocate an array, you must specify the type and number of elements to allocate. The elements
in the array allocated by new will automatically be initialized to zero. This example allocates
a 12-element array of integers and links them to month_days.
month_days = new int[12];
After this statement executes, month_days will refer to an array of 12 integers. Further, all
elements in the array will be initialized to zero.
Let’s review: Obtaining an array is a two-step process. First, you must declare a variable of
the desired array type. Second, you must allocate the memory that will hold the array, using
new, and assign it to the array variable. Thus, in Java all arrays are dynamically allocated. If
the concept of dynamic allocation is unfamiliar to you, don’t worry. It will be described at
length later in this book.
Once you have allocated an array, you can access a specific element in the array by
specifying its index within square brackets. All array indexes start at zero. For example,
this statement assigns the value 28 to the second element of month_days.
month_days[1] = 28;
The next line displays the value stored at index 3.
System.out.println(month_days[3]);
Putting together all the pieces, here is a program that creates an array of the number
of days in each month.
// Demonstrate a one-dimensional array.
class Array 
When you run this program, it prints the number of days in April. As mentioned, Java array
indexes start with zero, so the number of days in April is month_days[3] or 30.
It is possible to combine the declaration of the array variable with the allocation of the
array itself, as shown here:
int month_days[] = new int[12];
This is the way that you will normally see it done in professionally written Java programs.
Arrays can be initialized when they are declared. The process is much the same as that
used to initialize the simple types. An array initializer is a list of comma-separated expressions
surrounded by curly braces. The commas separate the values of the array elements. The array
will automatically be created large enough to hold the number of elements you specify in the
array initializer. There is no need to use new. For example, to store the number of days in
each month, the following code creates an initialized array of integers:
// An improved version of the previous program.
class AutoArray 
When you run this program, you see the same output as that generated by the previous version.
Java strictly checks to make sure you do not accidentally try to store or reference values
outside of the range of the array. The Java run-time system will check to be sure that all array
indexes are in the correct range. For example, the run-time system will check the value of
each index into month_days to make sure that it is between 0 and 11 inclusive. If you try to
access elements outside the range of the array (negative numbers or numbers greater than
the length of the array), you will cause a run-time error.
Here is one more example that uses a one-dimensional array. It finds the average of a set
of numbers.
// Average an array of values.
class Average 
Multidimensional Arrays
In Java, multidimensional arrays are actually arrays of arrays. These, as you might expect, look
and act like regular multidimensional arrays. However, as you will see, there are a couple
of subtle differences. To declare a multidimensional array variable, specify each additional
index using another set of square brackets. For example, the following declares a two-
dimensional array variable called twoD.
int twoD[][] = new int[4][5];
This allocates a 4 by 5 array and assigns it to twoD. Internally this matrix is implemented as
an array of arrays of int. Conceptually, this array will look like the one shown in Figure 3-1.
The following program numbers each element in the array from left to right, top to
bottom, and then displays these values:
// Demonstrate a two-dimensional array.
class TwoDArray 
This program generates the following output:
0 1 2
5 6 7
10 11
15 16
3 4
8 9
12 13 14
17 18 19
When you allocate memory for a multidimensional array, you need only specify the
memory for the first (leftmost) dimension. You can allocate the remaining dimensions
5152
Part I: The Java Language
F IGURE 3-1 A conceptual view of a 4 by 5, two-dimensional array
separately. For example, this following code allocates memory for the first dimension of
twoD when it is declared. It allocates the second dimension manually.
int twoD[][] = new int[4][];
twoD[0] = new int[5];
twoD[1] = new int[5];
twoD[2] = new int[5];
twoD[3] = new int[5];
While there is no advantage to individually allocating the second dimension arrays in
this situation, there may be in others. For example, when you allocate dimensions manually,
you do not need to allocate the same number of elements for each dimension. As stated earlier,
since multidimensional arrays are actually arrays of arrays, the length of each array is under
your control. For example, the following program creates a two-dimensional array in which
the sizes of the second dimension are unequal.
// Manually allocate differing size second dimensions.
class TwoDAgain 
This program generates the following output:
0
1 2
3 4 5
6 7 8 9
The array created by this program looks like this:
The use of uneven (or, irregular) multidimensional arrays may not be appropriate for many
applications, because it runs contrary to what people expect to find when a multidimensional
array is encountered. However, irregular arrays can be used effectively in some situations. For
example, if you need a very large two-dimensional array that is sparsely populated (that is,
one in which not all of the elements will be used), then an irregular array might be a perfect
solution.
It is possible to initialize multidimensional arrays. To do so, simply enclose each dimension’s
initializer within its own set of curly braces. The following program creates a matrix where
each element contains the product of the row and column indexes. Also notice that you can
use expressions as well as literal values inside of array initializers.
// Initialize a two-dimensional array.
class Matrix 
When you run this program, you will get the following output:
0.0
0.0
0.0
0.0
0.0
1.0
2.0
3.0
0.0
2.0
4.0
6.0
0.0
3.0
6.0
9.0
As you can see, each row in the array is initialized as specified in the initialization lists.
Let’s look at one more example that uses a multidimensional array. The following program
creates a 3 by 4 by 5, three-dimensional array. It then loads each element with the product
of its indexes. Finally, it displays these products.
// Demonstrate a three-dimensional array.
class ThreeDMatrix 
This program generates the following output:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0Chapter 3:
0
0
0
0 0
1
2
3 0
2
4
6
0
3
6
9
0
0
0
0 0
2
4
6 0 0 0
4 6 8
8 12 16
12 18 24
D a t a Ty p e s , Va r i a b l e s , a n d A r r a y s
0
4
8
12
Alternative Array Declaration Syntax
There is a second form that may be used to declare an array:
type[ ] var-name;
Here, the square brackets follow the type specifier, and not the name of the array variable.
For example, the following two declarations are equivalent:
int al[] = new int[3];
int[] a2 = new int[3];
The following declarations are also equivalent:
char twod1[][] = new char[3][4];
char[][] twod2 = new char[3][4];
This alternative declaration form offers convenience when declaring several arrays at the
same time. For example,
int[] nums, nums2, nums3; // create three arrays
creates three array variables of type int. It is the same as writing
int nums[], nums2[], nums3[]; // create three arrays
The alternative declaration form is also useful when specifying an array as a return type for
a method. Both forms are used in this book.
A Few Words About Strings
As you may have noticed, in the preceding discussion of data types and arrays there has been
no mention of strings or a string data type. This is not because Java does not support such a
type—it does. It is just that Java’s string type, called String, is not a simple type. Nor is it simply
an array of characters. Rather, String defines an object, and a full description of it requires an
understanding of several object-related features. As such, it will be covered later in this book,
after objects are described. However, so that you can use simple strings in example programs,
the following brief introduction is in order.
The String type is used to declare string variables. You can also declare arrays of strings.
A quoted string constant can be assigned to a String variable. A variable of type String can
5556
Part I:
The Java Language
be assigned to another variable of type String. You can use an object of type String as an
argument to println( ). For example, consider the following fragment:
String str = "this is a test";
System.out.println(str);
Here, str is an object of type String. It is assigned the string “this is a test”. This string is
displayed by the println( ) statement.
As you will see later, String objects have many special features and attributes that
make them quite powerful and easy to use. However, for the next few chapters, you will
be using them only in their simplest form.
A Note to C/C++ Programmers About Pointers
If you are an experienced C/C++ programmer, then you know that these languages provide
support for pointers. However, no mention of pointers has been made in this chapter. The
reason for this is simple: Java does not support or allow pointers. (Or more properly, Java
does not support pointers that can be accessed and/or modified by the programmer.) Java
cannot allow pointers, because doing so would allow Java programs to breach the firewall
between the Java execution environment and the host computer. (Remember, a pointer can
be given any address in memory—even addresses that might be outside the Java run-time
system.) Since C/C++ make extensive use of pointers, you might be thinking that their loss
is a significant disadvantage to Java. However, this is not true. Java is designed in such a way
that as long as you stay within the confines of the execution environment, you will never need
to use a pointer, nor would there be any benefit in using one.4
Operators
J
ava provides a rich operator environment. Most of its operators can be divided into the
following four groups: arithmetic, bitwise, relational, and logical. Java also defines some
additional operators that handle certain special situations. This chapter describes all
of Java’s operators except for the type comparison operator instanceof, which is examined
in Chapter 13.
Arithmetic Operators
Arithmetic operators are used in mathematical expressions in the same way that they are
used in algebra. The following table lists the arithmetic operators:
Operator Result
+ Addition
– Subtraction (also unary minus)
* Multiplication
/ Division
% Modulus
++ Increment
+= Addition assignment
–= Subtraction assignment
*= Multiplication assignment
/= Division assignment
%= Modulus assignment
– – Decrement
The operands of the arithmetic operators must be of a numeric type. You cannot use
them on boolean types, but you can use them on char types, since the char type in Java is,
essentially, a subset of int.
5758
Part I:
The Java Language
The Basic Arithmetic Operators
The basic arithmetic operations—addition, subtraction, multiplication, and division— all
behave as you would expect for all numeric types. The minus operator also has a unary form
that negates its single operand. Remember that when the division operator is applied to an
integer type, there will be no fractional component attached to the result.
The following simple example program demonstrates the arithmetic operators. It also
illustrates the difference between floating-point division and integer division.
// Demonstrate the basic arithmetic operators.
class BasicMath 
When you run this program, you will see the following output:
Integer Arithmetic
a = 2
b = 6
c = 1
d = -1
e = 1
Floating Point Arithmetic
da = 2.0
db = 6.0Chapter 4:
Operators
dc = 1.5
dd = -0.5
de = 0.5
The Modulus Operator
The modulus operator, %, returns the remainder of a division operation. It can be applied to
floating-point types as well as integer types. The following example program demonstrates
the %:
// Demonstrate the % operator.
class Modulus 
When you run this program, you will get the following output:
x mod 10 = 2
y mod 10 = 2.25
Arithmetic Compound Assignment Operators
Java provides special operators that can be used to combine an arithmetic operation with
an assignment. As you probably know, statements like the following are quite common in
programming:
a = a + 4;
In Java, you can rewrite this statement as shown here:
a += 4;
This version uses the += compound assignment operator. Both statements perform the same
action: they increase the value of a by 4.
Here is another example,
a = a % 2;
which can be expressed as
a %= 2;
In this case, the %= obtains the remainder of a/2 and puts that result back into a.
There are compound assignment operators for all of the arithmetic, binary operators.
Thus, any statement of the form
var = var op expression;
5960
Part I:
The Java Language
can be rewritten as
var op= expression;
The compound assignment operators provide two benefits. First, they save you a bit of
typing, because they are “shorthand” for their equivalent long forms. Second, they are
implemented more efficiently by the Java run-time system than are their equivalent long
forms. For these reasons, you will often see the compound assignment operators used in
professionally written Java programs.
Here is a sample program that shows several op= assignments in action:
// Demonstrate several assignment operators.
class OpEquals 
The output of this program is shown here:
a = 6
b = 8
c = 3
Increment and Decrement
The ++ and the – – are Java’s increment and decrement operators. They were introduced
in Chapter 2. Here they will be discussed in detail. As you will see, they have some special
properties that make them quite interesting. Let’s begin by reviewing precisely what the
increment and decrement operators do.
The increment operator increases its operand by one. The decrement operator decreases
its operand by one. For example, this statement:
x = x + 1;
can be rewritten like this by use of the increment operator:
x++;
Similarly, this statement:
x = x - 1;Chapter 4:
Operators
is equivalent to
x--;
These operators are unique in that they can appear both in postfix form, where they
follow the operand as just shown, and prefix form, where they precede the operand. In the
foregoing examples, there is no difference between the prefix and postfix forms. However,
when the increment and/or decrement operators are part of a larger expression, then a
subtle, yet powerful, difference between these two forms appears. In the prefix form, the
operand is incremented or decremented before the value is obtained for use in the expression.
In postfix form, the previous value is obtained for use in the expression, and then the operand
is modified. For example:
x = 42;
y = ++x;
In this case, y is set to 43 as you would expect, because the increment occurs before x is assigned
to y. Thus, the line y = ++x; is the equivalent of these two statements:
x = x + 1;
y = x;
However, when written like this,
x = 42;
y = x++;
the value of x is obtained before the increment operator is executed, so the value of y is 42.
Of course, in both cases x is set to 43. Here, the line y = x++; is the equivalent of these two
statements:
y = x;
x = x + 1;
The following program demonstrates the increment operator.
// Demonstrate ++.
class IncDec 
6162
Part I:
The Java Language
The output of this program follows:
a
b
c
d
=
=
=
=
2
3
4
1
The Bitwise Operators
Java defines several bitwise operators that can be applied to the integer types, long, int, short,
char, and byte. These operators act upon the individual bits of their operands. They are
summarized in the following table:
Operator
Result
~ Bitwise unary NOT
& Bitwise AND
| Bitwise OR
^ Bitwise exclusive OR
>> Shift right
>>> Shift right zero fill
<< Shift left
&= Bitwise AND assignment
|= Bitwise OR assignment
^= Bitwise exclusive OR assignment
>>= Shift right assignment
>>>= Shift right zero fill assignment
<<= Shift left assignment
Since the bitwise operators manipulate the bits within an integer, it is important to
understand what effects such manipulations may have on a value. Specifically, it is useful
to know how Java stores integer values and how it represents negative numbers. So, before
continuing, let’s briefly review these two topics.
All of the integer types are represented by binary numbers of varying bit widths. For
example, the byte value for 42 in binary is 00101010, where each position represents a power
of two, starting with 2 0 at the rightmost bit. The next bit position to the left would be 2 1 , or 2,
continuing toward the left with 2 2 , or 4, then 8, 16, 32, and so on. So 42 has 1 bits set at positions
1
3
5
1, 3, and 5 (counting from 0 at the right); thus, 42 is the sum of 2 + 2 + 2 , which is 2 + 8 + 32.
All of the integer types (except char) are signed integers. This means that they can represent
negative values as well as positive ones. Java uses an encoding known as two’s complement,
which means that negative numbers are represented by inverting (changing 1’s to 0’s and
vice versa) all of the bits in a value, then adding 1 to the result. For example, –42 is represented
by inverting all of the bits in 42, or 00101010, which yields 11010101, then adding 1, which
results in 11010110, or –42. To decode a negative number, first invert all of the bits, then add 1.
For example, –42, or 11010110 inverted, yields 00101001, or 41, so when you add 1 you get 42.Chapter 4:
Operators
The reason Java (and most other computer languages) uses two’s complement is easy to
see when you consider the issue of zero crossing. Assuming a byte value, zero is represented by
00000000. In one’s complement, simply inverting all of the bits creates 11111111, which creates
negative zero. The trouble is that negative zero is invalid in integer math. This problem is solved
by using two’s complement to represent negative values. When using two’s complement, 1 is
added to the complement, producing 100000000. This produces a 1 bit too far to the left to
fit back into the byte value, resulting in the desired behavior, where –0 is the same as 0, and
11111111 is the encoding for –1. Although we used a byte value in the preceding example,
the same basic principle applies to all of Java’s integer types.
Because Java uses two’s complement to store negative numbers—and because all
integers are signed values in Java—applying the bitwise operators can easily produce
unexpected results. For example, turning on the high-order bit will cause the resulting
value to be interpreted as a negative number, whether this is what you intended or not.
To avoid unpleasant surprises, just remember that the high-order bit determines the sign
of an integer no matter how that high-order bit gets set.
The Bitwise Logical Operators
The bitwise logical operators are &, |, ^, and ~. The following table shows the outcome of
each operation. In the discussion that follows, keep in mind that the bitwise operators are
applied to each individual bit within each operand.
A B
0 0
1 0
0 1
A | B
A & B A ^ B
~A
0 0 0 1
1 0 1 0
1 1 0 1 1
1 1 1 0 0
The Bitwise NOT
Also called the bitwise complement, the unary NOT operator, ~, inverts all of the bits of its
operand. For example, the number 42, which has the following bit pattern:
00101010
becomes
11010101
after the NOT operator is applied.
The Bitwise AND
The AND operator, &, produces a 1 bit if both operands are also 1. A zero is produced in all
other cases. Here is an example:
00101010
& 00001111 42
15
00001010 10
6364
Part I:
The Java Language
The Bitwise OR
The OR operator, |, combines bits such that if either of the bits in the operands is a 1, then
the resultant bit is a 1, as shown here:
00101010
| 00001111 42
15
00101111 47
The Bitwise XOR
The XOR operator, ^, combines bits such that if exactly one operand is 1, then the result is 1.
Otherwise, the result is zero. The following example shows the effect of the ^. This example
also demonstrates a useful attribute of the XOR operation. Notice how the bit pattern of 42
is inverted wherever the second operand has a 1 bit. Wherever the second operand has a 0 bit,
the first operand is unchanged. You will find this property useful when performing some
types of bit manipulations.
00101010
^ 00001111 42
15
00100101 37
Using the Bitwise Logical Operators
The following program demonstrates the bitwise logical operators:
// Demonstrate the bitwise logical operators.
class BitLogic 
=
=
=
=
=
=
=
"
"
"
"
"
"
"
+
+
+
+
+
+
+
binary[a]);
binary[b]);
binary[c]);
binary[d]);
binary[e]);
binary[f]);
binary[g]);Chapter 4:
Operators
In this example, a and b have bit patterns that present all four possibilities for two
binary digits: 0-0, 0-1, 1-0, and 1-1. You can see how the | and & operate on each bit by the
results in c and d. The values assigned to e and f are the same and illustrate how the ^ works.
The string array named binary holds the human-readable, binary representation of the numbers
0 through 15. In this example, the array is indexed to show the binary representation of each
result. The array is constructed such that the correct string representation of a binary value
n is stored in binary[n]. The value of ~a is ANDed with 0x0f (0000 1111 in binary) in order
to reduce its value to less than 16, so it can be printed by use of the binary array. Here is the
output from this program:
a
b
a|b
a&b
a^b
~a&b|a&~b
~a
=
=
=
=
=
=
=
0011
0110
0111
0010
0101
0101
1100
The Left Shift
The left shift operator, <<, shifts all of the bits in a value to the left a specified number of times.
It has this general form:
value << num
Here, num specifies the number of positions to left-shift the value in value. That is, the <<
moves all of the bits in the specified value to the left by the number of bit positions specified
by num. For each shift left, the high-order bit is shifted out (and lost), and a zero is brought
in on the right. This means that when a left shift is applied to an int operand, bits are lost
once they are shifted past bit position 31. If the operand is a long, then bits are lost after bit
position 63.
Java’s automatic type promotions produce unexpected results when you are shifting
byte and short values. As you know, byte and short values are promoted to int when an
expression is evaluated. Furthermore, the result of such an expression is also an int. This
means that the outcome of a left shift on a byte or short value will be an int, and the bits
shifted left will not be lost until they shift past bit position 31. Furthermore, a negative byte
or short value will be sign-extended when it is promoted to int. Thus, the high-order bits
will be filled with 1’s. For these reasons, to perform a left shift on a byte or short implies
that you must discard the high-order bytes of the int result. For example, if you left-shift
a byte value, that value will first be promoted to int and then shifted. This means that you
must discard the top three bytes of the result if what you want is the result of a shifted byte
value. The easiest way to do this is to simply cast the result back into a byte. The following
program demonstrates this concept:
// Left shifting a byte value.
class ByteShift 
The output generated by this program is shown here:
Original value of a: 64
i and b: 256 0
Since a is promoted to int for the purposes of evaluation, left-shifting the value 64
(0100 0000) twice results in i containing the value 256 (1 0000 0000). However, the value
in b contains 0 because after the shift, the low-order byte is now zero. Its only 1 bit has
been shifted out.
Since each left shift has the effect of doubling the original value, programmers frequently
use this fact as an efficient alternative to multiplying by 2. But you need to watch out. If you
shift a 1 bit into the high-order position (bit 31 or 63), the value will become negative. The
following program illustrates this point:
// Left shifting as a quick way to multiply by 2.
class MultByTwo 
The program generates the following output:
536870908
1073741816
2147483632
-32
The starting value was carefully chosen so that after being shifted left 4 bit positions, it
would produce –32. As you can see, when a 1 bit is shifted into bit 31, the number is interpreted
as negative.
The Right Shift
The right shift operator, >>, shifts all of the bits in a value to the right a specified number of
times. Its general form is shown here:
value >> numChapter 4:
Operators
Here, num specifies the number of positions to right-shift the value in value. That is, the >>
moves all of the bits in the specified value to the right the number of bit positions specified
by num.
The following code fragment shifts the value 32 to the right by two positions, resulting
in a being set to 8:
int a = 32;
a = a >> 2; // a now contains 8
When a value has bits that are “shifted off,” those bits are lost. For example, the next
code fragment shifts the value 35 to the right two positions, which causes the two low-order
bits to be lost, resulting again in a being set to 8.
int a = 35;
a = a >> 2; // a still contains 8
Looking at the same operation in binary shows more clearly how this happens:
00100011
>> 2
00001000
35
8
Each time you shift a value to the right, it divides that value by two—and discards any
remainder. You can take advantage of this for high-performance integer division by 2. Of
course, you must be sure that you are not shifting any bits off the right end.
When you are shifting right, the top (leftmost) bits exposed by the right shift are filled in
with the previous contents of the top bit. This is called sign extension and serves to preserve
the sign of negative numbers when you shift them right. For example, –8 >> 1 is –4, which,
in binary, is
11111000
>>1
11111100
–8
–4
It is interesting to note that if you shift –1 right, the result always remains –1, since sign
extension keeps bringing in more ones in the high-order bits.
Sometimes it is not desirable to sign-extend values when you are shifting them to the
right. For example, the following program converts a byte value to its hexadecimal string
representation. Notice that the shifted value is masked by ANDing it with 0x0f to discard
any sign-extended bits so that the value can be used as an index into the array of hexadecimal
characters.
// Masking sign extension.
class HexByte 
Here is the output of this program:
b = 0xf1
The Unsigned Right Shift
As you have just seen, the >> operator automatically fills the high-order bit with its previous
contents each time a shift occurs. This preserves the sign of the value. However, sometimes
this is undesirable. For example, if you are shifting something that does not represent a numeric
value, you may not want sign extension to take place. This situation is common when you
are working with pixel-based values and graphics. In these cases, you will generally want to
shift a zero into the high-order bit no matter what its initial value was. This is known as an
unsigned shift. To accomplish this, you will use Java’s unsigned, shift-right operator, >>>,
which always shifts zeros into the high-order bit.
The following code fragment demonstrates the >>>. Here, a is set to –1, which sets all
32 bits to 1 in binary. This value is then shifted right 24 bits, filling the top 24 bits with zeros,
ignoring normal sign extension. This sets a to 255.
int a = -1;
a = a >>> 24;
Here is the same operation in binary form to further illustrate what is happening:
11111111 11111111 11111111 11111111
>>>24
00000000 00000000 00000000 11111111
–1 in binary as an int
255 in binary as an int
The >>> operator is often not as useful as you might like, since it is only meaningful
for 32- and 64-bit values. Remember, smaller values are automatically promoted to int in
expressions. This means that sign-extension occurs and that the shift will take place on a
32-bit rather than on an 8- or 16-bit value. That is, one might expect an unsigned right shift
on a byte value to zero-fill beginning at bit 7. But this is not the case, since it is a 32-bit value
that is actually being shifted. The following program demonstrates this effect:
// Unsigned shifting a byte value.
class ByteUShift 
The following output of this program shows how the >>> operator appears to do nothing
when dealing with bytes. The variable b is set to an arbitrary negative byte value for this
demonstration. Then c is assigned the byte value of b shifted right by four, which is 0xff
because of the expected sign extension. Then d is assigned the byte value of b unsigned
shifted right by four, which you might have expected to be 0x0f, but is actually 0xff because
of the sign extension that happened when b was promoted to int before the shift. The last
expression sets e to the byte value of b masked to 8 bits using the AND operator, then shifted
right by four, which produces the expected value of 0x0f. Notice that the unsigned shift right
operator was not used for d, since the state of the sign bit after the AND was known.
b = 0xf1
b >> 4 = 0xff
b >>> 4 = 0xff
(b & 0xff) >> 4 = 0x0f
Bitwise Operator Compound Assignments
All of the binary bitwise operators have a compound form similar to that of the algebraic
operators, which combines the assignment with the bitwise operation. For example, the
following two statements, which shift the value in a right by four bits, are equivalent:
a = a >> 4;
a >>= 4;
Likewise, the following two statements, which result in a being assigned the bitwise
expression a OR b, are equivalent:
a = a | b;
a |= b;
The following program creates a few integer variables and then uses compound bitwise
operator assignments to manipulate the variables:
class OpBitEquals 
The output of this program is shown here:
a = 3
b = 1
c = 6
Relational Operators
The relational operators determine the relationship that one operand has to the other.
Specifically, they determine equality and ordering. The relational operators are shown here:
Operator Result
== Equal to
!= Not equal to
> Greater than
< Less than
>= Greater than or equal to
<= Less than or equal to
The outcome of these operations is a boolean value. The relational operators are most
frequently used in the expressions that control the if statement and the various loop statements.
Any type in Java, including integers, floating-point numbers, characters, and Booleans
can be compared using the equality test, ==, and the inequality test, !=. Notice that in Java
equality is denoted with two equal signs, not one. (Remember: a single equal sign is the
assignment operator.) Only numeric types can be compared using the ordering operators.
That is, only integer, floating-point, and character operands may be compared to see which
is greater or less than the other.
As stated, the result produced by a relational operator is a boolean value. For example,
the following code fragment is perfectly valid:
int a = 4;
int b = 1;
boolean c = a < b;
In this case, the result of a<b (which is false) is stored in c.
If you are coming from a C/C++ background, please note the following. In C/C++, these
types of statements are very common:Chapter 4:
Operators
int done;
// ...
if(!done) ... // Valid in C/C++
if(done) ...
// but not in Java.
In Java, these statements must be written like this:
if(done == 0) ... // This is Java-style.
if(done != 0) ...
The reason is that Java does not define true and false in the same way as C/C++. In C/C++,
true is any nonzero value and false is zero. In Java, true and false are nonnumeric values that
do not relate to zero or nonzero. Therefore, to test for zero or nonzero, you must explicitly
employ one or more of the relational operators.
Boolean Logical Operators
The Boolean logical operators shown here operate only on boolean operands. All of the
binary logical operators combine two boolean values to form a resultant boolean value.
Operator Result
& Logical AND
| Logical OR
^ Logical XOR (exclusive OR)
|| Short-circuit OR
&& Short-circuit AND
! Logical unary NOT
&= AND assignment
|= OR assignment
^= XOR assignment
== Equal to
!= Not equal to
?: Ternary if-then-else
The logical Boolean operators, &, |, and ^, operate on boolean values in the same way
that they operate on the bits of an integer. The logical ! operator inverts the Boolean state:
!true == false and !false == true. The following table shows the effect of each logical operation:
A B A | B A & B A ^ B !A
False False False False False True
True False True False True False
False True True False True True
True True True True False False
7172
Part I:
The Java Language
Here is a program that is almost the same as the BitLogic example shown earlier, but it
operates on boolean logical values instead of binary bits:
// Demonstrate the boolean logical operators.
class BoolLogic 
After running this program, you will see that the same logical rules apply to boolean
values as they did to bits. As you can see from the following output, the string representation
of a Java boolean value is one of the literal values true or false:
a
b
a|b
a&b
a^b
a&b|a&!b
!a
=
=
=
=
=
=
=
true
false
true
false
true
true
false
Short-Circuit Logical Operators
Java provides two interesting Boolean operators not found in many other computer languages.
These are secondary versions of the Boolean AND and OR operators, and are known as
short-circuit logical operators. As you can see from the preceding table, the OR operator
results in true when A is true, no matter what B is. Similarly, the AND operator results in
false when A is false, no matter what B is. If you use the || and && forms, rather than the
| and & forms of these operators, Java will not bother to evaluate the right-hand operand
when the outcome of the expression can be determined by the left operand alone. This is
very useful when the right-hand operand depends on the value of the left one in order
to function properly. For example, the following code fragment shows how you can take
advantage of short-circuit logical evaluation to be sure that a division operation will be valid
before evaluating it:
if (denom != 0 && num / denom > 10)Chapter 4:
Operators
Since the short-circuit form of AND (&&) is used, there is no risk of causing a run-time
exception when denom is zero. If this line of code were written using the single & version
of AND, both sides would be evaluated, causing a run-time exception when denom is zero.
It is standard practice to use the short-circuit forms of AND and OR in cases involving
Boolean logic, leaving the single-character versions exclusively for bitwise operations. However,
there are exceptions to this rule. For example, consider the following statement:
if(c==1 & e++ < 100) d = 100;
Here, using a single & ensures that the increment operation will be applied to e whether c
is equal to 1 or not.
The Assignment Operator
You have been using the assignment operator since Chapter 2. Now it is time to take a formal
look at it. The assignment operator is the single equal sign, =. The assignment operator works in
Java much as it does in any other computer language. It has this general form:
var = expression;
Here, the type of var must be compatible with the type of expression.
The assignment operator does have one interesting attribute that you may not be familiar
with: it allows you to create a chain of assignments. For example, consider this fragment:
int x, y, z;
x = y = z = 100; // set x, y, and z to 100
This fragment sets the variables x, y, and z to 100 using a single statement. This works
because the = is an operator that yields the value of the right-hand expression. Thus, the
value of z = 100 is 100, which is then assigned to y, which in turn is assigned to x. Using a
“chain of assignment” is an easy way to set a group of variables to a common value.
The ? Operator
Java includes a special ternary (three-way) operator that can replace certain types of if-then-else
statements. This operator is the ?. It can seem somewhat confusing at first, but the ? can be
used very effectively once mastered. The ? has this general form:
expression1 ? expression2 : expression3
Here, expression1 can be any expression that evaluates to a boolean value. If expression1 is
true, then expression2 is evaluated; otherwise, expression3 is evaluated. The result of the ?
operation is that of the expression evaluated. Both expression2 and expression3 are required
to return the same type, which can’t be void.
Here is an example of the way that the ? is employed:
ratio = denom == 0 ? 0 : num / denom;
7374
Part I:
The Java Language
When Java evaluates this assignment expression, it first looks at the expression to the left of
the question mark. If denom equals zero, then the expression between the question mark and
the colon is evaluated and used as the value of the entire ? expression. If denom does not
equal zero, then the expression after the colon is evaluated and used for the value of the
entire ? expression. The result produced by the ? operator is then assigned to ratio.
Here is a program that demonstrates the ? operator. It uses it to obtain the absolute
value of a variable.
// Demonstrate ?.
class Ternary 
The output generated by the program is shown here:
Absolute value of 10 is 10
Absolute value of -10 is 10
Operator Precedence
Table 4-1 shows the order of precedence for Java operators, from highest to lowest. Notice
that the first row shows items that you may not normally think of as operators: parentheses,
square brackets, and the dot operator. Technically, these are called separators, but they act
like operators in an expression. Parentheses are used to alter the precedence of an operation.
As you know from the previous chapter, the square brackets provide array indexing. The dot
operator is used to dereference objects and will be discussed later in this book.
Using Parentheses
Parentheses raise the precedence of the operations that are inside them. This is often necessary
to obtain the result you desire. For example, consider the following expression:
a >> b + 3
This expression first adds 3 to b and then shifts a right by that result. That is, this expression
can be rewritten using redundant parentheses like this:
a >> (b + 3)Chapter 4:
T ABLE 4-1
The Precedence of
the Java Operators
Operators
Highest
( ) [ ]
.
++ – – ~
* / %
+ – >> >>> <<
> >= <
== !=
!
<=
&
^
|
&&
||
?:
=
op=
Lowest
However, if you want to first shift a right by b positions and then add 3 to that result,
you will need to parenthesize the expression like this:
(a >> b) + 3
In addition to altering the normal precedence of an operator, parentheses can sometimes
be used to help clarify the meaning of an expression. For anyone reading your code, a
complicated expression can be difficult to understand. Adding redundant but clarifying
parentheses to complex expressions can help prevent confusion later. For example, which of
the following expressions is easier to read?
a | 4 + c >> b & 7
(a | (((4 + c) >> b) & 7))
One other point: parentheses (redundant or not) do not degrade the performance of
your program. Therefore, adding parentheses to reduce ambiguity does not negatively
affect your program.
75This page intentionally left blank5
Control Statements
A
programming language uses control statements to cause the flow of execution to
advance and branch based on changes to the state of a program. Java’s program
control statements can be put into the following categories: selection, iteration, and
jump. Selection statements allow your program to choose different paths of execution based
upon the outcome of an expression or the state of a variable. Iteration statements enable
program execution to repeat one or more statements (that is, iteration statements form
loops). Jump statements allow your program to execute in a nonlinear fashion. All of Java’s
control statements are examined here.
Java’s Selection Statements
Java supports two selection statements: if and switch. These statements allow you to control the
flow of your program’s execution based upon conditions known only during run time. You will
be pleasantly surprised by the power and flexibility contained in these two statements.
if
The if statement was introduced in Chapter 2. It is examined in detail here. The if statement
is Java’s conditional branch statement. It can be used to route program execution through
two different paths. Here is the general form of the if statement:
if (condition) statement1;
else statement2;
Here, each statement may be a single statement or a compound statement enclosed in curly
braces (that is, a block). The condition is any expression that returns a boolean value. The else
clause is optional.
The if works like this: If the condition is true, then statement1 is executed. Otherwise,
statement2 (if it exists) is executed. In no case will both statements be executed. For example,
consider the following:
int a, b;
// ...
if(a < b) a = 0;
else b = 0;
7778
Part I:
The Java Language
Here, if a is less than b, then a is set to zero. Otherwise, b is set to zero. In no case are they
both set to zero.
Most often, the expression used to control the if will involve the relational operators.
However, this is not technically necessary. It is possible to control the if using a single
boolean variable, as shown in this code fragment:
boolean dataAvailable;
// ...
if (dataAvailable)
ProcessData();
else
waitForMoreData();
Remember, only one statement can appear directly after the if or the else. If you want
to include more statements, you’ll need to create a block, as in this fragment:
int bytesAvailable;
// ...
if (bytesAvailable > 0)  else
waitForMoreData();
Here, both statements within the if block will execute if bytesAvailable is greater than zero.
Some programmers find it convenient to include the curly braces when using the if,
even when there is only one statement in each clause. This makes it easy to add another
statement at a later date, and you don’t have to worry about forgetting the braces. In fact,
forgetting to define a block when one is needed is a common cause of errors. For example,
consider the following code fragment:
int bytesAvailable;
// ...
if (bytesAvailable > 0)  else
waitForMoreData();
bytesAvailable = n;
It seems clear that the statement bytesAvailable = n; was intended to be executed inside
the else clause, because of the indentation level. However, as you recall, whitespace is
insignificant to Java, and there is no way for the compiler to know what was intended. This
code will compile without complaint, but it will behave incorrectly when run. The preceding
example is fixed in the code that follows:
int bytesAvailable;
// ...Chapter 5:
Control Statements
if (bytesAvailable > 0)  else 
Nested ifs
A nested if is an if statement that is the target of another if or else. Nested ifs are very common
in programming. When you nest ifs, the main thing to remember is that an else statement
always refers to the nearest if statement that is within the same block as the else and that is
not already associated with an else. Here is an example:
if(i == 10) 
else a = d;
// this else refers to if(i == 10)
As the comments indicate, the final else is not associated with if(j<20) because it is not
in the same block (even though it is the nearest if without an else). Rather, the final else
is associated with if(i==10). The inner else refers to if(k>100) because it is the closest if
within the same block.
The if-else-if Ladder
A common programming construct that is based upon a sequence of nested ifs is the
if-else-if ladder. It looks like this:
if(condition)
statement;
else if(condition)
statement;
else if(condition)
statement;
.
.
.
else
statement;
The if statements are executed from the top down. As soon as one of the conditions controlling
the if is true, the statement associated with that if is executed, and the rest of the ladder is
bypassed. If none of the conditions is true, then the final else statement will be executed.
The final else acts as a default condition; that is, if all other conditional tests fail, then the
7980
Part I:
The Java Language
last else statement is performed. If there is no final else and all other conditions are false,
then no action will take place.
Here is a program that uses an if-else-if ladder to determine which season a particular
month is in.
// Demonstrate if-else-if statements.
class IfElse 
Here is the output produced by the program:
April is in the Spring.
You might want to experiment with this program before moving on. As you will find,
no matter what value you give month, one and only one assignment statement within the
ladder will be executed.
switch
The switch statement is Java’s multiway branch statement. It provides an easy way to dispatch
execution to different parts of your code based on the value of an expression. As such, it often
provides a better alternative than a large series of if-else-if statements. Here is the general form
of a switch statement:
switch (expression) 
The expression must be of type byte, short, int, or char; each of the values specified in the
case statements must be of a type compatible with the expression. (An enumeration value can
also be used to control a switch statement. Enumerations are described in Chapter 12.) Each
case value must be a unique literal (that is, it must be a constant, not a variable). Duplicate case
values are not allowed.
The switch statement works like this: The value of the expression is compared with each
of the literal values in the case statements. If a match is found, the code sequence following
that case statement is executed. If none of the constants matches the value of the expression,
then the default statement is executed. However, the default statement is optional. If no case
matches and no default is present, then no further action is taken.
The break statement is used inside the switch to terminate a statement sequence. When
a break statement is encountered, execution branches to the first line of code that follows the
entire switch statement. This has the effect of “jumping out” of the switch.
Here is a simple example that uses a switch statement:
// A simple example of the switch.
class SampleSwitch 
The output produced by this program is shown here:
i
i
i
i
i
i
is
is
is
is
is
is
zero.
one.
two.
three.
greater than 3.
greater than 3.
8182
Part I:
The Java Language
As you can see, each time through the loop, the statements associated with the case constant
that matches i are executed. All others are bypassed. After i is greater than 3, no case statements
match, so the default statement is executed.
The break statement is optional. If you omit the break, execution will continue on into the
next case. It is sometimes desirable to have multiple cases without break statements between
them. For example, consider the following program:
// In a switch, break statements are optional.
class MissingBreak 
This program generates the following output:
i
i
i
i
i
i
i
i
i
i
i
i
is
is
is
is
is
is
is
is
is
is
is
is
less than 5
less than 5
less than 5
less than 5
less than 5
less than 10
less than 10
less than 10
less than 10
less than 10
10 or more
10 or more
As you can see, execution falls through each case until a break statement (or the end of the
switch) is reached.Chapter 5:
Control Statements
While the preceding example is, of course, contrived for the sake of illustration, omitting the
break statement has many practical applications in real programs. To sample its more realistic
usage, consider the following rewrite of the season example shown earlier. This version uses a
switch to provide a more efficient implementation.
// An improved version of the season program.
class Switch 
Nested switch Statements
You can use a switch as part of the statement sequence of an outer switch. This is called a
nested switch. Since a switch statement defines its own block, no conflicts arise between the
case constants in the inner switch and those in the outer switch. For example, the following
fragment is perfectly valid:
switch(count) {
case 1:
switch(target) 
break;
case 2: // ...
Here, the case 1: statement in the inner switch does not conflict with the case 1: statement in
the outer switch. The count variable is only compared with the list of cases at the outer level.
If count is 1, then target is compared with the inner list cases.
In summary, there are three important features of the switch statement to note:
• The switch differs from the if in that switch can only test for equality, whereas if
can evaluate any type of Boolean expression. That is, the switch looks only for a
match between the value of the expression and one of its case constants.
• No two case constants in the same switch can have identical values. Of course, a
switch statement and an enclosing outer switch can have case constants in common.
• A switch statement is usually more efficient than a set of nested ifs.
The last point is particularly interesting because it gives insight into how the Java compiler
works. When it compiles a switch statement, the Java compiler will inspect each of the case
constants and create a “jump table” that it will use for selecting the path of execution depending
on the value of the expression. Therefore, if you need to select among a large group of values,
a switch statement will run much faster than the equivalent logic coded using a sequence of
if-elses. The compiler can do this because it knows that the case constants are all the same type
and simply must be compared for equality with the switch expression. The compiler has no
such knowledge of a long list of if expressions.
Iteration Statements
Java’s iteration statements are for, while, and do-while. These statements create what we
commonly call loops. As you probably know, a loop repeatedly executes the same set of
instructions until a termination condition is met. As you will see, Java has a loop to fit any
programming need.
while
The while loop is Java’s most fundamental loop statement. It repeats a statement or block
while its controlling expression is true. Here is its general form:
while(condition) 
The condition can be any Boolean expression. The body of the loop will be executed as long
as the conditional expression is true. When condition becomes false, control passes to the
next line of code immediately following the loop. The curly braces are unnecessary if only
a single statement is being repeated.Chapter 5:
Control Statements
Here is a while loop that counts down from 10, printing exactly ten lines of “tick”:
// Demonstrate the while loop.
class While 
When you run this program, it will “tick” ten times:
tick
tick
tick
tick
tick
tick
tick
tick
tick
tick
10
9
8
7
6
5
4
3
2
1
Since the while loop evaluates its conditional expression at the top of the loop, the body
of the loop will not execute even once if the condition is false to begin with. For example, in
the following fragment, the call to println( ) is never executed:
int a = 10, b = 20;
while(a > b)
System.out.println("This will not be displayed");
The body of the while (or any other of Java’s loops) can be empty. This is because a null
statement (one that consists only of a semicolon) is syntactically valid in Java. For example,
consider the following program:
// The target of a loop can be empty.
class NoBody 
This program finds the midpoint between i and j. It generates the following output:
Midpoint is 150
Here is how this while loop works. The value of i is incremented, and the value of j is
decremented. These values are then compared with one another. If the new value of i is still
less than the new value of j, then the loop repeats. If i is equal to or greater than j, the loop
stops. Upon exit from the loop, i will hold a value that is midway between the original values
of i and j. (Of course, this procedure only works when i is less than j to begin with.) As you
can see, there is no need for a loop body; all of the action occurs within the conditional
expression, itself. In professionally written Java code, short loops are frequently coded
without bodies when the controlling expression can handle all of the details itself.
do-while
As you just saw, if the conditional expression controlling a while loop is initially false,
then the body of the loop will not be executed at all. However, sometimes it is desirable
to execute the body of a loop at least once, even if the conditional expression is false to
begin with. In other words, there are times when you would like to test the termination
expression at the end of the loop rather than at the beginning. Fortunately, Java supplies a
loop that does just that: the do-while. The do-while loop always executes its body at least
once, because its conditional expression is at the bottom of the loop. Its general form is
do  while (condition);
Each iteration of the do-while loop first executes the body of the loop and then evaluates
the conditional expression. If this expression is true, the loop will repeat. Otherwise, the loop
terminates. As with all of Java’s loops, condition must be a Boolean expression.
Here is a reworked version of the “tick” program that demonstrates the do-while loop.
It generates the same output as before.
// Demonstrate the do-while loop.
class DoWhile 
The loop in the preceding program, while technically correct, can be written more
efficiently as follows:Chapter 5:
Control Statements
do  while(--n > 0);
In this example, the expression (– –n > 0) combines the decrement of n and the test for zero
into one expression. Here is how it works. First, the – –n statement executes, decrementing
n and returning the new value of n. This value is then compared with zero. If it is greater
than zero, the loop continues; otherwise it terminates.
The do-while loop is especially useful when you process a menu selection, because you
will usually want the body of a menu loop to execute at least once. Consider the following
program, which implements a very simple help system for Java’s selection and iteration
statements:
// Using a do-while to process a menu selection
class Menu 
Here is a sample run produced by this program:
Help on:
1. if
2. switch
3. while
4. do-while
5. for
Choose one:
4
The do-while:
do  while (condition);
In the program, the do-while loop is used to verify that the user has entered a valid choice.
If not, then the user is reprompted. Since the menu must be displayed at least once, the do-
while is the perfect loop to accomplish this.
A few other points about this example: Notice that characters are read from the keyboard
by calling System.in.read( ). This is one of Java’s console input functions. Although Java’s
console I/O methods won’t be discussed in detail until Chapter 13, System.in.read( ) is used
here to obtain the user’s choice. It reads characters from standard input (returned as integers,
which is why the return value was cast to char). By default, standard input is line buffered, so
you must press ENTER before any characters that you type will be sent to your program.
Java’s console input can be a bit awkward to work with. Further, most real-world Java
programs will be graphical and window-based. For these reasons, not much use of console
input has been made in this book. However, it is useful in this context. One other point to
consider: Because System.in.read( ) is being used, the program must specify the throws
java.io.IOException clause. This line is necessary to handle input errors. It is part of Java’s
exception handling features, which are discussed in Chapter 10.
for
You were introduced to a simple form of the for loop in Chapter 2. As you will see, it is a
powerful and versatile construct.Chapter 5:
Control Statements
Beginning with JDK 5, there are two forms of the for loop. The first is the traditional form
that has been in use since the original version of Java. The second is the new “for-each” form.
Both types of for loops are discussed here, beginning with the traditional form.
Here is the general form of the traditional for statement:
for(initialization; condition; iteration) 
If only one statement is being repeated, there is no need for the curly braces.
The for loop operates as follows. When the loop first starts, the initialization portion of
the loop is executed. Generally, this is an expression that sets the value of the loop control
variable, which acts as a counter that controls the loop. It is important to understand that
the initialization expression is only executed once. Next, condition is evaluated. This must be
a Boolean expression. It usually tests the loop control variable against a target value. If this
expression is true, then the body of the loop is executed. If it is false, the loop terminates.
Next, the iteration portion of the loop is executed. This is usually an expression that increments
or decrements the loop control variable. The loop then iterates, first evaluating the conditional
expression, then executing the body of the loop, and then executing the iteration expression
with each pass. This process repeats until the controlling expression is false.
Here is a version of the “tick” program that uses a for loop:
// Demonstrate the for loop.
class ForTick 
Declaring Loop Control Variables Inside the for Loop
Often the variable that controls a for loop is only needed for the purposes of the loop and
is not used elsewhere. When this is the case, it is possible to declare the variable inside the
initialization portion of the for. For example, here is the preceding program recoded so that
the loop control variable n is declared as an int inside the for:
// Declare a loop control variable inside the for.
class ForTick 
When you declare a variable inside a for loop, there is one important point to remember:
the scope of that variable ends when the for statement does. (That is, the scope of the variable
is limited to the for loop.) Outside the for loop, the variable will cease to exist. If you need
8990
Part I:
The Java Language
to use the loop control variable elsewhere in your program, you will not be able to declare
it inside the for loop.
When the loop control variable will not be needed elsewhere, most Java programmers
declare it inside the for. For example, here is a simple program that tests for prime numbers.
Notice that the loop control variable, i, is declared inside the for since it is not needed elsewhere.
// Test for primes.
class FindPrime 
Using the Comma
There will be times when you will want to include more than one statement in the initialization
and iteration portions of the for loop. For example, consider the loop in the following program:
class Sample 
As you can see, the loop is controlled by the interaction of two variables. Since the loop is
governed by two variables, it would be useful if both could be included in the for statement,
itself, instead of b being handled manually. Fortunately, Java provides a way to accomplish
this. To allow two or more variables to control a for loop, Java permits you to include multiple
statements in both the initialization and iteration portions of the for. Each statement is separated
from the next by a comma.
Using the comma, the preceding for loop can be more efficiently coded as shown here:
// Using the comma.
class Comma 
In this example, the initialization portion sets the values of both a and b. The two comma-
separated statements in the iteration portion are executed each time the loop repeats. The
program generates the following output:
a
b
a
b
=
=
=
=
1
4
2
3
N OTE If you are familiar with C/C++, then you know that in those languages the comma is an
operator that can be used in any valid expression. However, this is not the case with Java. In
Java, the comma is a separator.
Some for Loop Variations
The for loop supports a number of variations that increase its power and applicability. The
reason it is so flexible is that its three parts—the initialization, the conditional test, and the
iteration—do not need to be used for only those purposes. In fact, the three sections of the
for can be used for any purpose you desire. Let’s look at some examples.
One of the most common variations involves the conditional expression. Specifically,
this expression does not need to test the loop control variable against some target value. In
fact, the condition controlling the for can be any Boolean expression. For example, consider
the following fragment:
boolean done = false;
for(int i=1; !done; i++) 
In this example, the for loop continues to run until the boolean variable done is set to true.
It does not test the value of i.
Here is another interesting for loop variation. Either the initialization or the iteration
expression or both may be absent, as in this next program:
// Parts of the for loop can be empty.
class ForVar 
Here, the initialization and iteration expressions have been moved out of the for. Thus, parts
of the for are empty. While this is of no value in this simple example—indeed, it would be
considered quite poor style—there can be times when this type of approach makes sense.
For example, if the initial condition is set through a complex expression elsewhere in the
program or if the loop control variable changes in a nonsequential manner determined by
actions that occur within the body of the loop, it may be appropriate to leave these parts of
the for empty.
Here is one more for loop variation. You can intentionally create an infinite loop (a loop
that never terminates) if you leave all three parts of the for empty. For example:
for( ; ; ) 
This loop will run forever because there is no condition under which it will terminate.
Although there are some programs, such as operating system command processors, that
require an infinite loop, most “infinite loops” are really just loops with special termination
requirements. As you will soon see, there is a way to terminate a loop— even an infinite
loop like the one shown—that does not make use of the normal loop conditional expression.
The For-Each Version of the for Loop
Beginning with JDK 5, a second form of for was defined that implements a “for-each” style
loop. As you may know, contemporary language theory has embraced the for-each concept,
and it is quickly becoming a standard feature that programmers have come to expect. A for-
each style loop is designed to cycle through a collection of objects, such as an array, in strictly
sequential fashion, from start to finish. Unlike some languages, such as C#, that implement
a for-each loop by using the keyword foreach, Java adds the for-each capability by enhancing
the for statement. The advantage of this approach is that no new keyword is required, and no
preexisting code is broken. The for-each style of for is also referred to as the enhanced for loop.
The general form of the for-each version of the for is shown here:
for(type itr-var : collection) statement-block
Here, type specifies the type and itr-var specifies the name of an iteration variable that will
receive the elements from a collection, one at a time, from beginning to end. The collection
being cycled through is specified by collection. There are various types of collections that
can be used with the for, but the only type used in this chapter is the array. (Other types of
collections that can be used with the for, such as those defined by the Collections Framework,Chapter 5:
Control Statements
are discussed later in this book.) With each iteration of the loop, the next element in the
collection is retrieved and stored in itr-var. The loop repeats until all elements in the collection
have been obtained.
Because the iteration variable receives values from the collection, type must be the same
as (or compatible with) the elements stored in the collection. Thus, when iterating over arrays,
type must be compatible with the base type of the array.
To understand the motivation behind a for-each style loop, consider the type of for loop
that it is designed to replace. The following fragment uses a traditional for loop to compute
the sum of the values in an array:
int nums[] = ;
int sum = 0;
for(int i=0; i < 10; i++) sum += nums[i];
To compute the sum, each element in nums is read, in order, from start to finish. Thus,
the entire array is read in strictly sequential order. This is accomplished by manually
indexing the nums array by i, the loop control variable.
The for-each style for automates the preceding loop. Specifically, it eliminates the need
to establish a loop counter, specify a starting and ending value, and manually index the
array. Instead, it automatically cycles through the entire array, obtaining one element at
a time, in sequence, from beginning to end. For example, here is the preceding fragment
rewritten using a for-each version of the for:
int nums[] = ;
int sum = 0;
for(int x: nums) sum += x;
With each pass through the loop, x is automatically given a value equal to the next element
in nums. Thus, on the first iteration, x contains 1; on the second iteration, x contains 2; and so on.
Not only is the syntax streamlined, but it also prevents boundary errors.
Here is an entire program that demonstrates the for-each version of the for just described:
// Use a for-each style for loop.
class ForEach 
9394
Part I:
The Java Language
The output from the program is shown here.
Value is: 1
Value is: 2
Value is: 3
Value is: 4
Value is: 5
Value is: 6
Value is: 7
Value is: 8
Value is: 9
Value is: 10
Summation: 55
As this output shows, the for-each style for automatically cycles through an array in sequence
from the lowest index to the highest.
Although the for-each for loop iterates until all elements in an array have been examined,
it is possible to terminate the loop early by using a break statement. For example, this program
sums only the first five elements of nums:
// Use break with a for-each style for.
class ForEach2 
This is the output produced:
Value is:
Value is:
Value is:
Value is:
Value is:
Summation
1
2
3
4
5
of first 5 elements: 15
As is evident, the for loop stops after the fifth element has been obtained. The break statement
can also be used with Java’s other loops, and it is discussed in detail later in this chapter.
There is one important point to understand about the for-each style loop. Its iteration
variable is “read-only” as it relates to the underlying array. An assignment to the
iteration variable has no effect on the underlying array. In other words, you can’t changeChapter 5:
Control Statements
the contents of the array by assigning the iteration variable a new value. For example,
consider this program:
// The for-each loop is essentially read-only.
class NoChange 
The first for loop increases the value of the iteration variable by a factor of 10. However,
this assignment has no effect on the underlying array nums, as the second for loop illustrates.
The output, shown here, proves this point:
1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
Iterating Over Multidimensional Arrays
The enhanced version of the for also works on multidimensional arrays. Remember,
however, that in Java, multidimensional arrays consist of arrays of arrays. (For example,
a two-dimensional array is an array of one-dimensional arrays.) This is important when
iterating over a multidimensional array, because each iteration obtains the next array, not an
individual element. Furthermore, the iteration variable in the for loop must be compatible
with the type of array being obtained. For example, in the case of a two-dimensional array,
the iteration variable must be a reference to a one-dimensional array. In general, when
using the for-each for to iterate over an array of N dimensions, the objects obtained will be
arrays of N–1 dimensions. To understand the implications of this, consider the following
program. It uses nested for loops to obtain the elements of a two-dimensional array in row-
order, from first to last.
// Use for-each style for on a two-dimensional array.
class ForEach3 
The output from this program is shown here:
Value is: 1
Value is: 2
Value is: 3
Value is: 4
Value is: 5
Value is: 2
Value is: 4
Value is: 6
Value is: 8
Value is: 10
Value is: 3
Value is: 6
Value is: 9
Value is: 12
Value is: 15
Summation: 90
In the program, pay special attention to this line:
for(int x[] : nums) {
Notice how x is declared. It is a reference to a one-dimensional array of integers. This is
necessary because each iteration of the for obtains the next array in nums, beginning with
the array specified by nums[0]. The inner for loop then cycles through each of these arrays,
displaying the values of each element.
Applying the Enhanced for
Since the for-each style for can only cycle through an array sequentially, from start to finish,
you might think that its use is limited, but this is not true. A large number of algorithms
require exactly this mechanism. One of the most common is searching. For example, the
following program uses a for loop to search an unsorted array for a value. It stops if the
value is found.Chapter 5:
Control Statements
// Search an array using for-each style for.
class Search 
The for-each style for is an excellent choice in this application because searching an
unsorted array involves examining each element in sequence. (Of course, if the array were
sorted, a binary search could be used, which would require a different style loop.) Other
types of applications that benefit from for-each style loops include computing an average,
finding the minimum or maximum of a set, looking for duplicates, and so on.
Although we have been using arrays in the examples in this chapter, the for-each style
for is especially useful when operating on collections defined by the Collections Framework,
which is described in Part II. More generally, the for can cycle through the elements of any
collection of objects, as long as that collection satisfies a certain set of constraints, which are
described in Chapter 17.
Nested Loops
Like all other programming languages, Java allows loops to be nested. That is, one loop may
be inside another. For example, here is a program that nests for loops:
// Loops may be nested.
class Nested 
9798
Part I:
The Java Language
The output produced by this program is shown here:
..........
.........
........
.......
......
.....
....
...
..
.
Jump Statements
Java supports three jump statements: break, continue, and return. These statements transfer
control to another part of your program. Each is examined here.
N OTE In addition to the jump statements discussed here, Java supports one other way that you
can change your program’s flow of execution: through exception handling. Exception handling
provides a structured method by which run-time errors can be trapped and handled by your
program. It is supported by the keywords try, catch, throw, throws, and finally. In essence,
the exception handling mechanism allows your program to perform a nonlocal branch. Since
exception handling is a large topic, it is discussed in its own chapter, Chapter 10.
Using break
In Java, the break statement has three uses. First, as you have seen, it terminates a statement
sequence in a switch statement. Second, it can be used to exit a loop. Third, it can be used as
a “civilized” form of goto. The last two uses are explained here.
Using break to Exit a Loop
By using break, you can force immediate termination of a loop, bypassing the conditional
expression and any remaining code in the body of the loop. When a break statement is
encountered inside a loop, the loop is terminated and program control resumes at the next
statement following the loop. Here is a simple example:
// Using break to exit a loop.
class BreakLoop Chapter 5:
Control Statements
This program generates the following output:
i: 0
i: 1
i: 2
i: 3
i: 4
i: 5
i: 6
i: 7
i: 8
i: 9
Loop complete.
As you can see, although the for loop is designed to run from 0 to 99, the break statement
causes it to terminate early, when i equals 10.
The break statement can be used with any of Java’s loops, including intentionally
infinite loops. For example, here is the preceding program coded by use of a while loop.
The output from this program is the same as just shown.
// Using break to exit a while loop.
class BreakLoop2 
When used inside a set of nested loops, the break statement will only break out of the
innermost loop. For example:
// Using break with nested loops.
class BreakLoop3 
99100
Part I:
The Java Language
This program generates the following output:
Pass 0: 0 1 2 3 4 5 6 7 8 9
Pass 1: 0 1 2 3 4 5 6 7 8 9
Pass 2: 0 1 2 3 4 5 6 7 8 9
Loops complete.
As you can see, the break statement in the inner loop only causes termination of that loop.
The outer loop is unaffected.
Here are two other points to remember about break. First, more than one break statement
may appear in a loop. However, be careful. Too many break statements have the tendency
to destructure your code. Second, the break that terminates a switch statement affects only
that switch statement and not any enclosing loops.
R EMEMBER break was not designed to provide the normal means by which a loop is terminated.
The loop’s conditional expression serves this purpose. The break statement should be used to
cancel a loop only when some sort of special situation occurs.
Using break as a Form of Goto
In addition to its uses with the switch statement and loops, the break statement can also be
employed by itself to provide a “civilized” form of the goto statement. Java does not have a
goto statement because it provides a way to branch in an arbitrary and unstructured manner.
This usually makes goto-ridden code hard to understand and hard to maintain. It also prohibits
certain compiler optimizations. There are, however, a few places where the goto is a valuable
and legitimate construct for flow control. For example, the goto can be useful when you are
exiting from a deeply nested set of loops. To handle such situations, Java defines an expanded
form of the break statement. By using this form of break, you can, for example, break out of
one or more blocks of code. These blocks need not be part of a loop or a switch. They can be
any block. Further, you can specify precisely where execution will resume, because this form
of break works with a label. As you will see, break gives you the benefits of a goto without its
problems.
The general form of the labeled break statement is shown here:
break label;
Most often, label is the name of a label that identifies a block of code. This can be a stand-alone
block of code but it can also be a block that is the target of another statement. When this form of
break executes, control is transferred out of the named block. The labeled block must enclose
the break statement, but it does not need to be the immediately enclosing block. This means,
for example, that you can use a labeled break statement to exit from a set of nested blocks.
But you cannot use break to transfer control out of a block that does not enclose the break
statement.
To name a block, put a label at the start of it. A label is any valid Java identifier followed
by a colon. Once you have labeled a block, you can then use this label as the target of a
break statement. Doing so causes execution to resume at the end of the labeled block. For
example, the following program shows three nested blocks, each with its own label. The
break statement causes execution to jump forward, past the end of the block labeled second,
skipping the two println( ) statements.Chapter 5:
Control Statements
// Using break as a civilized form of goto.
class Break 
Running this program generates the following output:
Before the break.
This is after second block.
One of the most common uses for a labeled break statement is to exit from nested loops.
For example, in the following program, the outer loop executes only once:
// Using break to exit from nested loops
class BreakLoop4 
This program generates the following output:
Pass 0: 0 1 2 3 4 5 6 7 8 9 Loops complete.
As you can see, when the inner loop breaks to the outer loop, both loops have been terminated.
Notice that this example labels the for statement, which has a block of code as its target.
Keep in mind that you cannot break to any label which is not defined for an enclosing
block. For example, the following program is invalid and will not compile:
// This program contains an error.
class BreakErr 
Since the loop labeled one does not enclose the break statement, it is not possible to transfer
control out of that block.
Using continue
Sometimes it is useful to force an early iteration of a loop. That is, you might want to continue
running the loop but stop processing the remainder of the code in its body for this particular
iteration. This is, in effect, a goto just past the body of the loop, to the loop’s end. The continue
statement performs such an action. In while and do-while loops, a continue statement
causes control to be transferred directly to the conditional expression that controls the loop.
In a for loop, control goes first to the iteration portion of the for statement and then to the
conditional expression. For all three loops, any intermediate code is bypassed.
Here is an example program that uses continue to cause two numbers to be printed on
each line:
// Demonstrate continue.
class Continue 
This code uses the % operator to check if i is even. If it is, the loop continues without printing
a newline. Here is the output from this program:
0
2
4
6
8
1
3
5
7
9
As with the break statement, continue may specify a label to describe which enclosing
loop to continue. Here is an example program that uses continue to print a triangular
multiplication table for 0 through 9.Chapter 5:
Control Statements
// Using continue with a label.
class ContinueLabel 
The continue statement in this example terminates the loop counting j and continues with
the next iteration of the loop counting i. Here is the output of this program:
0
0
0
0
0
0
0
0
0
0
1
2
3
4
5
6
7
8
9
4
6 9
8 12 16
10 15 20
12 18 24
14 21 28
16 24 32
18 27 36
25
30
35
40
45
36
42 49
48 56 64
54 63 72 81
Good uses of continue are rare. One reason is that Java provides a rich set of loop
statements which fit most applications. However, for those special circumstances in which
early iteration is needed, the continue statement provides a structured way to accomplish it.
return
The last control statement is return. The return statement is used to explicitly return from
a method. That is, it causes program control to transfer back to the caller of the method.
As such, it is categorized as a jump statement. Although a full discussion of return must
wait until methods are discussed in Chapter 6, a brief look at return is presented here.
At any time in a method the return statement can be used to cause execution to branch
back to the caller of the method. Thus, the return statement immediately terminates the
method in which it is executed. The following example illustrates this point. Here, return
causes execution to return to the Java run-time system, since it is the run-time system that
calls main( ).
// Demonstrate return.
class Return 
The output from this program is shown here:
Before the return.
As you can see, the final println( ) statement is not executed. As soon as return is executed,
control passes back to the caller.
One last point: In the preceding program, the if(t) statement is necessary. Without it, the
Java compiler would flag an “unreachable code” error because the compiler would know
that the last println( ) statement would never be executed. To prevent this error, the if statement
is used here to trick the compiler for the sake of this demonstration.6
Introducing Classes
T
he class is at the core of Java. It is the logical construct upon which the entire Java
language is built because it defines the shape and nature of an object. As such, the
class forms the basis for object-oriented programming in Java. Any concept you wish
to implement in a Java program must be encapsulated within a class.
Because the class is so fundamental to Java, this and the next few chapters will be devoted
to it. Here, you will be introduced to the basic elements of a class and learn how a class can be
used to create objects. You will also learn about methods, constructors, and the this keyword.
Class Fundamentals
Classes have been used since the beginning of this book. However, until now, only the most
rudimentary form of a class has been used. The classes created in the preceding chapters
primarily exist simply to encapsulate the main( ) method, which has been used to demonstrate
the basics of the Java syntax. As you will see, classes are substantially more powerful than the
limited ones presented so far.
Perhaps the most important thing to understand about a class is that it defines a new data
type. Once defined, this new type can be used to create objects of that type. Thus, a class is
a template for an object, and an object is an instance of a class. Because an object is an instance
of a class, you will often see the two words object and instance used interchangeably.
The General Form of a Class
When you define a class, you declare its exact form and nature. You do this by specifying the
data that it contains and the code that operates on that data. While very simple classes may
contain only code or only data, most real-world classes contain both. As you will see, a class’
code defines the interface to its data.
A class is declared by use of the class keyword. The classes that have been used up to this
point are actually very limited examples of its complete form. Classes can (and usually do)
get much more complex. A simplified general form of a class definition is shown here:
class classname 
The data, or variables, defined within a class are called instance variables. The code is
contained within methods. Collectively, the methods and variables defined within a class are
called members of the class. In most classes, the instance variables are acted upon and accessed
by the methods defined for that class. Thus, as a general rule, it is the methods that determine
how a class’ data can be used.
Variables defined within a class are called instance variables because each instance of the
class (that is, each object of the class) contains its own copy of these variables. Thus, the data
for one object is separate and unique from the data for another. We will come back to this point
shortly, but it is an important concept to learn early.
All methods have the same general form as main( ), which we have been using thus far.
However, most methods will not be specified as static or public. Notice that the general form
of a class does not specify a main( ) method. Java classes do not need to have a main( ) method.
You only specify one if that class is the starting point for your program. Further, applets don’t
require a main( ) method at all.
N OTE C++ programmers will notice that the class declaration and the implementation of the
methods are stored in the same place and not defined separately. This sometimes makes for very
large .java files, since any class must be entirely defined in a single source file. This design feature
was built into Java because it was felt that in the long run, having specification, declaration, and
implementation all in one place makes for code that is easier to maintain.
A Simple Class
Let’s begin our study of the class with a simple example. Here is a class called Box that defines
three instance variables: width, height, and depth. Currently, Box does not contain any
methods (but some will be added soon).
class Box Chapter 6:
Introducing Classes
As stated, a class defines a new type of data. In this case, the new data type is called Box.
You will use this name to declare objects of type Box. It is important to remember that a class
declaration only creates a template; it does not create an actual object. Thus, the preceding
code does not cause any objects of type Box to come into existence.
To actually create a Box object, you will use a statement like the following:
Box mybox = new Box(); // create a Box object called mybox
After this statement executes, mybox will be an instance of Box. Thus, it will have “physical”
reality. For the moment, don’t worry about the details of this statement.
As mentioned earlier, each time you create an instance of a class, you are creating an object
that contains its own copy of each instance variable defined by the class. Thus, every Box
object will contain its own copies of the instance variables width, height, and depth. To
access these variables, you will use the dot (.) operator. The dot operator links the name of the
object with the name of an instance variable. For example, to assign the width variable of
mybox the value 100, you would use the following statement:
mybox.width = 100;
This statement tells the compiler to assign the copy of width that is contained within the
mybox object the value of 100. In general, you use the dot operator to access both the instance
variables and the methods within an object.
Here is a complete program that uses the Box class:
/* A program that uses the Box class.
Call this file BoxDemo.java
*/
class Box 
// This class declares an object of type Box.
class BoxDemo 
107108
Part I:
The Java Language
You should call the file that contains this program BoxDemo.java, because the main( ) method
is in the class called BoxDemo, not the class called Box. When you compile this program, you
will find that two .class files have been created, one for Box and one for BoxDemo. The Java
compiler automatically puts each class into its own .class file. It is not necessary for both the
Box and the BoxDemo class to actually be in the same source file. You could put each class
in its own file, called Box.java and BoxDemo.java, respectively.
To run this program, you must execute BoxDemo.class. When you do, you will see the
following output:
Volume is 3000.0
As stated earlier, each object has its own copies of the instance variables. This means that
if you have two Box objects, each has its own copy of depth, width, and height. It is important
to understand that changes to the instance variables of one object have no effect on the instance
variables of another. For example, the following program declares two Box objects:
// This program declares two Box objects.
class Box 
class BoxDemo2 Chapter 6:
Introducing Classes
The output produced by this program is shown here:
Volume is 3000.0
Volume is 162.0
As you can see, mybox1’s data is completely separate from the data contained in mybox2.
Declaring Objects
As just explained, when you create a class, you are creating a new data type. You can use this
type to declare objects of that type. However, obtaining objects of a class is a two-step process.
First, you must declare a variable of the class type. This variable does not define an object.
Instead, it is simply a variable that can refer to an object. Second, you must acquire an actual,
physical copy of the object and assign it to that variable. You can do this using the new operator.
The new operator dynamically allocates (that is, allocates at run time) memory for an object
and returns a reference to it. This reference is, more or less, the address in memory of the object
allocated by new. This reference is then stored in the variable. Thus, in Java, all class objects
must be dynamically allocated. Let’s look at the details of this procedure.
In the preceding sample programs, a line similar to the following is used to declare an
object of type Box:
Box mybox = new Box();
This statement combines the two steps just described. It can be rewritten like this to show
each step more clearly:
Box mybox; // declare reference to object
mybox = new Box(); // allocate a Box object
The first line declares mybox as a reference to an object of type Box. After this line executes,
mybox contains the value null, which indicates that it does not yet point to an actual object.
Any attempt to use mybox at this point will result in a compile-time error. The next line
allocates an actual object and assigns a reference to it to mybox. After the second line executes,
you can use mybox as if it were a Box object. But in reality, mybox simply holds the memory
address of the actual Box object. The effect of these two lines of code is depicted in Figure 6-1.
N OTE Those readers familiar with C/C++ have probably noticed that object references appear to be
similar to pointers. This suspicion is, essentially, correct. An object reference is similar to a memory
pointer. The main difference—and the key to Java’s safety—is that you cannot manipulate references
as you can actual pointers. Thus, you cannot cause an object reference to point to an arbitrary
memory location or manipulate it like an integer.
A Closer Look at new
As just explained, the new operator dynamically allocates memory for an object. It has this
general form:
class-var = new classname( );
109110
Part I:
The Java Language
F IGURE 6-1
Declaring an object
of type Box
Here, class-var is a variable of the class type being created. The classname is the name of the
class that is being instantiated. The class name followed by parentheses specifies the constructor
for the class. A constructor defines what occurs when an object of a class is created. Constructors
are an important part of all classes and have many significant attributes. Most real-world
classes explicitly define their own constructors within their class definition. However, if no
explicit constructor is specified, then Java will automatically supply a default constructor.
This is the case with Box. For now, we will use the default constructor. Soon, you will see
how to define your own constructors.
At this point, you might be wondering why you do not need to use new for such things
as integers or characters. The answer is that Java’s primitive types are not implemented as
objects. Rather, they are implemented as “normal” variables. This is done in the interest of
efficiency. As you will see, objects have many features and attributes that require Java to treat
them differently than it treats the primitive types. By not applying the same overhead to the
primitive types that applies to objects, Java can implement the primitive types more efficiently.
Later, you will see object versions of the primitive types that are available for your use in
those situations in which complete objects of these types are needed.
It is important to understand that new allocates memory for an object during run time.
The advantage of this approach is that your program can create as many or as few objects as
it needs during the execution of your program. However, since memory is finite, it is possible
that new will not be able to allocate memory for an object because insufficient memory exists.
If this happens, a run-time exception will occur. (You will learn how to handle this and other
exceptions in Chapter 10.) For the sample programs in this book, you won’t need to worry
about running out of memory, but you will need to consider this possibility in real-world
programs that you write.
Let’s once again review the distinction between a class and an object. A class creates a
new data type that can be used to create objects. That is, a class creates a logical framework
that defines the relationship between its members. When you declare an object of a class, you
are creating an instance of that class. Thus, a class is a logical construct. An object has physical
reality. (That is, an object occupies space in memory.) It is important to keep this distinction
clearly in mind.Chapter 6:
Introducing Classes
Assigning Object Reference Variables
Object reference variables act differently than you might expect when an assignment takes
place. For example, what do you think the following fragment does?
Box b1 = new Box();
Box b2 = b1;
You might think that b2 is being assigned a reference to a copy of the object referred to by
b1. That is, you might think that b1 and b2 refer to separate and distinct objects. However,
this would be wrong. Instead, after this fragment executes, b1 and b2 will both refer to the
same object. The assignment of b1 to b2 did not allocate any memory or copy any part of the
original object. It simply makes b2 refer to the same object as does b1. Thus, any changes
made to the object through b2 will affect the object to which b1 is referring, since they are the
same object.
This situation is depicted here:
Although b1 and b2 both refer to the same object, they are not linked in any other way.
For example, a subsequent assignment to b1 will simply unhook b1 from the original object
without affecting the object or affecting b2. For example:
Box b1 = new Box();
Box b2 = b1;
// ...
b1 = null;
Here, b1 has been set to null, but b2 still points to the original object.
R EMEMBER When you assign one object reference variable to another object reference variable,
you are not creating a copy of the object, you are only making a copy of the reference.
Introducing Methods
As mentioned at the beginning of this chapter, classes usually consist of two things: instance
variables and methods. The topic of methods is a large one because Java gives them so much
power and flexibility. In fact, much of the next chapter is devoted to methods. However, there
are some fundamentals that you need to learn now so that you can begin to add methods to
your classes.
111112
Part I:
The Java Language
This is the general form of a method:
type name(parameter-list) 
Here, type specifies the type of data returned by the method. This can be any valid type,
including class types that you create. If the method does not return a value, its return type
must be void. The name of the method is specified by name. This can be any legal identifier
other than those already used by other items within the current scope. The parameter-list is a
sequence of type and identifier pairs separated by commas. Parameters are essentially variables
that receive the value of the arguments passed to the method when it is called. If the method
has no parameters, then the parameter list will be empty.
Methods that have a return type other than void return a value to the calling routine using
the following form of the return statement:
return value;
Here, value is the value returned.
In the next few sections, you will see how to create various types of methods, including
those that take parameters and those that return values.
Adding a Method to the Box Class
Although it is perfectly fine to create a class that contains only data, it rarely happens. Most
of the time, you will use methods to access the instance variables defined by the class. In fact,
methods define the interface to most classes. This allows the class implementor to hide the
specific layout of internal data structures behind cleaner method abstractions. In addition
to defining methods that provide access to data, you can also define methods that are used
internally by the class itself.
Let’s begin by adding a method to the Box class. It may have occurred to you while looking
at the preceding programs that the computation of a box’s volume was something that was
best handled by the Box class rather than the BoxDemo class. After all, since the volume of
a box is dependent upon the size of the box, it makes sense to have the Box class compute it.
To do this, you must add a method to Box, as shown here:
// This program includes a method inside the box class.
class Box Chapter 6:
Introducing Classes
class BoxDemo3 
This program generates the following output, which is the same as the previous version.
Volume is 3000.0
Volume is 162.0
Look closely at the following two lines of code:
mybox1.volume();
mybox2.volume();
The first line here invokes the volume( ) method on mybox1. That is, it calls volume( )
relative to the mybox1 object, using the object’s name followed by the dot operator. Thus,
the call to mybox1.volume( ) displays the volume of the box defined by mybox1, and the
call to mybox2.volume( ) displays the volume of the box defined by mybox2. Each time
volume( ) is invoked, it displays the volume for the specified box.
If you are unfamiliar with the concept of calling a method, the following discussion will
help clear things up. When mybox1.volume( ) is executed, the Java run-time system transfers
control to the code defined inside volume( ). After the statements inside volume( ) have
executed, control is returned to the calling routine, and execution resumes with the line of
code following the call. In the most general sense, a method is Java’s way of implementing
subroutines.
There is something very important to notice inside the volume( ) method: the instance
variables width, height, and depth are referred to directly, without preceding them with an
object name or the dot operator. When a method uses an instance variable that is defined by
its class, it does so directly, without explicit reference to an object and without use of the dot
operator. This is easy to understand if you think about it. A method is always invoked relative
to some object of its class. Once this invocation has occurred, the object is known. Thus, within
113114
Part I:
The Java Language
a method, there is no need to specify the object a second time. This means that width, height,
and depth inside volume( ) implicitly refer to the copies of those variables found in the object
that invokes volume( ).
Let’s review: When an instance variable is accessed by code that is not part of the class
in which that instance variable is defined, it must be done through an object, by use of the
dot operator. However, when an instance variable is accessed by code that is part of the same
class as the instance variable, that variable can be referred to directly. The same thing applies
to methods.
Returning a Value
While the implementation of volume( ) does move the computation of a box’s volume inside
the Box class where it belongs, it is not the best way to do it. For example, what if another
part of your program wanted to know the volume of a box, but not display its value? A better
way to implement volume( ) is to have it compute the volume of the box and return the result
to the caller. The following example, an improved version of the preceding program, does
just that:
// Now, volume() returns the volume of a box.
class Box 
class BoxDemo4 
As you can see, when volume( ) is called, it is put on the right side of an assignment
statement. On the left is a variable, in this case vol, that will receive the value returned by
volume( ). Thus, after
vol = mybox1.volume();
executes, the value of mybox1.volume( ) is 3,000 and this value then is stored in vol.
There are two important things to understand about returning values:
• The type of data returned by a method must be compatible with the return type
specified by the method. For example, if the return type of some method is boolean,
you could not return an integer.
• The variable receiving the value returned by a method (such as vol, in this case) must
also be compatible with the return type specified for the method.
One more point: The preceding program can be written a bit more efficiently because
there is actually no need for the vol variable. The call to volume( ) could have been used in
the println( ) statement directly, as shown here:
System.out.println("Volume is " + mybox1.volume());
In this case, when println( ) is executed, mybox1.volume( ) will be called automatically and
its value will be passed to println( ).
Adding a Method That Takes Parameters
While some methods don’t need parameters, most do. Parameters allow a method to be
generalized. That is, a parameterized method can operate on a variety of data and/or be used
in a number of slightly different situations. To illustrate this point, let’s use a very simple
example. Here is a method that returns the square of the number 10:
int square()

While this method does, indeed, return the value of 10 squared, its use is very limited.
However, if you modify the method so that it takes a parameter, as shown next, then you
can make square( ) much more useful.
int square(int i)

115116
Part I:
The Java Language
Now, square( ) will return the square of whatever value it is called with. That is, square( ) is
now a general-purpose method that can compute the square of any integer value, rather than
just 10.
Here is an example:
int
x =
x =
y =
x =
x, y;
square(5); // x equals 25
square(9); // x equals 81
2;
square(y); // x equals 4
In the first call to square( ), the value 5 will be passed into parameter i. In the second call, i
will receive the value 9. The third invocation passes the value of y, which is 2 in this example.
As these examples show, square( ) is able to return the square of whatever data it is passed.
It is important to keep the two terms parameter and argument straight. A parameter is a
variable defined by a method that receives a value when the method is called. For example,
in square( ), i is a parameter. An argument is a value that is passed to a method when it is
invoked. For example, square(100) passes 100 as an argument. Inside square( ), the parameter i
receives that value.
You can use a parameterized method to improve the Box class. In the preceding examples,
the dimensions of each box had to be set separately by use of a sequence of statements, such as:
mybox1.width = 10;
mybox1.height = 20;
mybox1.depth = 15;
While this code works, it is troubling for two reasons. First, it is clumsy and error prone. For
example, it would be easy to forget to set a dimension. Second, in well-designed Java programs,
instance variables should be accessed only through methods defined by their class. In the
future, you can change the behavior of a method, but you can’t change the behavior of an
exposed instance variable.
Thus, a better approach to setting the dimensions of a box is to create a method that takes
the dimensions of a box in its parameters and sets each instance variable appropriately. This
concept is implemented by the following program:
// This program uses a parameterized method.
class Box 
class BoxDemo5 
As you can see, the setDim( ) method is used to set the dimensions of each box. For
example, when
mybox1.setDim(10, 20, 15);
is executed, 10 is copied into parameter w, 20 is copied into h, and 15 is copied into d. Inside
setDim( ) the values of w, h, and d are then assigned to width, height, and depth, respectively.
For many readers, the concepts presented in the preceding sections will be familiar.
However, if such things as method calls, arguments, and parameters are new to you, then you
might want to take some time to experiment before moving on. The concepts of the method
invocation, parameters, and return values are fundamental to Java programming.
Constructors
It can be tedious to initialize all of the variables in a class each time an instance is created. Even
when you add convenience functions like setDim( ), it would be simpler and more concise
to have all of the setup done at the time the object is first created. Because the requirement
for initialization is so common, Java allows objects to initialize themselves when they are
created. This automatic initialization is performed through the use of a constructor.
A constructor initializes an object immediately upon creation. It has the same name as the
class in which it resides and is syntactically similar to a method. Once defined, the constructor
is automatically called immediately after the object is created, before the new operator completes.
Constructors look a little strange because they have no return type, not even void. This is
because the implicit return type of a class’ constructor is the class type itself. It is the constructor’s
job to initialize the internal state of an object so that the code creating an instance will have
a fully initialized, usable object immediately.
117118
Part I:
The Java Language
You can rework the Box example so that the dimensions of a box are automatically
initialized when an object is constructed. To do so, replace setDim( ) with a constructor.
Let’s begin by defining a simple constructor that simply sets the dimensions of each box
to the same values. This version is shown here:
/* Here, Box uses a constructor to initialize the
dimensions of a box.
*/
class Box 
class BoxDemo6 
When this program is run, it generates the following results:
Constructing Box
Constructing Box
Volume is 1000.0
Volume is 1000.0Chapter 6:
Introducing Classes
As you can see, both mybox1 and mybox2 were initialized by the Box( ) constructor when
they were created. Since the constructor gives all boxes the same dimensions, 10 by 10 by 10,
both mybox1 and mybox2 will have the same volume. The println( ) statement inside Box( )
is for the sake of illustration only. Most constructors will not display anything. They will
simply initialize an object.
Before moving on, let’s reexamine the new operator. As you know, when you allocate an
object, you use the following general form:
class-var = new classname( );
Now you can understand why the parentheses are needed after the class name. What is actually
happening is that the constructor for the class is being called. Thus, in the line
Box mybox1 = new Box();
new Box( ) is calling the Box( ) constructor. When you do not explicitly define a constructor
for a class, then Java creates a default constructor for the class. This is why the preceding line
of code worked in earlier versions of Box that did not define a constructor. The default
constructor automatically initializes all instance variables to zero. The default constructor is
often sufficient for simple classes, but it usually won’t do for more sophisticated ones. Once
you define your own constructor, the default constructor is no longer used.
Parameterized Constructors
While the Box( ) constructor in the preceding example does initialize a Box object, it is not
very useful—all boxes have the same dimensions. What is needed is a way to construct Box
objects of various dimensions. The easy solution is to add parameters to the constructor. As
you can probably guess, this makes them much more useful. For example, the following version
of Box defines a parameterized constructor that sets the dimensions of a box as specified by
those parameters. Pay special attention to how Box objects are created.
/* Here, Box uses a parameterized constructor to
initialize the dimensions of a box.
*/
class Box 
119120
Part I:
The Java Language
class BoxDemo7 
The output from this program is shown here:
Volume is 3000.0
Volume is 162.0
As you can see, each object is initialized as specified in the parameters to its constructor.
For example, in the following line,
Box mybox1 = new Box(10, 20, 15);
the values 10, 20, and 15 are passed to the Box( ) constructor when new creates the object.
Thus, mybox1’s copy of width, height, and depth will contain the values 10, 20, and 15,
respectively.
The this Keyword
Sometimes a method will need to refer to the object that invoked it. To allow this, Java defines
the this keyword. this can be used inside any method to refer to the current object. That is,
this is always a reference to the object on which the method was invoked. You can use this
anywhere a reference to an object of the current class’ type is permitted.
To better understand what this refers to, consider the following version of Box( ):
// A redundant use of this.
Box(double w, double h, double d) 
This version of Box( ) operates exactly like the earlier version. The use of this is redundant,
but perfectly correct. Inside Box( ), this will always refer to the invoking object. While it is
redundant in this case, this is useful in other contexts, one of which is explained in the next
section.Chapter 6:
Introducing Classes
Instance Variable Hiding
As you know, it is illegal in Java to declare two local variables with the same name inside
the same or enclosing scopes. Interestingly, you can have local variables, including formal
parameters to methods, which overlap with the names of the class’ instance variables. However,
when a local variable has the same name as an instance variable, the local variable hides the
instance variable. This is why width, height, and depth were not used as the names of the
parameters to the Box( ) constructor inside the Box class. If they had been, then width would
have referred to the formal parameter, hiding the instance variable width. While it is usually
easier to simply use different names, there is another way around this situation. Because this
lets you refer directly to the object, you can use it to resolve any name space collisions that
might occur between instance variables and local variables. For example, here is another
version of Box( ), which uses width, height, and depth for parameter names and then uses
this to access the instance variables by the same name:
// Use this to resolve name-space collisions.
Box(double width, double height, double depth) 
A word of caution: The use of this in such a context can sometimes be confusing, and
some programmers are careful not to use local variables and formal parameter names that
hide instance variables. Of course, other programmers believe the contrary—that it is a good
convention to use the same names for clarity, and use this to overcome the instance variable
hiding. It is a matter of taste which approach you adopt.
Garbage Collection
Since objects are dynamically allocated by using the new operator, you might be wondering
how such objects are destroyed and their memory released for later reallocation. In some
languages, such as C++, dynamically allocated objects must be manually released by use of
a delete operator. Java takes a different approach; it handles deallocation for you automatically.
The technique that accomplishes this is called garbage collection. It works like this: when no
references to an object exist, that object is assumed to be no longer needed, and the memory
occupied by the object can be reclaimed. There is no explicit need to destroy objects as in C++.
Garbage collection only occurs sporadically (if at all) during the execution of your program.
It will not occur simply because one or more objects exist that are no longer used. Furthermore,
different Java run-time implementations will take varying approaches to garbage collection,
but for the most part, you should not have to think about it while writing your programs.
The finalize( ) Method
Sometimes an object will need to perform some action when it is destroyed. For example, if
an object is holding some non-Java resource such as a file handle or character font, then you
might want to make sure these resources are freed before an object is destroyed. To handle
121122
Part I:
The Java Language
such situations, Java provides a mechanism called finalization. By using finalization, you can
define specific actions that will occur when an object is just about to be reclaimed by the
garbage collector.
To add a finalizer to a class, you simply define the finalize( ) method. The Java run time
calls that method whenever it is about to recycle an object of that class. Inside the finalize( )
method, you will specify those actions that must be performed before an object is destroyed.
The garbage collector runs periodically, checking for objects that are no longer referenced by
any running state or indirectly through other referenced objects. Right before an asset is freed,
the Java run time calls the finalize( ) method on the object.
The finalize( ) method has this general form:
protected void finalize( )

Here, the keyword protected is a specifier that prevents access to finalize( ) by code defined
outside its class. This and the other access specifiers are explained in Chapter 7.
It is important to understand that finalize( ) is only called just prior to garbage collection.
It is not called when an object goes out-of-scope, for example. This means that you cannot
know when—or even if—finalize( ) will be executed. Therefore, your program should provide
other means of releasing system resources, etc., used by the object. It must not rely on finalize( )
for normal program operation.
N OTE If you are familiar with C++, then you know that C++ allows you to define a destructor for
a class, which is called when an object goes out-of-scope. Java does not support this idea or provide
for destructors. The finalize( ) method only approximates the function of a destructor. As you
get more experienced with Java, you will see that the need for destructor functions is minimal
because of Java’s garbage collection subsystem.
A Stack Class
While the Box class is useful to illustrate the essential elements of a class, it is of little practical
value. To show the real power of classes, this chapter will conclude with a more sophisticated
example. As you recall from the discussion of object-oriented programming (OOP) presented in
Chapter 2, one of OOP’s most important benefits is the encapsulation of data and the code that
manipulates that data. As you have seen, the class is the mechanism by which encapsulation
is achieved in Java. By creating a class, you are creating a new data type that defines both the
nature of the data being manipulated and the routines used to manipulate it. Further, the
methods define a consistent and controlled interface to the class’ data. Thus, you can use
the class through its methods without having to worry about the details of its implementation
or how the data is actually managed within the class. In a sense, a class is like a “data engine.”
No knowledge of what goes on inside the engine is required to use the engine through its
controls. In fact, since the details are hidden, its inner workings can be changed as needed.
As long as your code uses the class through its methods, internal details can change without
causing side effects outside the class.Chapter 6:
Introducing Classes
To see a practical application of the preceding discussion, let’s develop one of the
archetypal examples of encapsulation: the stack. A stack stores data using first-in, last-out
ordering. That is, a stack is like a stack of plates on a table—the first plate put down on the
table is the last plate to be used. Stacks are controlled through two operations traditionally
called push and pop. To put an item on top of the stack, you will use push. To take an item off
the stack, you will use pop. As you will see, it is easy to encapsulate the entire stack mechanism.
Here is a class called Stack that implements a stack for integers:
// This class defines an integer stack that can hold 10 values.
class Stack 
As you can see, the Stack class defines two data items and three methods. The stack of integers
is held by the array stck. This array is indexed by the variable tos, which always contains the
index of the top of the stack. The Stack( ) constructor initializes tos to –1, which indicates an
empty stack. The method push( ) puts an item on the stack. To retrieve an item, call pop( ).
Since access to the stack is through push( ) and pop( ), the fact that the stack is held in an
array is actually not relevant to using the stack. For example, the stack could be held in a
more complicated data structure, such as a linked list, yet the interface defined by push( )
and pop( ) would remain the same.
The class TestStack, shown here, demonstrates the Stack class. It creates two integer stacks,
pushes some values onto each, and then pops them off.
class TestStack 
This program generates the following output:
Stack in mystack1:
9
8
7
6
5
4
3
2
1
0
Stack in mystack2:
19
18
17
16
15
14
13
12
11
10
As you can see, the contents of each stack are separate.
One last point about the Stack class. As it is currently implemented, it is possible for the
array that holds the stack, stck, to be altered by code outside of the Stack class. This leaves
Stack open to misuse or mischief. In the next chapter, you will see how to remedy this situation.7
A Closer Look at
Methods and Classes
T
his chapter continues the discussion of methods and classes begun in the preceding
chapter. It examines several topics relating to methods, including overloading, parameter
passing, and recursion. The chapter then returns to the class, discussing access control,
the use of the keyword static, and one of Java’s most important built-in classes: String.
Overloading Methods
In Java it is possible to define two or more methods within the same class that share the
same name, as long as their parameter declarations are different. When this is the case, the
methods are said to be overloaded, and the process is referred to as method overloading. Method
overloading is one of the ways that Java supports polymorphism. If you have never used
a language that allows the overloading of methods, then the concept may seem strange at
first. But as you will see, method overloading is one of Java’s most exciting and useful features.
When an overloaded method is invoked, Java uses the type and/or number of
arguments as its guide to determine which version of the overloaded method to actually
call. Thus, overloaded methods must differ in the type and/or number of their parameters.
While overloaded methods may have different return types, the return type alone is
insufficient to distinguish two versions of a method. When Java encounters a call to an
overloaded method, it simply executes the version of the method whose parameters match
the arguments used in the call.
Here is a simple example that illustrates method overloading:
// Demonstrate method overloading.
class OverloadDemo 
class Overload 
This program generates the following output:
No parameters
a: 10
a and b: 10 20
double a: 123.25
Result of ob.test(123.25): 15190.5625
As you can see, test( ) is overloaded four times. The first version takes no parameters,
the second takes one integer parameter, the third takes two integer parameters, and the
fourth takes one double parameter. The fact that the fourth version of test( ) also returns a
value is of no consequence relative to overloading, since return types do not play a role in
overload resolution.
When an overloaded method is called, Java looks for a match between the arguments
used to call the method and the method’s parameters. However, this match need not always
be exact. In some cases, Java’s automatic type conversions can play a role in overload resolution.
For example, consider the following program:
// Automatic type conversions apply to overloading.
class OverloadDemo 
class Overload 
This program generates the following output:
No parameters
a and b: 10 20
Inside test(double) a: 88
Inside test(double) a: 123.2
As you can see, this version of OverloadDemo does not define test(int). Therefore, when
test( ) is called with an integer argument inside Overload, no matching method is found.
However, Java can automatically convert an integer into a double, and this conversion can
be used to resolve the call. Therefore, after test(int) is not found, Java elevates i to double
and then calls test(double). Of course, if test(int) had been defined, it would have been called
instead. Java will employ its automatic type conversions only if no exact match is found.
Method overloading supports polymorphism because it is one way that Java implements
the “one interface, multiple methods” paradigm. To understand how, consider the following.
In languages that do not support method overloading, each method must be given a unique
name. However, frequently you will want to implement essentially the same method for
different types of data. Consider the absolute value function. In languages that do not
support overloading, there are usually three or more versions of this function, each with a
slightly different name. For instance, in C, the function abs( ) returns the absolute value of
an integer, labs( ) returns the absolute value of a long integer, and fabs( ) returns the absolute
value of a floating-point value. Since C does not support overloading, each function has to
have its own name, even though all three functions do essentially the same thing. This makes
the situation more complex, conceptually, than it actually is. Although the underlying concept
of each function is the same, you still have three names to remember. This situation does not
occur in Java, because each absolute value method can use the same name. Indeed, Java’s
127128
Part I:
The Java Language
standard class library includes an absolute value method, called abs( ). This method is
overloaded by Java’s Math class to handle all numeric types. Java determines which version
of abs( ) to call based upon the type of argument.
The value of overloading is that it allows related methods to be accessed by use of a
common name. Thus, the name abs represents the general action that is being performed. It
is left to the compiler to choose the right specific version for a particular circumstance. You,
the programmer, need only remember the general operation being performed. Through the
application of polymorphism, several names have been reduced to one. Although this
example is fairly simple, if you expand the concept, you can see how overloading can help
you manage greater complexity.
When you overload a method, each version of that method can perform any activity
you desire. There is no rule stating that overloaded methods must relate to one another.
However, from a stylistic point of view, method overloading implies a relationship. Thus,
while you can use the same name to overload unrelated methods, you should not. For
example, you could use the name sqr to create methods that return the square of an integer
and the square root of a floating-point value. But these two operations are fundamentally
different. Applying method overloading in this manner defeats its original purpose. In
practice, you should only overload closely related operations.
Overloading Constructors
In addition to overloading normal methods, you can also overload constructor methods. In
fact, for most real-world classes that you create, overloaded constructors will be the norm,
not the exception. To understand why, let’s return to the Box class developed in the preceding
chapter. Following is the latest version of Box:
class Box 
As you can see, the Box( ) constructor requires three parameters. This means that all
declarations of Box objects must pass three arguments to the Box( ) constructor. For example,
the following statement is currently invalid:
Box ob = new Box();Chapter 7:
A Closer Look at Methods and Classes
Since Box( ) requires three arguments, it’s an error to call it without them. This raises
some important questions. What if you simply wanted a box and did not care (or know)
what its initial dimensions were? Or, what if you want to be able to initialize a cube by
specifying only one value that would be used for all three dimensions? As the Box class
is currently written, these other options are not available to you.
Fortunately, the solution to these problems is quite easy: simply overload the Box
constructor so that it handles the situations just described. Here is a program that contains
an improved version of Box that does just that:
/* Here, Box defines three constructors to initialize
the dimensions of a box various ways.
*/
class Box 
class OverloadCons 
The output produced by this program is shown here:
Volume of mybox1 is 3000.0
Volume of mybox2 is -1.0
Volume of mycube is 343.0
As you can see, the proper overloaded constructor is called based upon the parameters
specified when new is executed.
Using Objects as Parameters
So far, we have only been using simple types as parameters to methods. However, it is both
correct and common to pass objects to methods. For example, consider the following short
program:
// Objects may be passed to methods.
class Test 
class PassOb 
This program generates the following output:
ob1 == ob2: true
ob1 == ob3: false
As you can see, the equals( ) method inside Test compares two objects for equality and
returns the result. That is, it compares the invoking object with the one that it is passed. If
they contain the same values, then the method returns true. Otherwise, it returns false. Notice
that the parameter o in equals( ) specifies Test as its type. Although Test is a class type created
by the program, it is used in just the same way as Java’s built-in types.
One of the most common uses of object parameters involves constructors. Frequently, you
will want to construct a new object so that it is initially the same as some existing object. To do
this, you must define a constructor that takes an object of its class as a parameter. For example,
the following version of Box allows one object to initialize another:
// Here, Box allows one object to initialize another.
class Box 
class OverloadCons2 
As you will see when you begin to create your own classes, providing many forms
of constructors is usually required to allow objects to be constructed in a convenient and
efficient manner.
A Closer Look at Argument Passing
In general, there are two ways that a computer language can pass an argument to a subroutine.
The first way is call-by-value. This approach copies the value of an argument into the formal
parameter of the subroutine. Therefore, changes made to the parameter of the subroutine
have no effect on the argument. The second way an argument can be passed is call-by-reference.
In this approach, a reference to an argument (not the value of the argument) is passed to the
parameter. Inside the subroutine, this reference is used to access the actual argument specified
in the call. This means that changes made to the parameter will affect the argument used to
call the subroutine. As you will see, Java uses both approaches, depending upon what is passed.
In Java, when you pass a primitive type to a method, it is passed by value. Thus, what
occurs to the parameter that receives the argument has no effect outside the method. For
example, consider the following program:Chapter 7:
A Closer Look at Methods and Classes
// Primitive types are passed by value.
class Test 
class CallByValue 
The output from this program is shown here:
a and b before call: 15 20
a and b after call: 15 20
As you can see, the operations that occur inside meth( ) have no effect on the values of a and b
used in the call; their values here did not change to 30 and 10.
When you pass an object to a method, the situation changes dramatically, because objects
are passed by what is effectively call-by-reference. Keep in mind that when you create a
variable of a class type, you are only creating a reference to an object. Thus, when you pass
this reference to a method, the parameter that receives it will refer to the same object as that
referred to by the argument. This effectively means that objects are passed to methods by use
of call-by-reference. Changes to the object inside the method do affect the object used as an
argument. For example, consider the following program:
// Objects are passed by reference.
class Test 
class CallByRef 
This program generates the following output:
ob.a and ob.b before call: 15 20
ob.a and ob.b after call: 30 10
As you can see, in this case, the actions inside meth( ) have affected the object used as an
argument.
As a point of interest, when an object reference is passed to a method, the reference itself
is passed by use of call-by-value. However, since the value being passed refers to an object,
the copy of that value will still refer to the same object that its corresponding argument does.
R EMEMBER When a primitive type is passed to a method, it is done by use of call-by-value. Objects
are implicitly passed by use of call-by-reference.
Returning Objects
A method can return any type of data, including class types that you create. For example, in
the following program, the incrByTen( ) method returns an object in which the value of a is
ten greater than it is in the invoking object.
// Returning an object.
class Test 
class RetOb 
The output generated by this program is shown here:
ob1.a: 2
ob2.a: 12
ob2.a after second increase: 22
As you can see, each time incrByTen( ) is invoked, a new object is created, and a reference
to it is returned to the calling routine.
The preceding program makes another important point: Since all objects are dynamically
allocated using new, you don’t need to worry about an object going out-of-scope because the
method in which it was created terminates. The object will continue to exist as long as there is
a reference to it somewhere in your program. When there are no references to it, the object will
be reclaimed the next time garbage collection takes place.
Recursion
Java supports recursion. Recursion is the process of defining something in terms of itself. As
it relates to Java programming, recursion is the attribute that allows a method to call itself.
A method that calls itself is said to be recursive.
The classic example of recursion is the computation of the factorial of a number. The
factorial of a number N is the product of all the whole numbers between 1 and N. For
example, 3 factorial is 1 × 2 × 3, or 6. Here is how a factorial can be computed by use of a
recursive method:
// A simple example of recursion.
class Factorial 
class Recursion 
The output from this program is shown here:
Factorial of 3 is 6
Factorial of 4 is 24
Factorial of 5 is 120
If you are unfamiliar with recursive methods, then the operation of fact( ) may seem a
bit confusing. Here is how it works. When fact( ) is called with an argument of 1, the function
returns 1; otherwise, it returns the product of fact(n–1)*n. To evaluate this expression, fact( )
is called with n–1. This process repeats until n equals 1 and the calls to the method begin
returning.
To better understand how the fact( ) method works, let’s go through a short example.
When you compute the factorial of 3, the first call to fact( ) will cause a second call to be
made with an argument of 2. This invocation will cause fact( ) to be called a third time with
an argument of 1. This call will return 1, which is then multiplied by 2 (the value of n in the
second invocation). This result (which is 2) is then returned to the original invocation of
fact( ) and multiplied by 3 (the original value of n). This yields the answer, 6. You might
find it interesting to insert println( ) statements into fact( ), which will show at what level
each call is and what the intermediate answers are.
When a method calls itself, new local variables and parameters are allocated storage
on the stack, and the method code is executed with these new variables from the start.
As each recursive call returns, the old local variables and parameters are removed from
the stack, and execution resumes at the point of the call inside the method. Recursive
methods could be said to “telescope” out and back.
Recursive versions of many routines may execute a bit more slowly than the iterative
equivalent because of the added overhead of the additional function calls. Many recursive
calls to a method could cause a stack overrun. Because storage for parameters and local
variables is on the stack and each new call creates a new copy of these variables, it is possible
that the stack could be exhausted. If this occurs, the Java run-time system will cause an
exception. However, you probably will not have to worry about this unless a recursive
routine runs wild.
The main advantage to recursive methods is that they can be used to create clearer and
simpler versions of several algorithms than can their iterative relatives. For example, the
QuickSort sorting algorithm is quite difficult to implement in an iterative way. Also, some types
of AI-related algorithms are most easily implemented using recursive solutions.Chapter 7:
A Closer Look at Methods and Classes
When writing recursive methods, you must have an if statement somewhere to force the
method to return without the recursive call being executed. If you don’t do this, once you
call the method, it will never return. This is a very common error in working with recursion.
Use println( ) statements liberally during development so that you can watch what is going
on and abort execution if you see that you have made a mistake.
Here is one more example of recursion. The recursive method printArray( ) prints the
first i elements in the array values.
// Another example that uses recursion.
class RecTest 
class Recursion2 
This program generates the following output:
[0]
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
0
1
2
3
4
5
6
7
8
9
137138
Part I:
The Java Language
Introducing Access Control
As you know, encapsulation links data with the code that manipulates it. However,
encapsulation provides another important attribute: access control. Through encapsulation,
you can control what parts of a program can access the members of a class. By controlling
access, you can prevent misuse. For example, allowing access to data only through a well-
defined set of methods, you can prevent the misuse of that data. Thus, when correctly
implemented, a class creates a “black box” which may be used, but the inner workings
of which are not open to tampering. However, the classes that were presented earlier do
not completely meet this goal. For example, consider the Stack class shown at the end of
Chapter 6. While it is true that the methods push( ) and pop( ) do provide a controlled
interface to the stack, this interface is not enforced. That is, it is possible for another part of
the program to bypass these methods and access the stack directly. Of course, in the wrong
hands, this could lead to trouble. In this section, you will be introduced to the mechanism
by which you can precisely control access to the various members of a class.
How a member can be accessed is determined by the access specifier that modifies its
declaration. Java supplies a rich set of access specifiers. Some aspects of access control are
related mostly to inheritance or packages. (A package is, essentially, a grouping of classes.)
These parts of Java’s access control mechanism will be discussed later. Here, let’s begin by
examining access control as it applies to a single class. Once you understand the fundamentals
of access control, the rest will be easy.
Java’s access specifiers are public, private, and protected. Java also defines a default
access level. protected applies only when inheritance is involved. The other access specifiers
are described next.
Let’s begin by defining public and private. When a member of a class is modified by
the public specifier, then that member can be accessed by any other code. When a member
of a class is specified as private, then that member can only be accessed by other members of
its class. Now you can understand why main( ) has always been preceded by the public
specifier. It is called by code that is outside the program—that is, by the Java run-time
system. When no access specifier is used, then by default the member of a class is public
within its own package, but cannot be accessed outside of its package. (Packages are
discussed in the following chapter.)
In the classes developed so far, all members of a class have used the default access mode,
which is essentially public. However, this is not what you will typically want to be the case.
Usually, you will want to restrict access to the data members of a class—allowing access
only through methods. Also, there will be times when you will want to define methods
that are private to a class.
An access specifier precedes the rest of a member’s type specification. That is, it must
begin a member’s declaration statement. Here is an example:
public int i;
private double j;
private int myMethod(int a, char b) { // ...
To understand the effects of public and private access, consider the following program:Chapter 7:
A Closer Look at Methods and Classes
/* This program demonstrates the difference between
public and private.
*/
class Test 
class AccessTest 
As you can see, inside the Test class, a uses default access, which for this example is the
same as specifying public. b is explicitly specified as public. Member c is given private
access. This means that it cannot be accessed by code outside of its class. So, inside the
AccessTest class, c cannot be used directly. It must be accessed through its public methods:
setc( ) and getc( ). If you were to remove the comment symbol from the beginning of the
following line,
//
ob.c = 100; // Error!
then you would not be able to compile this program because of the access violation.
To see how access control can be applied to a more practical example, consider the
following improved version of the Stack class shown at the end of Chapter 6.
// This class defines an integer stack that can hold 10 values.
class Stack 
As you can see, now both stck, which holds the stack, and tos, which is the index of the
top of the stack, are specified as private. This means that they cannot be accessed or altered
except through push( ) and pop( ). Making tos private, for example, prevents other parts of
your program from inadvertently setting it to a value that is beyond the end of the stck array.
The following program demonstrates the improved Stack class. Try removing the
commented-out lines to prove to yourself that the stck and tos members are, indeed,
inaccessible.
class TestStack 
Although methods will usually provide access to the data defined by a class, this does
not always have to be the case. It is perfectly proper to allow an instance variable to be public
when there is good reason to do so. For example, most of the simple classes in this book
were created with little concern about controlling access to instance variables for the sake of
simplicity. However, in most real-world classes, you will need to allow operations on data
only through methods. The next chapter will return to the topic of access control. As you
will see, it is particularly important when inheritance is involved.
Understanding static
There will be times when you will want to define a class member that will be used
independently of any object of that class. Normally, a class member must be accessed only
in conjunction with an object of its class. However, it is possible to create a member that can
be used by itself, without reference to a specific instance. To create such a member, precede
its declaration with the keyword static. When a member is declared static, it can be accessed
before any objects of its class are created, and without reference to any object. You can declare
both methods and variables to be static. The most common example of a static member is
main( ). main( ) is declared as static because it must be called before any objects exist.
Instance variables declared as static are, essentially, global variables. When objects of
its class are declared, no copy of a static variable is made. Instead, all instances of the class
share the same static variable.
Methods declared as static have several restrictions:
• They can only call other static methods.
• They must only access static data.
• They cannot refer to this or super in any way. (The keyword super relates to
inheritance and is described in the next chapter.)
If you need to do computation in order to initialize your static variables, you can declare a
static block that gets executed exactly once, when the class is first loaded. The following
example shows a class that has a static method, some static variables, and a static initialization
block:
// Demonstrate static variables, methods, and blocks.
class UseStatic 
As soon as the UseStatic class is loaded, all of the static statements are run. First, a is set to 3,
then the static block executes, which prints a message and then initializes b to a * 4 or 12. Then
main( ) is called, which calls meth( ), passing 42 to x. The three println( ) statements refer to the
two static variables a and b, as well as to the local variable x.
Here is the output of the program:
Static block initialized.
x = 42
a = 3
b = 12
Outside of the class in which they are defined, static methods and variables can be used
independently of any object. To do so, you need only specify the name of their class followed
by the dot operator. For example, if you wish to call a static method from outside its class, you
can do so using the following general form:
classname.method( )
Here, classname is the name of the class in which the static method is declared. As you can
see, this format is similar to that used to call non-static methods through object-reference
variables. A static variable can be accessed in the same way—by use of the dot operator on
the name of the class. This is how Java implements a controlled version of global methods
and global variables.
Here is an example. Inside main( ), the static method callme( ) and the static variable b
are accessed through their class name StaticDemo.
class StaticDemo 
class StaticByName 
Here is the output of this program:
a = 42
b = 99
Introducing final
A variable can be declared as final. Doing so prevents its contents from being modified.
This means that you must initialize a final variable when it is declared. For example:
final
final
final
final
final
int
int
int
int
int
FILE_NEW = 1;
FILE_OPEN = 2;
FILE_SAVE = 3;
FILE_SAVEAS = 4;
FILE_QUIT = 5;
Subsequent parts of your program can now use FILE_OPEN, etc., as if they were constants,
without fear that a value has been changed.
It is a common coding convention to choose all uppercase identifiers for final variables.
Variables declared as final do not occupy memory on a per-instance basis. Thus, a final
variable is essentially a constant.
The keyword final can also be applied to methods, but its meaning is substantially
different than when it is applied to variables. This second usage of final is described in the
next chapter, when inheritance is described.
Arrays Revisited
Arrays were introduced earlier in this book, before classes had been discussed. Now that you
know about classes, an important point can be made about arrays: they are implemented as
objects. Because of this, there is a special array attribute that you will want to take advantage
of. Specifically, the size of an array—that is, the number of elements that an array can hold—is
found in its length instance variable. All arrays have this variable, and it will always hold the
size of the array. Here is a program that demonstrates this property:
// This program demonstrates the length array member.
class Length 
This program displays the following output:
length of a1 is 10
length of a2 is 8
length of a3 is 4
As you can see, the size of each array is displayed. Keep in mind that the value of length
has nothing to do with the number of elements that are actually in use. It only reflects the
number of elements that the array is designed to hold.
You can put the length member to good use in many situations. For example, here is an
improved version of the Stack class. As you might recall, the earlier versions of this class
always created a ten-element stack. The following version lets you create stacks of any size.
The value of stck.length is used to prevent the stack from overflowing.
// Improved Stack class that uses the length array member.
class Stack 
class TestStack2 
Notice that the program creates two stacks: one five elements deep and the other eight
elements deep. As you can see, the fact that arrays maintain their own length information
makes it easy to create stacks of any size.
Introducing Nested and Inner Classes
It is possible to define a class within another class; such classes are known as nested classes.
The scope of a nested class is bounded by the scope of its enclosing class. Thus, if class B is
defined within class A, then B does not exist independently of A. A nested class has access
to the members, including private members, of the class in which it is nested. However, the
enclosing class does not have access to the members of the nested class. A nested class that
is declared directly within its enclosing class scope is a member of its enclosing class. It is
also possible to declare a nested class that is local to a block.
There are two types of nested classes: static and non-static. A static nested class is one
that has the static modifier applied. Because it is static, it must access the members of its
enclosing class through an object. That is, it cannot refer to members of its enclosing class
directly. Because of this restriction, static nested classes are seldom used.
The most important type of nested class is the inner class. An inner class is a non-static
nested class. It has access to all of the variables and methods of its outer class and may refer
to them directly in the same way that other non-static members of the outer class do.
The following program illustrates how to define and use an inner class. The class named
Outer has one instance variable named outer_x, one instance method named test( ), and
defines one inner class called Inner.
// Demonstrate an inner class.
class Outer 
class InnerClassDemo 
Output from this application is shown here:
display: outer_x = 100
In the program, an inner class named Inner is defined within the scope of class Outer.
Therefore, any code in class Inner can directly access the variable outer_x. An instance
method named display( ) is defined inside Inner. This method displays outer_x on the
standard output stream. The main( ) method of InnerClassDemo creates an instance of
class Outer and invokes its test( ) method. That method creates an instance of class Inner
and the display( ) method is called.
It is important to realize that an instance of Inner can be created only within the scope
of class Outer. The Java compiler generates an error message if any code outside of class
Outer attempts to instantiate class Inner. (In general, an inner class instance must be
created by an enclosing scope.) You can, however, create an instance of Inner outside of
Outer by qualifying its name with Outer, as in Outer.Inner.
As explained, an inner class has access to all of the members of its enclosing class, but
the reverse is not true. Members of the inner class are known only within the scope of the
inner class and may not be used by the outer class. For example,
// This program will not compile.
class Outer 
class InnerClassDemo 
Here, y is declared as an instance variable of Inner. Thus, it is not known outside of that
class and it cannot be used by showy( ).
Although we have been focusing on inner classes declared as members within an outer
class scope, it is possible to define inner classes within any block scope. For example, you
can define a nested class within the block defined by a method or even within the body of a
for loop, as this next program shows.
// Define an inner class within a for loop.
class Outer 
class InnerClassDemo 
The output from this version of the program is shown here.
display:
display:
display:
display:
display:
display:
display:
display:
outer_x
outer_x
outer_x
outer_x
outer_x
outer_x
outer_x
outer_x
=
=
=
=
=
=
=
=
100
100
100
100
100
100
100
100
147148
Part I:
The Java Language
display: outer_x = 100
display: outer_x = 100
While nested classes are not applicable to all stiuations, they are particularly helpful when
handling events. We will return to the topic of nested classes in Chapter 22. There you will
see how inner classes can be used to simplify the code needed to handle certain types of
events. You will also learn about anonymous inner classes, which are inner classes that don’t
have a name.
One final point: Nested classes were not allowed by the original 1.0 specification for Java.
They were added by Java 1.1.
Exploring the String Class
Although the String class will be examined in depth in Part II of this book, a short exploration
of it is warranted now, because we will be using strings in some of the example programs
shown toward the end of Part I. String is probably the most commonly used class in Java’s
class library. The obvious reason for this is that strings are a very important part of
programming.
The first thing to understand about strings is that every string you create is actually an
object of type String. Even string constants are actually String objects. For example, in the
statement
System.out.println("This is a String, too");
the string “This is a String, too” is a String constant.
The second thing to understand about strings is that objects of type String are immutable;
once a String object is created, its contents cannot be altered. While this may seem like a
serious restriction, it is not, for two reasons:
• If you need to change a string, you can always create a new one that contains
the modifications.
• Java defines a peer class of String, called StringBuffer, which allows strings
to be altered, so all of the normal string manipulations are still available in Java.
(StringBuffer is described in Part II of this book.)
Strings can be constructed in a variety of ways. The easiest is to use a statement like this:
String myString = "this is a test";
Once you have created a String object, you can use it anywhere that a string is allowed.
For example, this statement displays myString:
System.out.println(myString);
Java defines one operator for String objects: +. It is used to concatenate two strings.
For example, this statement
String myString = "I" + " like " + "Java.";
results in myString containing “I like Java.”Chapter 7:
A Closer Look at Methods and Classes
The following program demonstrates the preceding concepts:
// Demonstrating Strings.
class StringDemo 
The output produced by this program is shown here:
First String
Second String
First String and Second String
The String class contains several methods that you can use. Here are a few. You can test
two strings for equality by using equals( ). You can obtain the length of a string by calling
the length( ) method. You can obtain the character at a specified index within a string by
calling charAt( ). The general forms of these three methods are shown here:
boolean equals(String object)
int length( )
char charAt(int index)
Here is a program that demonstrates these methods:
// Demonstrating some String methods.
class StringDemo2 
This program generates the following output:
Length of strOb1: 12
Char at index 3 in strOb1: s
strOb1 != strOb2
strOb1 == strOb3
Of course, you can have arrays of strings, just like you can have arrays of any other type
of object. For example:
// Demonstrate String arrays.
class StringDemo3 
Here is the output from this program:
str[0]: one
str[1]: two
str[2]: three
As you will see in the following section, string arrays play an important part in many
Java programs.
Using Command-Line Arguments
Sometimes you will want to pass information into a program when you run it. This is
accomplished by passing command-line arguments to main( ). A command-line argument is
the information that directly follows the program’s name on the command line when it is
executed. To access the command-line arguments inside a Java program is quite easy—
they are stored as strings in a String array passed to the args parameter of main( ). The first
command-line argument is stored at args[0], the second at args[1], and so on. For example,
the following program displays all of the command-line arguments that it is called with:
// Display all command-line arguments.
class CommandLine Chapter 7:
A Closer Look at Methods and Classes
Try executing this program, as shown here:
java CommandLine this is a test 100 -1
When you do, you will see the following output:
args[0]:
args[1]:
args[2]:
args[3]:
args[4]:
args[5]:
this
is
a
test
100
-1
R EMEMBER All command-line arguments are passed as strings. You must convert numeric values
to their internal forms manually, as explained in Chapter 16.
Varargs: Variable-Length Arguments
Beginning with JDK 5, Java has included a feature that simplifies the creation of methods
that need to take a variable number of arguments. This feature is called varargs and it is
short for variable-length arguments. A method that takes a variable number of arguments
is called a variable-arity method, or simply a varargs method.
Situations that require that a variable number of arguments be passed to a method are
not unusual. For example, a method that opens an Internet connection might take a user
name, password, filename, protocol, and so on, but supply defaults if some of this information
is not provided. In this situation, it would be convenient to pass only the arguments to
which the defaults did not apply. Another example is the printf( ) method that is part of
Java’s I/O library. As you will see in Chapter 19, it takes a variable number of arguments,
which it formats and then outputs.
Prior to JDK 5, variable-length arguments could be handled two ways, neither of which
was particularly pleasing. First, if the maximum number of arguments was small and
known, then you could create overloaded versions of the method, one for each way the
method could be called. Although this works and is suitable for some cases, it applies to
only a narrow class of situations.
In cases where the maximum number of potential arguments was larger, or unknowable,
a second approach was used in which the arguments were put into an array, and then the
array was passed to the method. This approach is illustrated by the following program:
// Use an array to pass a variable number of
// arguments to a method. This is the old-style
// approach to variable-length arguments.
class PassArray 
The output from the program is shown here:
Number of args: 1 Contents: 10
Number of args: 3 Contents: 1 2 3
Number of args: 0 Contents:
In the program, the method vaTest( ) is passed its arguments through the array v. This
old-style approach to variable-length arguments does enable vaTest( ) to take an arbitrary
number of arguments. However, it requires that these arguments be manually packaged
into an array prior to calling vaTest( ). Not only is it tedious to construct an array each time
vaTest( ) is called, it is potentially error-prone. The varargs feature offers a simpler, better
option.
A variable-length argument is specified by three periods (...). For example, here is how
vaTest( ) is written using a vararg:
static void vaTest(int ... v) {
This syntax tells the compiler that vaTest( ) can be called with zero or more arguments. As a
result, v is implicitly declared as an array of type int[ ]. Thus, inside vaTest( ), v is accessed
using the normal array syntax. Here is the preceding program rewritten using a vararg:
// Demonstrate variable-length arguments.
class VarArgs 
The output from the program is the same as the original version.
There are two important things to notice about this program. First, as explained, inside
vaTest( ), v is operated on as an array. This is because v is an array. The ... syntax simply tells
the compiler that a variable number of arguments will be used, and that these arguments will
be stored in the array referred to by v. Second, in main( ), vaTest( ) is called with different
numbers of arguments, including no arguments at all. The arguments are automatically put
in an array and passed to v. In the case of no arguments, the length of the array is zero.
A method can have “normal” parameters along with a variable-length parameter. However,
the variable-length parameter must be the last parameter declared by the method. For example,
this method declaration is perfectly acceptable:
int doIt(int a, int b, double c, int ... vals) {
In this case, the first three arguments used in a call to doIt( ) are matched to the first three
parameters. Then, any remaining arguments are assumed to belong to vals.
Remember, the varargs parameter must be last. For example, the following declaration
is incorrect:
int doIt(int a, int b, double c, int ... vals, boolean stopFlag) { // Error!
Here, there is an attempt to declare a regular parameter after the varargs parameter, which
is illegal.
There is one more restriction to be aware of: there must be only one varargs parameter.
For example, this declaration is also invalid:
int doIt(int a, int b, double c, int ... vals, double ... morevals) { // Error!
The attempt to declare the second varargs parameter is illegal.
Here is a reworked version of the vaTest( ) method that takes a regular argument and
a variable-length argument:
// Use varargs with standard arguments.
class VarArgs2 
The output from this program is shown here:
One vararg: 1 Contents: 10
Three varargs: 3 Contents: 1 2 3
No varargs: 0 Contents:
Overloading Vararg Methods
You can overload a method that takes a variable-length argument. For example, the following
program overloads vaTest( ) three times:
// Varargs and overloading.
class VarArgs3 
The output produced by this program is shown here:
vaTest(int ...): Number of args: 3 Contents: 1 2 3
vaTest(String, int ...): Testing: 2 Contents: 10 20
vaTest(boolean ...) Number of args: 3 Contents: true false false
This program illustrates both ways that a varargs method can be overloaded. First, the
types of its vararg parameter can differ. This is the case for vaTest(int ...) and vaTest(boolean
...). Remember, the ... causes the parameter to be treated as an array of the specified type.
Therefore, just as you can overload methods by using different types of array parameters,
you can overload vararg methods by using different types of varargs. In this case, Java uses
the type difference to determine which overloaded method to call.
The second way to overload a varargs method is to add a normal parameter. This is what
was done with vaTest(String, int ...). In this case, Java uses both the number of arguments and
the type of the arguments to determine which method to call.
N OTE A varargs method can also be overloaded by a non-varargs method. For example, vaTest(int x)
is a valid overload of vaTest( ) in the foregoing program. This version is invoked only when one
int argument is present. When two or more int arguments are passed, the varargs version
vaTest(int...v) is used.
Varargs and Ambiguity
Somewhat unexpected errors can result when overloading a method that takes a variable-length
argument. These errors involve ambiguity because it is possible to create an ambiguous call to
an overloaded varargs method. For example, consider the following program:
// Varargs, overloading, and ambiguity.
//
// This program contains an error and will
// not compile!
class VarArgs4 
In this program, the overloading of vaTest( ) is perfectly correct. However, this program
will not compile because of the following call:
vaTest(); // Error: Ambiguous!
Because the vararg parameter can be empty, this call could be translated into a call to
vaTest(int ...) or vaTest(boolean ...). Both are equally valid. Thus, the call is inherently
ambiguous.
Here is another example of ambiguity. The following overloaded versions of vaTest( )
are inherently ambiguous even though one takes a normal parameter:
static void vaTest(int ... v) { // ...
static void vaTest(int n, int ... v) { // ...
Although the parameter lists of vaTest( ) differ, there is no way for the compiler to resolve
the following call:
vaTest(1)
Does this translate into a call to vaTest(int ...), with one varargs argument, or into a call to
vaTest(int, int ...) with no varargs arguments? There is no way for the compiler to answer
this question. Thus, the situation is ambiguous.
Because of ambiguity errors like those just shown, sometimes you will need to forego
overloading and simply use two different method names. Also, in some cases, ambiguity
errors expose a conceptual flaw in your code, which you can remedy by more carefully
crafting a solution.8
Inheritance
I
nheritance is one of the cornerstones of object-oriented programming because it allows
the creation of hierarchical classifications. Using inheritance, you can create a general
class that defines traits common to a set of related items. This class can then be inherited
by other, more specific classes, each adding those things that are unique to it. In the terminology
of Java, a class that is inherited is called a superclass. The class that does the inheriting is called
a subclass. Therefore, a subclass is a specialized version of a superclass. It inherits all of the
instance variables and methods defined by the superclass and adds its own, unique elements.
Inheritance Basics
To inherit a class, you simply incorporate the definition of one class into another by using
the extends keyword. To see how, let’s begin with a short example. The following program
creates a superclass called A and a subclass called B. Notice how the keyword extends is
used to create a subclass of A.
// A simple example of inheritance.
// Create a superclass.
class A 
// Create a subclass by extending class A.
class B extends A 
157158
Part I:
The Java Language
class SimpleInheritance 
The output from this program is shown here:
Contents of superOb:
i and j: 10 20
Contents of subOb:
i and j: 7 8
k: 9
Sum of i, j and k in subOb:
i+j+k: 24
As you can see, the subclass B includes all of the members of its superclass, A. This is
why subOb can access i and j and call showij( ). Also, inside sum( ), i and j can be referred
to directly, as if they were part of B.
Even though A is a superclass for B, it is also a completely independent, stand-alone
class. Being a superclass for a subclass does not mean that the superclass cannot be used
by itself. Further, a subclass can be a superclass for another subclass.
The general form of a class declaration that inherits a superclass is shown here:
class subclass-name extends superclass-name Chapter 8:
Inheritance
You can only specify one superclass for any subclass that you create. Java does not
support the inheritance of multiple superclasses into a single subclass. You can, as stated,
create a hierarchy of inheritance in which a subclass becomes a superclass of another subclass.
However, no class can be a superclass of itself.
Member Access and Inheritance
Although a subclass includes all of the members of its superclass, it cannot access those
members of the superclass that have been declared as private. For example, consider the
following simple class hierarchy:
/* In a class hierarchy, private members remain
private to their class.
This program contains an error and will not
compile.
*/
// Create a superclass.
class A 
// A's j is not accessible here.
class B extends A 
class Access 
This program will not compile because the reference to j inside the sum( ) method of B
causes an access violation. Since j is declared as private, it is only accessible by other members
of its own class. Subclasses have no access to it.
159160
Part I:
The Java Language
R EMEMBER A class member that has been declared as private will remain private to its class. It is
not accessible by any code outside its class, including subclasses.
A More Practical Example
Let’s look at a more practical example that will help illustrate the power of inheritance.
Here, the final version of the Box class developed in the preceding chapter will be extended
to include a fourth component called weight. Thus, the new class will contain a box’s width,
height, depth, and weight.
// This program uses inheritance to extend Box.
class Box 
// Here, Box is extended to include weight.
class BoxWeight extends Box 
class DemoBoxWeight 
The output from this program is shown here:
Volume of mybox1 is 3000.0
Weight of mybox1 is 34.3
Volume of mybox2 is 24.0
Weight of mybox2 is 0.076
BoxWeight inherits all of the characteristics of Box and adds to them the weight component.
It is not necessary for BoxWeight to re-create all of the features found in Box. It can simply
extend Box to meet its own purposes.
A major advantage of inheritance is that once you have created a superclass that defines
the attributes common to a set of objects, it can be used to create any number of more specific
subclasses. Each subclass can precisely tailor its own classification. For example, the following
class inherits Box and adds a color attribute:
// Here, Box is extended to include color.
class ColorBox extends Box 
161162
Part I:
The Java Language
Remember, once you have created a superclass that defines the general aspects of an
object, that superclass can be inherited to form specialized classes. Each subclass simply
adds its own unique attributes. This is the essence of inheritance.
A Superclass Variable Can Reference a Subclass Object
A reference variable of a superclass can be assigned a reference to any subclass derived from
that superclass. You will find this aspect of inheritance quite useful in a variety of situations.
For example, consider the following:
class RefDemo 
Here, weightbox is a reference to BoxWeight objects, and plainbox is a reference to Box objects.
Since BoxWeight is a subclass of Box, it is permissible to assign plainbox a reference to the
weightbox object.
It is important to understand that it is the type of the reference variable—not the type of
the object that it refers to—that determines what members can be accessed. That is, when a
reference to a subclass object is assigned to a superclass reference variable, you will have access
only to those parts of the object defined by the superclass. This is why plainbox can’t access
weight even when it refers to a BoxWeight object. If you think about it, this makes sense,
because the superclass has no knowledge of what a subclass adds to it. This is why the last
line of code in the preceding fragment is commented out. It is not possible for a Box reference
to access the weight field, because Box does not define one.
Although the preceding may seem a bit esoteric, it has some important practical
applications—two of which are discussed later in this chapter.Chapter 8:
Inheritance
Using super
In the preceding examples, classes derived from Box were not implemented as efficiently or
as robustly as they could have been. For example, the constructor for BoxWeight explicitly
initializes the width, height, and depth fields of Box( ). Not only does this duplicate code
found in its superclass, which is inefficient, but it implies that a subclass must be granted access
to these members. However, there will be times when you will want to create a superclass that
keeps the details of its implementation to itself (that is, that keeps its data members private).
In this case, there would be no way for a subclass to directly access or initialize these variables
on its own. Since encapsulation is a primary attribute of OOP, it is not surprising that Java
provides a solution to this problem. Whenever a subclass needs to refer to its immediate
superclass, it can do so by use of the keyword super.
super has two general forms. The first calls the superclass’ constructor. The second is
used to access a member of the superclass that has been hidden by a member of a subclass.
Each use is examined here.
Using super to Call Superclass Constructors
A subclass can call a constructor defined by its superclass by use of the following form of super:
super(arg-list);
Here, arg-list specifies any arguments needed by the constructor in the superclass. super( )
must always be the first statement executed inside a subclass’ constructor.
To see how super( ) is used, consider this improved version of the BoxWeight( ) class:
// BoxWeight now uses super to initialize its Box attributes.
class BoxWeight extends Box 
Here, BoxWeight( ) calls super( ) with the arguments w, h, and d. This causes the Box( )
constructor to be called, which initializes width, height, and depth using these values.
BoxWeight no longer initializes these values itself. It only needs to initialize the value unique
to it: weight. This leaves Box free to make these values private if desired.
In the preceding example, super( ) was called with three arguments. Since constructors
can be overloaded, super( ) can be called using any form defined by the superclass. The
constructor executed will be the one that matches the arguments. For example, here is a
complete implementation of BoxWeight that provides constructors for the various ways
163164
Part I:
The Java Language
that a box can be constructed. In each case, super( ) is called using the appropriate arguments.
Notice that width, height, and depth have been made private within Box.
// A complete implementation of BoxWeight.
class Box 
// BoxWeight now fully implements all constructors.
class BoxWeight extends Box 
class DemoSuper 
165166
Part I:
The Java Language
This program generates the following output:
Volume of mybox1 is 3000.0
Weight of mybox1 is 34.3
Volume of mybox2 is 24.0
Weight of mybox2 is 0.076
Volume of mybox3 is -1.0
Weight of mybox3 is -1.0
Volume of myclone is 3000.0
Weight of myclone is 34.3
Volume of mycube is 27.0
Weight of mycube is 2.0
Pay special attention to this constructor in BoxWeight( ):
// construct clone of an object
BoxWeight(BoxWeight ob) 
Notice that super( ) is passed an object of type BoxWeight—not of type Box. This still
invokes the constructor Box(Box ob). As mentioned earlier, a superclass variable can be
used to reference any object derived from that class. Thus, we are able to pass a BoxWeight
object to the Box constructor. Of course, Box only has knowledge of its own members.
Let’s review the key concepts behind super( ). When a subclass calls super( ), it is calling
the constructor of its immediate superclass. Thus, super( ) always refers to the superclass
immediately above the calling class. This is true even in a multileveled hierarchy. Also, super( )
must always be the first statement executed inside a subclass constructor.
A Second Use for super
The second form of super acts somewhat like this, except that it always refers to the superclass
of the subclass in which it is used. This usage has the following general form:
super.member
Here, member can be either a method or an instance variable.
This second form of super is most applicable to situations in which member names of
a subclass hide members by the same name in the superclass. Consider this simple class
hierarchy:
// Using super to overcome name hiding.
class A Chapter 8:
Inheritance
// Create a subclass by extending class A.
class B extends A 
class UseSuper 
This program displays the following:
i in superclass: 1
i in subclass: 2
Although the instance variable i in B hides the i in A, super allows access to the i defined
in the superclass. As you will see, super can also be used to call methods that are hidden by a
subclass.
Creating a Multilevel Hierarchy
Up to this point, we have been using simple class hierarchies that consist of only a superclass
and a subclass. However, you can build hierarchies that contain as many layers of inheritance
as you like. As mentioned, it is perfectly acceptable to use a subclass as a superclass of another.
For example, given three classes called A, B, and C, C can be a subclass of B, which is a
subclass of A. When this type of situation occurs, each subclass inherits all of the traits
found in all of its superclasses. In this case, C inherits all aspects of B and A. To see how
a multilevel hierarchy can be useful, consider the following program. In it, the subclass
BoxWeight is used as a superclass to create the subclass called Shipment. Shipment inherits
all of the traits of BoxWeight and Box, and adds a field called cost, which holds the cost of
shipping such a parcel.
// Extend BoxWeight to include shipping costs.
// Start with Box.
class Box 
// Add weight.
class BoxWeight extends Box 
// Add shipping costs.
class Shipment extends BoxWeight 
class DemoShipment 
The output of this program is shown here:
Volume of shipment1 is 3000.0
Weight of shipment1 is 10.0
Shipping cost: $3.41
Volume of shipment2 is 24.0
Weight of shipment2 is 0.76
Shipping cost: $1.28
Because of inheritance, Shipment can make use of the previously defined classes of Box
and BoxWeight, adding only the extra information it needs for its own, specific application.
This is part of the value of inheritance; it allows the reuse of code.
This example illustrates one other important point: super( ) always refers to the constructor
in the closest superclass. The super( ) in Shipment calls the constructor in BoxWeight. The
super( ) in BoxWeight calls the constructor in Box. In a class hierarchy, if a superclass
constructor requires parameters, then all subclasses must pass those parameters “up the
line.” This is true whether or not a subclass needs parameters of its own.
N OTE In the preceding program, the entire class hierarchy, including Box, BoxWeight, and
Shipment, is shown all in one file. This is for your convenience only. In Java, all three classes
could have been placed into their own files and compiled separately. In fact, using separate
files is the norm, not the exception, in creating class hierarchies.
When Constructors Are Called
When a class hierarchy is created, in what order are the constructors for the classes that make up
the hierarchy called? For example, given a subclass called B and a superclass called A, is A’s
constructor called before B’s, or vice versa? The answer is that in a class hierarchy, constructors
are called in order of derivation, from superclass to subclass. Further, since super( ) must be the
first statement executed in a subclass’ constructor, this order is the same whether or not super( )
is used. If super( ) is not used, then the default or parameterless constructor of each superclass
will be executed. The following program illustrates when constructors are executed:
// Demonstrate when constructors are called.
// Create a super class.
class A Chapter 8:
Inheritance
// Create a subclass by extending class A.
class B extends A 
// Create another subclass by extending B.
class C extends B 
class CallingCons 
The output from this program is shown here:
Inside A’s constructor
Inside B’s constructor
Inside C’s constructor
As you can see, the constructors are called in order of derivation.
If you think about it, it makes sense that constructors are executed in order of derivation.
Because a superclass has no knowledge of any subclass, any initialization it needs to perform
is separate from and possibly prerequisite to any initialization performed by the subclass.
Therefore, it must be executed first.
Method Overriding
In a class hierarchy, when a method in a subclass has the same name and type signature as
a method in its superclass, then the method in the subclass is said to override the method in
the superclass. When an overridden method is called from within a subclass, it will always
refer to the version of that method defined by the subclass. The version of the method defined
by the superclass will be hidden. Consider the following:
// Method overriding.
class A 
171172
Part I:
The Java Language
class B extends A 
class Override 
The output produced by this program is shown here:
k: 3
When show( ) is invoked on an object of type B, the version of show( ) defined within B
is used. That is, the version of show( ) inside B overrides the version declared in A.
If you wish to access the superclass version of an overridden method, you can do so by
using super. For example, in this version of B, the superclass version of show( ) is invoked
within the subclass’ version. This allows all instance variables to be displayed.
class B extends A 
If you substitute this version of A into the previous program, you will see the following
output:
i and j: 1 2
k: 3
Here, super.show( ) calls the superclass version of show( ).Chapter 8:
Inheritance
Method overriding occurs only when the names and the type signatures of the two
methods are identical. If they are not, then the two methods are simply overloaded. For
example, consider this modified version of the preceding example:
// Methods with differing type signatures are overloaded – not
// overridden.
class A 
// Create a subclass by extending class A.
class B extends A 
class Override 
The output produced by this program is shown here:
This is k: 3
i and j: 1 2
The version of show( ) in B takes a string parameter. This makes its type signature
different from the one in A, which takes no parameters. Therefore, no overriding (or name
hiding) takes place. Instead, the version of show( ) in B simply overloads the version of
show( ) in A.
173174
Part I:
The Java Language
Dynamic Method Dispatch
While the examples in the preceding section demonstrate the mechanics of method overriding,
they do not show its power. Indeed, if there were nothing more to method overriding than
a name space convention, then it would be, at best, an interesting curiosity, but of little real
value. However, this is not the case. Method overriding forms the basis for one of Java’s most
powerful concepts: dynamic method dispatch. Dynamic method dispatch is the mechanism
by which a call to an overridden method is resolved at run time, rather than compile time.
Dynamic method dispatch is important because this is how Java implements run-time
polymorphism.
Let’s begin by restating an important principle: a superclass reference variable can refer
to a subclass object. Java uses this fact to resolve calls to overridden methods at run time. Here
is how. When an overridden method is called through a superclass reference, Java determines
which version of that method to execute based upon the type of the object being referred
to at the time the call occurs. Thus, this determination is made at run time. When different
types of objects are referred to, different versions of an overridden method will be called.
In other words, it is the type of the object being referred to (not the type of the reference variable)
that determines which version of an overridden method will be executed. Therefore, if a
superclass contains a method that is overridden by a subclass, then when different types
of objects are referred to through a superclass reference variable, different versions of the
method are executed.
Here is an example that illustrates dynamic method dispatch:
// Dynamic Method Dispatch
class A 
class B extends A 
class C extends A 
class Dispatch 
The output from the program is shown here:
Inside A’s callme method
Inside B’s callme method
Inside C’s callme method
This program creates one superclass called A and two subclasses of it, called B and C.
Subclasses B and C override callme( ) declared in A. Inside the main( ) method, objects of
type A, B, and C are declared. Also, a reference of type A, called r, is declared. The program
then in turn assigns a reference to each type of object to r and uses that reference to invoke
callme( ). As the output shows, the version of callme( ) executed is determined by the type
of object being referred to at the time of the call. Had it been determined by the type of the
reference variable, r, you would see three calls to A’s callme( ) method.
N OTE Readers familiar with C++ or C# will recognize that overridden methods in Java are similar
to virtual functions in those languages.
Why Overridden Methods?
As stated earlier, overridden methods allow Java to support run-time polymorphism.
Polymorphism is essential to object-oriented programming for one reason: it allows a
general class to specify methods that will be common to all of its derivatives, while allowing
subclasses to define the specific implementation of some or all of those methods. Overridden
methods are another way that Java implements the “one interface, multiple methods” aspect
of polymorphism.
Part of the key to successfully applying polymorphism is understanding that the
superclasses and subclasses form a hierarchy which moves from lesser to greater specialization.
Used correctly, the superclass provides all elements that a subclass can use directly. It also
defines those methods that the derived class must implement on its own. This allows the
subclass the flexibility to define its own methods, yet still enforces a consistent interface.
Thus, by combining inheritance with overridden methods, a superclass can define the general
form of the methods that will be used by all of its subclasses.
Dynamic, run-time polymorphism is one of the most powerful mechanisms that object-
oriented design brings to bear on code reuse and robustness. The ability of existing code
libraries to call methods on instances of new classes without recompiling while maintaining
a clean abstract interface is a profoundly powerful tool.
175176
Part I:
The Java Language
Applying Method Overriding
Let’s look at a more practical example that uses method overriding. The following program
creates a superclass called Figure that stores the dimensions of a two-dimensional object. It
also defines a method called area( ) that computes the area of an object. The program derives
two subclasses from Figure. The first is Rectangle and the second is Triangle. Each of
these subclasses overrides area( ) so that it returns the area of a rectangle and a triangle,
respectively.
// Using run-time polymorphism.
class Figure 
class Rectangle extends Figure 
class Triangle extends Figure 
class FindAreas 
The output from the program is shown here:
Inside Area for Rectangle.
Area is 45
Inside Area for Triangle.
Area is 40
Area for Figure is undefined.
Area is 0
Through the dual mechanisms of inheritance and run-time polymorphism, it is possible
to define one consistent interface that is used by several different, yet related, types of objects.
In this case, if an object is derived from Figure, then its area can be obtained by calling area( ).
The interface to this operation is the same no matter what type of figure is being used.
Using Abstract Classes
There are situations in which you will want to define a superclass that declares the structure
of a given abstraction without providing a complete implementation of every method. That
is, sometimes you will want to create a superclass that only defines a generalized form that
will be shared by all of its subclasses, leaving it to each subclass to fill in the details. Such a
class determines the nature of the methods that the subclasses must implement. One way
this situation can occur is when a superclass is unable to create a meaningful implementation
for a method. This is the case with the class Figure used in the preceding example. The
definition of area( ) is simply a placeholder. It will not compute and display the area of any
type of object.
As you will see as you create your own class libraries, it is not uncommon for a method
to have no meaningful definition in the context of its superclass. You can handle this situation
two ways. One way, as shown in the previous example, is to simply have it report a warning
message. While this approach can be useful in certain situations—such as debugging—it is
not usually appropriate. You may have methods that must be overridden by the subclass
in order for the subclass to have any meaning. Consider the class Triangle. It has no meaning
if area( ) is not defined. In this case, you want some way to ensure that a subclass does, indeed,
override all necessary methods. Java’s solution to this problem is the abstract method.
You can require that certain methods be overridden by subclasses by specifying the
abstract type modifier. These methods are sometimes referred to as subclasser responsibility
because they have no implementation specified in the superclass. Thus, a subclass must
177178
Part I:
The Java Language
override them—it cannot simply use the version defined in the superclass. To declare an
abstract method, use this general form:
abstract type name(parameter-list);
As you can see, no method body is present.
Any class that contains one or more abstract methods must also be declared abstract. To
declare a class abstract, you simply use the abstract keyword in front of the class keyword
at the beginning of the class declaration. There can be no objects of an abstract class. That is,
an abstract class cannot be directly instantiated with the new operator. Such objects would
be useless, because an abstract class is not fully defined. Also, you cannot declare abstract
constructors, or abstract static methods. Any subclass of an abstract class must either implement
all of the abstract methods in the superclass, or be itself declared abstract.
Here is a simple example of a class with an abstract method, followed by a class which
implements that method:
// A Simple demonstration of abstract.
abstract class A 
class B extends A 
class AbstractDemo 
Notice that no objects of class A are declared in the program. As mentioned, it is not
possible to instantiate an abstract class. One other point: class A implements a concrete
method called callmetoo( ). This is perfectly acceptable. Abstract classes can include as
much implementation as they see fit.
Although abstract classes cannot be used to instantiate objects, they can be used to create
object references, because Java’s approach to run-time polymorphism is implemented through
the use of superclass references. Thus, it must be possible to create a reference to an abstract
class so that it can be used to point to a subclass object. You will see this feature put to use in
the next example.Chapter 8:
Inheritance
Using an abstract class, you can improve the Figure class shown earlier. Since there is no
meaningful concept of area for an undefined two-dimensional figure, the following version
of the program declares area( ) as abstract inside Figure. This, of course, means that all classes
derived from Figure must override area( ).
// Using
abstract
double
double
abstract methods and classes.
class Figure 
class Rectangle extends Figure 
class Triangle extends Figure 
class AbstractAreas 
As the comment inside main( ) indicates, it is no longer possible to declare objects of
type Figure, since it is now abstract. And, all subclasses of Figure must override area( ). To
prove this to yourself, try creating a subclass that does not override area( ). You will receive
a compile-time error.
Although it is not possible to create an object of type Figure, you can create a reference
variable of type Figure. The variable figref is declared as a reference to Figure, which means
that it can be used to refer to an object of any class derived from Figure. As explained, it is
through superclass reference variables that overridden methods are resolved at run time.
Using final with Inheritance
The keyword final has three uses. First, it can be used to create the equivalent of a named
constant. This use was described in the preceding chapter. The other two uses of final apply
to inheritance. Both are examined here.
Using final to Prevent Overriding
While method overriding is one of Java’s most powerful features, there will be times when
you will want to prevent it from occurring. To disallow a method from being overridden,
specify final as a modifier at the start of its declaration. Methods declared as final cannot
be overridden. The following fragment illustrates final:
class A 
class B extends A 
Because meth( ) is declared as final, it cannot be overridden in B. If you attempt to do
so, a compile-time error will result.
Methods declared as final can sometimes provide a performance enhancement: The
compiler is free to inline calls to them because it “knows” they will not be overridden
by a subclass. When a small final method is called, often the Java compiler can copy the
bytecode for the subroutine directly inline with the compiled code of the calling method,
thus eliminating the costly overhead associated with a method call. Inlining is only an
option with final methods. Normally, Java resolves calls to methods dynamically, at run
time. This is called late binding. However, since final methods cannot be overridden, a call
to one can be resolved at compile time. This is called early binding.Chapter 8:
Inheritance
Using final to Prevent Inheritance
Sometimes you will want to prevent a class from being inherited. To do this, precede the
class declaration with final. Declaring a class as final implicitly declares all of its methods
as final, too. As you might expect, it is illegal to declare a class as both abstract and final
since an abstract class is incomplete by itself and relies upon its subclasses to provide
complete implementations.
Here is an example of a final class:
final class A 
// The following class is illegal.
class B extends A 
As the comments imply, it is illegal for B to inherit A since A is declared as final.
The Object Class
There is one special class, Object, defined by Java. All other classes are subclasses of Object.
That is, Object is a superclass of all other classes. This means that a reference variable of type
Object can refer to an object of any other class. Also, since arrays are implemented as classes,
a variable of type Object can also refer to any array.
Object defines the following methods, which means that they are available in every object.
Method Purpose
Object clone( ) Creates a new object that is the same as the object being cloned.
boolean equals(Object object) Determines whether one object is equal to another.
void finalize( ) Called before an unused object is recycled.
Class getClass( ) Obtains the class of an object at run time.
int hashCode( ) Returns the hash code associated with the invoking object.
void notify( ) Resumes execution of a thread waiting on the invoking object.
void notifyAll( ) Resumes execution of all threads waiting on the invoking object.
String toString( ) Returns a string that describes the object.
void wait( )
void wait(long milliseconds)
void wait(long milliseconds,
int nanoseconds) Waits on another thread of execution.
The methods getClass( ), notify( ), notifyAll( ), and wait( ) are declared as final. You
may override the others. These methods are described elsewhere in this book. However,
notice two methods now: equals( ) and toString( ). The equals( ) method compares the
contents of two objects. It returns true if the objects are equivalent, and false otherwise.
181182
Part I:
The Java Language
The precise definition of equality can vary, depending on the type of objects being
compared. The toString( ) method returns a string that contains a description of the object
on which it is called. Also, this method is automatically called when an object is output
using println( ). Many classes override this method. Doing so allows them to tailor a
description specifically for the types of objects that they create.9
Packages and Interfaces
T
his chapter examines two of Java’s most innovative features: packages and interfaces.
Packages are containers for classes that are used to keep the class name space
compartmentalized. For example, a package allows you to create a class named List,
which you can store in your own package without concern that it will collide with some
other class named List stored elsewhere. Packages are stored in a hierarchical manner and
are explicitly imported into new class definitions.
In previous chapters, you have seen how methods define the interface to the data in
a class. Through the use of the interface keyword, Java allows you to fully abstract the
interface from its implementation. Using interface, you can specify a set of methods that
can be implemented by one or more classes. The interface, itself, does not actually define
any implementation. Although they are similar to abstract classes, interfaces have an
additional capability: A class can implement more than one interface. By contrast, a class
can only inherit a single superclass (abstract or otherwise).
Packages
In the preceding chapters, the name of each example class was taken from the same
name space. This means that a unique name had to be used for each class to avoid name
collisions. After a while, without some way to manage the name space, you could run out
of convenient, descriptive names for individual classes. You also need some way to be
assured that the name you choose for a class will be reasonably unique and not collide
with class names chosen by other programmers. (Imagine a small group of programmers
fighting over who gets to use the name “Foobar” as a class name. Or, imagine the entire
Internet community arguing over who first named a class “Espresso.”) Thankfully, Java
provides a mechanism for partitioning the class name space into more manageable
chunks. This mechanism is the package. The package is both a naming and a visibility
control mechanism. You can define classes inside a package that are not accessible by
code outside that package. You can also define class members that are only exposed
to other members of the same package. This allows your classes to have intimate
knowledge of each other, but not expose that knowledge to the rest of the world.
183184
Part I:
The Java Language
Defining a Package
To create a package is quite easy: simply include a package command as the first statement
in a Java source file. Any classes declared within that file will belong to the specified package.
The package statement defines a name space in which classes are stored. If you omit the
package statement, the class names are put into the default package, which has no name.
(This is why you haven’t had to worry about packages before now.) While the default package
is fine for short, sample programs, it is inadequate for real applications. Most of the time,
you will define a package for your code.
This is the general form of the package statement:
package pkg;
Here, pkg is the name of the package. For example, the following statement creates a package
called MyPackage.
package MyPackage;
Java uses file system directories to store packages. For example, the .class files for any
classes you declare to be part of MyPackage must be stored in a directory called MyPackage.
Remember that case is significant, and the directory name must match the package name
exactly.
More than one file can include the same package statement. The package statement
simply specifies to which package the classes defined in a file belong. It does not exclude
other classes in other files from being part of that same package. Most real-world packages
are spread across many files.
You can create a hierarchy of packages. To do so, simply separate each package name
from the one above it by use of a period. The general form of a multileveled package statement
is shown here:
package pkg1[.pkg2[.pkg3]];
A package hierarchy must be reflected in the file system of your Java development
system. For example, a package declared as
package java.awt.image;
needs to be stored in java\awt\image in a Windows environment. Be sure to choose your
package names carefully. You cannot rename a package without renaming the directory in
which the classes are stored.
Finding Packages and CLASSPATH
As just explained, packages are mirrored by directories. This raises an important question:
How does the Java run-time system know where to look for packages that you create? The
answer has three parts. First, by default, the Java run-time system uses the current working
directory as its starting point. Thus, if your package is in a subdirectory of the current
directory, it will be found. Second, you can specify a directory path or paths by setting theChapter 9:
Packages and Interfaces
CLASSPATH environmental variable. Third, you can use the -classpath option with java
and javac to specify the path to your classes.
For example, consider the following package specification:
package MyPack
In order for a program to find MyPack, one of three things must be true. Either the program
can be executed from a directory immediately above MyPack, or the CLASSPATH must be
set to include the path to MyPack, or the -classpath option must specify the path to MyPack
when the program is run via java.
When the second two options are used, the class path must not include MyPack, itself.
It must simply specify the path to MyPack. For example, in a Windows environment, if the
path to MyPack is
C:\MyPrograms\Java\MyPack
Then the class path to MyPack is
C:\MyPrograms\Java
The easiest way to try the examples shown in this book is to simply create the package
directories below your current development directory, put the .class files into the
appropriate directories, and then execute the programs from the development directory.
This is the approach used in the following example.
A Short Package Example
Keeping the preceding discussion in mind, you can try this simple package:
// A simple package
package MyPack;
class Balance 
class AccountBalance 
Call this file AccountBalance.java and put it in a directory called MyPack.
Next, compile the file. Make sure that the resulting .class file is also in the MyPack
directory. Then, try executing the AccountBalance class, using the following command line:
java MyPack.AccountBalance
Remember, you will need to be in the directory above MyPack when you execute this command.
(Alternatively, you can use one of the other two options described in the preceding section to
specify the path MyPack.)
As explained, AccountBalance is now part of the package MyPack. This means that it
cannot be executed by itself. That is, you cannot use this command line:
java AccountBalance
AccountBalance must be qualified with its package name.
Access Protection
In the preceding chapters, you learned about various aspects of Java’s access control mechanism
and its access specifiers. For example, you already know that access to a private member of
a class is granted only to other members of that class. Packages add another dimension to
access control. As you will see, Java provides many levels of protection to allow fine-grained
control over the visibility of variables and methods within classes, subclasses, and packages.
Classes and packages are both means of encapsulating and containing the name space
and scope of variables and methods. Packages act as containers for classes and other
subordinate packages. Classes act as containers for data and code. The class is Java’s
smallest unit of abstraction. Because of the interplay between classes and packages, Java
addresses four categories of visibility for class members:
• Subclasses in the same package
• Non-subclasses in the same package
• Subclasses in different packages
• Classes that are neither in the same package nor subclasses
The three access specifiers, private, public, and protected, provide a variety of ways
to produce the many levels of access required by these categories. Table 9-1 sums up the
interactions.
While Java’s access control mechanism may seem complicated, we can simplify it as
follows. Anything declared public can be accessed from anywhere. Anything declared
private cannot be seen outside of its class. When a member does not have an explicit accessChapter 9:
T ABLE 9-1
Class Member
Access
Packages and Interfaces
Private No Modifier Protected Public
Same class Yes Yes Yes Yes
Same
package
subclass No Yes Yes Yes
Same
No
package
non-subclass Yes Yes Yes
Different
package
subclass No No Yes Yes
Different
No
package
non-subclass No No Yes
specification, it is visible to subclasses as well as to other classes in the same package. This is
the default access. If you want to allow an element to be seen outside your current package,
but only to classes that subclass your class directly, then declare that element protected.
Table 9-1 applies only to members of classes. A non-nested class has only two possible
access levels: default and public. When a class is declared as public, it is accessible by any
other code. If a class has default access, then it can only be accessed by other code within its
same package. When a class is public, it must be the only public class declared in the file,
and the file must have the same name as the class.
An Access Example
The following example shows all combinations of the access control modifiers. This example
has two packages and five classes. Remember that the classes for the two different
packages need to be stored in directories named after their respective packages—in this
case, p1 and p2.
The source for the first package defines three classes: Protection, Derived, and SamePackage.
The first class defines four int variables in each of the legal protection modes. The variable n
is declared with the default protection, n_pri is private, n_pro is protected, and n_pub is
public.
Each subsequent class in this example will try to access the variables in an instance
of this class. The lines that will not compile due to access restrictions are commented out.
Before each of these lines is a comment listing the places from which this level of protection
would allow access.
The second class, Derived, is a subclass of Protection in the same package, p1. This
grants Derived access to every variable in Protection except for n_pri, the private one. The
third class, SamePackage, is not a subclass of Protection, but is in the same package and
also has access to all but n_pri.
187188
Part I:
The Java Language
This is file Protection.java:
package p1;
public class Protection 
This is file Derived.java:
package p1;
class Derived extends Protection 
This is file SamePackage.java:
package p1;
class SamePackage Chapter 9:
Packages and Interfaces
Following is the source code for the other package, p2. The two classes defined in p2
cover the other two conditions that are affected by access control. The first class, Protection2, is
a subclass of p1.Protection. This grants access to all of p1.Protection’s variables except for
n_pri (because it is private) and n, the variable declared with the default protection. Remember,
the default only allows access from within the class or the package, not extra-package
subclasses. Finally, the class OtherPackage has access to only one variable, n_pub, which
was declared public.
This is file Protection2.java:
package p2;
class Protection2 extends p1.Protection 
This is file OtherPackage.java:
package p2;
class OtherPackage 
189190
Part I:
The Java Language
If you wish to try these two packages, here are two test files you can use. The one for
package p1 is shown here:
// Demo package p1.
package p1;
// Instantiate the various classes in p1.
public class Demo 
The test file for p2 is shown next:
// Demo package p2.
package p2;
// Instantiate the various classes in p2.
public class Demo 
Importing Packages
Given that packages exist and are a good mechanism for compartmentalizing diverse classes
from each other, it is easy to see why all of the built-in Java classes are stored in packages.
There are no core Java classes in the unnamed default package; all of the standard classes
are stored in some named package. Since classes within packages must be fully qualified
with their package name or names, it could become tedious to type in the long dot-separated
package path name for every class you want to use. For this reason, Java includes the import
statement to bring certain classes, or entire packages, into visibility. Once imported, a class
can be referred to directly, using only its name. The import statement is a convenience to
the programmer and is not technically needed to write a complete Java program. If you are
going to refer to a few dozen classes in your application, however, the import statement will
save a lot of typing.
In a Java source file, import statements occur immediately following the package statement
(if it exists) and before any class definitions. This is the general form of the import statement:
import pkg1[.pkg2].(classname|*);
Here, pkg1 is the name of a top-level package, and pkg2 is the name of a subordinate
package inside the outer package separated by a dot (.). There is no practical limit on the
depth of a package hierarchy, except that imposed by the file system. Finally, you specifyChapter 9:
Packages and Interfaces
either an explicit classname or a star (*), which indicates that the Java compiler should import
the entire package. This code fragment shows both forms in use:
import java.util.Date;
import java.io.*;
C AUTION The star form may increase compilation time—especially if you import several large
packages. For this reason it is a good idea to explicitly name the classes that you want to use
rather than importing whole packages. However, the star form has absolutely no effect on the
run-time performance or size of your classes.
All of the standard Java classes included with Java are stored in a package called java.
The basic language functions are stored in a package inside of the java package called
java.lang. Normally, you have to import every package or class that you want to use, but
since Java is useless without much of the functionality in java.lang, it is implicitly imported
by the compiler for all programs. This is equivalent to the following line being at the top of
all of your programs:
import java.lang.*;
If a class with the same name exists in two different packages that you import using the
star form, the compiler will remain silent, unless you try to use one of the classes. In that case,
you will get a compile-time error and have to explicitly name the class specifying its package.
It must be emphasized that the import statement is optional. Any place you use a class
name, you can use its fully qualified name, which includes its full package hierarchy. For
example, this fragment uses an import statement:
import java.util.*;
class MyDate extends Date 
The same example without the import statement looks like this:
class MyDate extends java.util.Date 
In this version, Date is fully-qualified.
As shown in Table 9-1, when a package is imported, only those items within the package
declared as public will be available to non-subclasses in the importing code. For example,
if you want the Balance class of the package MyPack shown earlier to be available as a
stand-alone class for general use outside of MyPack, then you will need to declare it as
public and put it into its own file, as shown here:
package MyPack;
/* Now, the Balance class, its constructor, and its
show() method are public. This means that they can
be used by non-subclass code outside their package.
*/
public class Balance 
As you can see, the Balance class is now public. Also, its constructor and its show( )
method are public, too. This means that they can be accessed by any type of code outside
the MyPack package. For example, here TestBalance imports MyPack and is then able to
make use of the Balance class:
import MyPack.*;
class TestBalance 
As an experiment, remove the public specifier from the Balance class and then try
compiling TestBalance. As explained, errors will result.
Interfaces
Using the keyword interface, you can fully abstract a class’ interface from its implementation.
That is, using interface, you can specify what a class must do, but not how it does it. Interfaces
are syntactically similar to classes, but they lack instance variables, and their methods are
declared without any body. In practice, this means that you can define interfaces that don’t
make assumptions about how they are implemented. Once it is defined, any number of
classes can implement an interface. Also, one class can implement any number of interfaces.
To implement an interface, a class must create the complete set of methods defined by
the interface. However, each class is free to determine the details of its own implementation.
By providing the interface keyword, Java allows you to fully utilize the “one interface,
multiple methods” aspect of polymorphism.Chapter 9:
Packages and Interfaces
Interfaces are designed to support dynamic method resolution at run time. Normally,
in order for a method to be called from one class to another, both classes need to be present
at compile time so the Java compiler can check to ensure that the method signatures are
compatible. This requirement by itself makes for a static and nonextensible classing
environment. Inevitably in a system like this, functionality gets pushed up higher and higher
in the class hierarchy so that the mechanisms will be available to more and more subclasses.
Interfaces are designed to avoid this problem. They disconnect the definition of a method or
set of methods from the inheritance hierarchy. Since interfaces are in a different hierarchy from
classes, it is possible for classes that are unrelated in terms of the class hierarchy to implement
the same interface. This is where the real power of interfaces is realized.
N OTE Interfaces add most of the functionality that is required for many applications that would
normally resort to using multiple inheritance in a language such as C++.
Defining an Interface
An interface is defined much like a class. This is the general form of an interface:
access interface name 
When no access specifier is included, then default access results, and the interface is only
available to other members of the package in which it is declared. When it is declared as
public, the interface can be used by any other code. In this case, the interface must be the
only public interface declared in the file, and the file must have the same name as the interface.
name is the name of the interface, and can be any valid identifier. Notice that the methods that
are declared have no bodies. They end with a semicolon after the parameter list. They are,
essentially, abstract methods; there can be no default implementation of any method specified
within an interface. Each class that includes an interface must implement all of the methods.
Variables can be declared inside of interface declarations. They are implicitly final and
static, meaning they cannot be changed by the implementing class. They must also be
initialized. All methods and variables are implicitly public.
Here is an example of an interface definition. It declares a simple interface that contains
one method called callback( ) that takes a single integer parameter.
interface Callback 
193194
Part I:
The Java Language
Implementing Interfaces
Once an interface has been defined, one or more classes can implement that interface. To
implement an interface, include the implements clause in a class definition, and then create
the methods defined by the interface. The general form of a class that includes the implements
clause looks like this:
class classname [extends superclass] [implements interface [,interface...]] 
If a class implements more than one interface, the interfaces are separated with a comma. If
a class implements two interfaces that declare the same method, then the same method will
be used by clients of either interface. The methods that implement an interface must be
declared public. Also, the type signature of the implementing method must match exactly
the type signature specified in the interface definition.
Here is a small example class that implements the Callback interface shown earlier.
class Client implements Callback 
Notice that callback( ) is declared using the public access specifier.
R EMEMBER When you implement an interface method, it must be declared as public.
It is both permissible and common for classes that implement interfaces to define
additional members of their own. For example, the following version of Client implements
callback( ) and adds the method nonIfaceMeth( ):
class Client implements Callback Chapter 9:
Packages and Interfaces
Accessing Implementations Through Interface References
You can declare variables as object references that use an interface rather than a class type.
Any instance of any class that implements the declared interface can be referred to by such
a variable. When you call a method through one of these references, the correct version will
be called based on the actual instance of the interface being referred to. This is one of the
key features of interfaces. The method to be executed is looked up dynamically at run time,
allowing classes to be created later than the code which calls methods on them. The calling
code can dispatch through an interface without having to know anything about the “callee.”
This process is similar to using a superclass reference to access a subclass object, as described
in Chapter 8.
C AUTION Because dynamic lookup of a method at run time incurs a significant overhead when
compared with the normal method invocation in Java, you should be careful not to use interfaces
casually in performance-critical code.
The following example calls the callback( ) method via an interface reference variable:
class TestIface 
The output of this program is shown here:
callback called with 42
Notice that variable c is declared to be of the interface type Callback, yet it was assigned an
instance of Client. Although c can be used to access the callback( ) method, it cannot access
any other members of the Client class. An interface reference variable only has knowledge
of the methods declared by its interface declaration. Thus, c could not be used to access
nonIfaceMeth( ) since it is defined by Client but not Callback.
While the preceding example shows, mechanically, how an interface reference variable
can access an implementation object, it does not demonstrate the polymorphic power of
such a reference. To sample this usage, first create the second implementation of Callback,
shown here:
// Another implementation of Callback.
class AnotherClient implements Callback 
195196
Part I:
The Java Language
Now, try the following class:
class TestIface2 
The output from this program is shown here:
callback called with 42
Another version of callback
p squared is 1764
As you can see, the version of callback( ) that is called is determined by the type of object
that c refers to at run time. While this is a very simple example, you will see another, more
practical one shortly.
Partial Implementations
If a class includes an interface but does not fully implement the methods defined by that
interface, then that class must be declared as abstract. For example:
abstract class Incomplete implements Callback 
Here, the class Incomplete does not implement callback( ) and must be declared as abstract.
Any class that inherits Incomplete must implement callback( ) or be declared abstract itself.
Nested Interfaces
An interface can be declared a member of a class or another interface. Such an interface is
called a member interface or a nested interface. A nested interface can be declared as public,
private, or protected. This differs from a top-level interface, which must either be declared
as public or use the default access level, as previously described. When a nested interface is
used outside of its enclosing scope, it must be qualified by the name of the class or interface
of which it is a member. Thus, outside of the class or interface in which a nested interface is
declared, its name must be fully qualified.
Here is an example that demonstrates a nested interface:
// A nested interface example.
// This class contains a member interface.
class A 
// B implements the nested interface.
class B implements A.NestedIF 
class NestedIFDemo 
Notice that A defines a member interface called NestedIF and that it is declared public.
Next, B implements the nested interface by specifying
implements A.NestedIF
Notice that the name is fully qualified by the enclosing class’ name. Inside the main( )
method, an A.NestedIF reference called nif is created, and it is assigned a reference to a
B object. Because B implements A.NestedIF, this is legal.
Applying Interfaces
To understand the power of interfaces, let’s look at a more practical example. In earlier
chapters, you developed a class called Stack that implemented a simple fixed-size stack.
However, there are many ways to implement a stack. For example, the stack can be of a
fixed size or it can be “growable.” The stack can also be held in an array, a linked list, a
binary tree, and so on. No matter how the stack is implemented, the interface to the stack
remains the same. That is, the methods push( ) and pop( ) define the interface to the stack
independently of the details of the implementation. Because the interface to a stack is
separate from its implementation, it is easy to define a stack interface, leaving it to each
implementation to define the specifics. Let’s look at two examples.
First, here is the interface that defines an integer stack. Put this in a file called IntStack.java.
This interface will be used by both stack implementations.
// Define an integer stack interface.
interface IntStack 
197198
Part I:
The Java Language
The following program creates a class called FixedStack that implements a fixed-length
version of an integer stack:
// An implementation of IntStack that uses fixed storage.
class FixedStack implements IntStack 
class IFTest Chapter 9:
Packages and Interfaces
Following is another implementation of IntStack that creates a dynamic stack by use
of the same interface definition. In this implementation, each stack is constructed with an
initial length. If this initial length is exceeded, then the stack is increased in size. Each time
more room is needed, the size of the stack is doubled.
// Implement a "growable" stack.
class DynStack implements IntStack 
class IFTest2 
The following class uses both the FixedStack and DynStack implementations. It does
so through an interface reference. This means that calls to push( ) and pop( ) are resolved
at run time rather than at compile time.
/* Create an interface variable and
access stacks through it.
*/
class IFTest3 
In this program, mystack is a reference to the IntStack interface. Thus, when it refers to ds,
it uses the versions of push( ) and pop( ) defined by the DynStack implementation. When it
refers to fs, it uses the versions of push( ) and pop( ) defined by FixedStack. As explained,
these determinations are made at run time. Accessing multiple implementations of an interface
through an interface reference variable is the most powerful way that Java achieves run-time
polymorphism.
Variables in Interfaces
You can use interfaces to import shared constants into multiple classes by simply declaring
an interface that contains variables that are initialized to the desired values. When you
include that interface in a class (that is, when you “implement” the interface), all of those
variable names will be in scope as constants. (This is similar to using a header file in C/C++
to create a large number of #defined constants or const declarations.) If an interface contains
no methods, then any class that includes such an interface doesn’t actually implement anything.Chapter 9:
Packages and Interfaces
It is as if that class were importing the constant fields into the class name space as final
variables. The next example uses this technique to implement an automated “decision maker”:
import java.util.Random;
interface SharedConstants 
class Question implements SharedConstants 
class AskMe implements SharedConstants 
Notice that this program makes use of one of Java’s standard classes: Random. This class
provides pseudorandom numbers. It contains several methods that allow you to obtain
random numbers in the form required by your program. In this example, the method
nextDouble( ) is used. It returns random numbers in the range 0.0 to 1.0.
In this sample program, the two classes, Question and AskMe, both implement the
SharedConstants interface where NO, YES, MAYBE, SOON, LATER, and NEVER are
defined. Inside each class, the code refers to these constants as if each class had defined or
inherited them directly. Here is the output of a sample run of this program. Note that the
results are different each time it is run.
Later
Soon
No
Yes
Interfaces Can Be Extended
One interface can inherit another by use of the keyword extends. The syntax is the same as
for inheriting classes. When a class implements an interface that inherits another interface,
it must provide implementations for all methods defined within the interface inheritance
chain. Following is an example:
// One interface can extend another.
interface A 
// B now includes meth1() and meth2() -- it adds meth3().
interface B extends A 
// This class must implement all of A and B
class MyClass implements B 
class IFExtend 
As an experiment, you might want to try removing the implementation for meth1( ) in
MyClass. This will cause a compile-time error. As stated earlier, any class that implements
an interface must implement all methods defined by that interface, including any that are
inherited from other interfaces.
Although the examples we’ve included in this book do not make frequent use of packages
or interfaces, both of these tools are an important part of the Java programming environment.
Virtually all real programs that you write in Java will be contained within packages. A number
will probably implement interfaces as well. It is important, therefore, that you be comfortable
with their usage.
203This page intentionally left blank10
Exception Handling
T
his chapter examines Java’s exception-handling mechanism. An exception is an abnormal
condition that arises in a code sequence at run time. In other words, an exception is a
run-time error. In computer languages that do not support exception handling, errors
must be checked and handled manually—typically through the use of error codes, and so
on. This approach is as cumbersome as it is troublesome. Java’s exception handling avoids
these problems and, in the process, brings run-time error management into the object-
oriented world.
Exception-Handling Fundamentals
A Java exception is an object that describes an exceptional (that is, error) condition that has
occurred in a piece of code. When an exceptional condition arises, an object representing
that exception is created and thrown in the method that caused the error. That method may
choose to handle the exception itself, or pass it on. Either way, at some point, the exception
is caught and processed. Exceptions can be generated by the Java run-time system, or they
can be manually generated by your code. Exceptions thrown by Java relate to fundamental
errors that violate the rules of the Java language or the constraints of the Java execution
environment. Manually generated exceptions are typically used to report some error condition
to the caller of a method.
Java exception handling is managed via five keywords: try, catch, throw, throws, and
finally. Briefly, here is how they work. Program statements that you want to monitor for
exceptions are contained within a try block. If an exception occurs within the try block, it is
thrown. Your code can catch this exception (using catch) and handle it in some rational manner.
System-generated exceptions are automatically thrown by the Java run-time system. To
manually throw an exception, use the keyword throw. Any exception that is thrown out of
a method must be specified as such by a throws clause. Any code that absolutely must be
executed after a try block completes is put in a finally block.
This is the general form of an exception-handling block:
try 
205206
Part I:
The Java Language
catch (ExceptionType1 exOb) 
catch (ExceptionType2 exOb) 
// ...
finally 
Here, ExceptionType is the type of exception that has occurred. The remainder of this chapter
describes how to apply this framework.
Exception Types
All exception types are subclasses of the built-in class Throwable. Thus, Throwable is at the
top of the exception class hierarchy. Immediately below Throwable are two subclasses that
partition exceptions into two distinct branches. One branch is headed by Exception. This class
is used for exceptional conditions that user programs should catch. This is also the class that
you will subclass to create your own custom exception types. There is an important subclass
of Exception, called RuntimeException. Exceptions of this type are automatically defined for
the programs that you write and include things such as division by zero and invalid array
indexing.
The other branch is topped by Error, which defines exceptions that are not expected to
be caught under normal circumstances by your program. Exceptions of type Error are used
by the Java run-time system to indicate errors having to do with the run-time environment,
itself. Stack overflow is an example of such an error. This chapter will not be dealing with
exceptions of type Error, because these are typically created in response to catastrophic failures
that cannot usually be handled by your program.
Uncaught Exceptions
Before you learn how to handle exceptions in your program, it is useful to see what happens
when you don’t handle them. This small program includes an expression that intentionally
causes a divide-by-zero error:
class Exc0 
When the Java run-time system detects the attempt to divide by zero, it constructs a
new exception object and then throws this exception. This causes the execution of Exc0 toChapter 10:
Exception Handling
stop, because once an exception has been thrown, it must be caught by an exception handler
and dealt with immediately. In this example, we haven’t supplied any exception handlers of
our own, so the exception is caught by the default handler provided by the Java run-time
system. Any exception that is not caught by your program will ultimately be processed by
the default handler. The default handler displays a string describing the exception, prints a
stack trace from the point at which the exception occurred, and terminates the program.
Here is the exception generated when this example is executed:
java.lang.ArithmeticException: / by zero
at Exc0.main(Exc0.java:4)
Notice how the class name, Exc0; the method name, main; the filename, Exc0.java;
and the line number, 4, are all included in the simple stack trace. Also, notice that the type
of exception thrown is a subclass of Exception called ArithmeticException, which more
specifically describes what type of error happened. As discussed later in this chapter, Java
supplies several built-in exception types that match the various sorts of run-time errors that
can be generated.
The stack trace will always show the sequence of method invocations that led up to
the error. For example, here is another version of the preceding program that introduces the
same error but in a method separate from main( ):
class Exc1 
The resulting stack trace from the default exception handler shows how the entire call
stack is displayed:
java.lang.ArithmeticException: / by zero
at Exc1.subroutine(Exc1.java:4)
at Exc1.main(Exc1.java:7)
As you can see, the bottom of the stack is main’s line 7, which is the call to subroutine( ),
which caused the exception at line 4. The call stack is quite useful for debugging, because it
pinpoints the precise sequence of steps that led to the error.
Using try and catch
Although the default exception handler provided by the Java run-time system is useful for
debugging, you will usually want to handle an exception yourself. Doing so provides two
benefits. First, it allows you to fix the error. Second, it prevents the program from automatically
terminating. Most users would be confused (to say the least) if your program stopped
207208
Part I:
The Java Language
running and printed a stack trace whenever an error occurred! Fortunately, it is quite easy
to prevent this.
To guard against and handle a run-time error, simply enclose the code that you want
to monitor inside a try block. Immediately following the try block, include a catch clause
that specifies the exception type that you wish to catch. To illustrate how easily this can be
done, the following program includes a try block and a catch clause that processes the
ArithmeticException generated by the division-by-zero error:
class Exc2 
This program generates the following output:
Division by zero.
After catch statement.
Notice that the call to println( ) inside the try block is never executed. Once an exception
is thrown, program control transfers out of the try block into the catch block. Put differently,
catch is not “called,” so execution never “returns” to the try block from a catch. Thus, the
line “This will not be printed.” is not displayed. Once the catch statement has executed,
program control continues with the next line in the program following the entire try/catch
mechanism.
A try and its catch statement form a unit. The scope of the catch clause is restricted to
those statements specified by the immediately preceding try statement. A catch statement
cannot catch an exception thrown by another try statement (except in the case of nested try
statements, described shortly). The statements that are protected by try must be surrounded
by curly braces. (That is, they must be within a block.) You cannot use try on a single statement.
The goal of most well-constructed catch clauses should be to resolve the exceptional
condition and then continue on as if the error had never happened. For example, in the next
program each iteration of the for loop obtains two random integers. Those two integers are
divided by each other, and the result is used to divide the value 12345. The final result is put
into a. If either division operation causes a divide-by-zero error, it is caught, the value of a is
set to zero, and the program continues.
// Handle an exception and move on.
import java.util.Random;
class HandleError 
Displaying a Description of an Exception
Throwable overrides the toString( ) method (defined by Object) so that it returns a string
containing a description of the exception. You can display this description in a println( )
statement by simply passing the exception as an argument. For example, the catch block
in the preceding program can be rewritten like this:
catch (ArithmeticException e) 
When this version is substituted in the program, and the program is run, each divide-by-
zero error displays the following message:
Exception: java.lang.ArithmeticException: / by zero
While it is of no particular value in this context, the ability to display a description of
an exception is valuable in other circumstances—particularly when you are experimenting
with exceptions or when you are debugging.
Multiple catch Clauses
In some cases, more than one exception could be raised by a single piece of code. To handle
this type of situation, you can specify two or more catch clauses, each catching a different
type of exception. When an exception is thrown, each catch statement is inspected in order,
and the first one whose type matches that of the exception is executed. After one catch
statement executes, the others are bypassed, and execution continues after the try/catch
block. The following example traps two different exception types:
// Demonstrate multiple catch statements.
class MultiCatch 
This program will cause a division-by-zero exception if it is started with no command-
line arguments, since a will equal zero. It will survive the division if you provide a
command-line argument, setting a to something larger than zero. But it will cause an
ArrayIndexOutOfBoundsException, since the int array c has a length of 1, yet the program
attempts to assign a value to c[42].
Here is the output generated by running it both ways:
C:\>java MultiCatch
a = 0
Divide by 0: java.lang.ArithmeticException: / by zero
After try/catch blocks.
C:\>java MultiCatch TestArg
a = 1
Array index oob: java.lang.ArrayIndexOutOfBoundsException:42
After try/catch blocks.
When you use multiple catch statements, it is important to remember that exception
subclasses must come before any of their superclasses. This is because a catch statement
that uses a superclass will catch exceptions of that type plus any of its subclasses. Thus, a
subclass would never be reached if it came after its superclass. Further, in Java, unreachable
code is an error. For example, consider the following program:
/* This program contains an error.
A subclass must come before its superclass in
a series of catch statements. If not,
unreachable code will be created and a
compile-time error will result.
*/
class SuperSubCatch 
If you try to compile this program, you will receive an error message stating that the
second catch statement is unreachable because the exception has already been caught. Since
ArithmeticException is a subclass of Exception, the first catch statement will handle all
Exception-based errors, including ArithmeticException. This means that the second catch
statement will never execute. To fix the problem, reverse the order of the catch statements.
Nested try Statements
The try statement can be nested. That is, a try statement can be inside the block of another try.
Each time a try statement is entered, the context of that exception is pushed on the stack. If an
inner try statement does not have a catch handler for a particular exception, the stack is
unwound and the next try statement’s catch handlers are inspected for a match. This continues
until one of the catch statements succeeds, or until all of the nested try statements are exhausted.
If no catch statement matches, then the Java run-time system will handle the exception. Here
is an example that uses nested try statements:
// An example of nested try statements.
class NestTry 
As you can see, this program nests one try block within another. The program works as
follows. When you execute the program with no command-line arguments, a divide-by-zero
exception is generated by the outer try block. Execution of the program with one command-line
argument generates a divide-by-zero exception from within the nested try block. Since the
inner block does not catch this exception, it is passed on to the outer try block, where it is
handled. If you execute the program with two command-line arguments, an array boundary
exception is generated from within the inner try block. Here are sample runs that illustrate
each case:
C:\>java NestTry
Divide by 0: java.lang.ArithmeticException: / by zero
C:\>java NestTry One
a = 1
Divide by 0: java.lang.ArithmeticException: / by zero
C:\>java NestTry One Two
a = 2
Array index out-of-bounds:
java.lang.ArrayIndexOutOfBoundsException:42
Nesting of try statements can occur in less obvious ways when method calls are involved.
For example, you can enclose a call to a method within a try block. Inside that method is
another try statement. In this case, the try within the method is still nested inside the outer try
block, which calls the method. Here is the previous program recoded so that the nested
try block is moved inside the method nesttry( ):
/* Try statements can be implicitly nested via
calls to methods. */
class MethNestTry 
The output of this program is identical to that of the preceding example.
throw
So far, you have only been catching exceptions that are thrown by the Java run-time system.
However, it is possible for your program to throw an exception explicitly, using the throw
statement. The general form of throw is shown here:
throw ThrowableInstance;
Here, ThrowableInstance must be an object of type Throwable or a subclass of Throwable.
Primitive types, such as int or char, as well as non-Throwable classes, such as String and
Object, cannot be used as exceptions. There are two ways you can obtain a Throwable object:
using a parameter in a catch clause, or creating one with the new operator.
The flow of execution stops immediately after the throw statement; any subsequent
statements are not executed. The nearest enclosing try block is inspected to see if it has a
catch statement that matches the type of exception. If it does find a match, control is
transferred to that statement. If not, then the next enclosing try statement is inspected, and
so on. If no matching catch is found, then the default exception handler halts the program
and prints the stack trace.
213214
Part I:
The Java Language
Here is a sample program that creates and throws an exception. The handler that catches
the exception rethrows it to the outer handler.
// Demonstrate throw.
class ThrowDemo 
This program gets two chances to deal with the same error. First, main( ) sets up an exception
context and then calls demoproc( ). The demoproc( ) method then sets up another exception-
handling context and immediately throws a new instance of NullPointerException, which
is caught on the next line. The exception is then rethrown. Here is the resulting output:
Caught inside demoproc.
Recaught: java.lang.NullPointerException: demo
The program also illustrates how to create one of Java’s standard exception objects. Pay
close attention to this line:
throw new NullPointerException("demo");
Here, new is used to construct an instance of NullPointerException. Many of Java’s built-
in run-time exceptions have at least two constructors: one with no parameter and one that
takes a string parameter. When the second form is used, the argument specifies a string that
describes the exception. This string is displayed when the object is used as an argument to
print( ) or println( ). It can also be obtained by a call to getMessage( ), which is defined by
Throwable.
throws
If a method is capable of causing an exception that it does not handle, it must specify this
behavior so that callers of the method can guard themselves against that exception. You do
this by including a throws clause in the method’s declaration. A throws clause lists the types
of exceptions that a method might throw. This is necessary for all exceptions, except those ofChapter 10:
Exception Handling
type Error or RuntimeException, or any of their subclasses. All other exceptions that a method
can throw must be declared in the throws clause. If they are not, a compile-time error will result.
This is the general form of a method declaration that includes a throws clause:
type method-name(parameter-list) throws exception-list

Here, exception-list is a comma-separated list of the exceptions that a method can throw.
Following is an example of an incorrect program that tries to throw an exception that it
does not catch. Because the program does not specify a throws clause to declare this fact, the
program will not compile.
// This program contains an error and will not compile.
class ThrowsDemo 
To make this example compile, you need to make two changes. First, you need to declare
that throwOne( ) throws IllegalAccessException. Second, main( ) must define a try/catch
statement that catches this exception.
The corrected example is shown here:
// This is now correct.
class ThrowsDemo 
Here is the output generated by running this example program:
inside throwOne
caught java.lang.IllegalAccessException: demo
215216
Part I:
The Java Language
finally
When exceptions are thrown, execution in a method takes a rather abrupt, nonlinear path
that alters the normal flow through the method. Depending upon how the method is coded,
it is even possible for an exception to cause the method to return prematurely. This could
be a problem in some methods. For example, if a method opens a file upon entry and
closes it upon exit, then you will not want the code that closes the file to be bypassed
by the exception-handling mechanism. The finally keyword is designed to address this
contingency.
finally creates a block of code that will be executed after a try/catch block has
completed and before the code following the try/catch block. The finally block will
execute whether or not an exception is thrown. If an exception is thrown, the finally
block will execute even if no catch statement matches the exception. Any time a method
is about to return to the caller from inside a try/catch block, via an uncaught exception or
an explicit return statement, the finally clause is also executed just before the method
returns. This can be useful for closing file handles and freeing up any other resources that
might have been allocated at the beginning of a method with the intent of disposing of them
before returning. The finally clause is optional. However, each try statement requires at
least one catch or a finally clause.
Here is an example program that shows three methods that exit in various ways, none
without executing their finally clauses:
// Demonstrate finally.
class FinallyDemo 
In this example, procA( ) prematurely breaks out of the try by throwing an exception.
The finally clause is executed on the way out. procB( )’s try statement is exited via a return
statement. The finally clause is executed before procB( ) returns. In procC( ), the try statement
executes normally, without error. However, the finally block is still executed.
R EMEMBER If a finally block is associated with a try, the finally block will be executed upon
conclusion of the try.
Here is the output generated by the preceding program:
inside procA
procA’s finally
Exception caught
inside procB
procB’s finally
inside procC
procC’s finally
Java’s Built-in Exceptions
Inside the standard package java.lang, Java defines several exception classes. A few have
been used by the preceding examples. The most general of these exceptions are subclasses
of the standard type RuntimeException. As previously explained, these exceptions need
not be included in any method’s throws list. In the language of Java, these are called
unchecked exceptions because the compiler does not check to see if a method handles or
throws these exceptions. The unchecked exceptions defined in java.lang are listed in
Table 10-1. Table 10-2 lists those exceptions defined by java.lang that must be included
in a method’s throws list if that method can generate one of these exceptions and does
not handle it itself. These are called checked exceptions. Java defines several other types
of exceptions that relate to its various class libraries.
217218
Part I:
The Java Language
Exception Meaning
ArithmeticException Arithmetic error, such as divide-by-zero.
ArrayIndexOutOfBoundsException Array index is out-of-bounds.
ArrayStoreException Assignment to an array element of an incompatible type.
ClassCastException Invalid cast.
EnumConstantNotPresentException An attempt is made to use an undefined enumeration value.
IllegalArgumentException Illegal argument used to invoke a method.
IllegalMonitorStateException Illegal monitor operation, such as waiting on an unlocked
thread.
IllegalStateException Environment or application is in incorrect state.
IllegalThreadStateException Requested operation not compatible with current thread
state.
IndexOutOfBoundsException Some type of index is out-of-bounds.
NegativeArraySizeException Array created with a negative size.
NullPointerException Invalid use of a null reference.
NumberFormatException Invalid conversion of a string to a numeric format.
SecurityException Attempt to violate security.
StringIndexOutOfBounds Attempt to index outside the bounds of a string.
TypeNotPresentException Type not found.
UnsupportedOperationException An unsupported operation was encountered.
T ABLE 10-1
Java’s Unchecked RuntimeException Subclasses Defined in java.lang
Exception Meaning
ClassNotFoundException Class not found.
CloneNotSupportedException Attempt to clone an object that does not implement the Cloneable
interface.
IllegalAccessException Access to a class is denied.
InstantiationException Attempt to create an object of an abstract class or interface.
InterruptedException One thread has been interrupted by another thread.
NoSuchFieldException A requested field does not exist.
NoSuchMethodException A requested method does not exist.
T ABLE 10-2
Java’s Checked Exceptions Defined in java.langChapter 10:
Exception Handling
Creating Your Own Exception Subclasses
Although Java’s built-in exceptions handle most common errors, you will probably want
to create your own exception types to handle situations specific to your applications. This
is quite easy to do: just define a subclass of Exception (which is, of course, a subclass of
Throwable). Your subclasses don’t need to actually implement anything—it is their existence
in the type system that allows you to use them as exceptions.
The Exception class does not define any methods of its own. It does, of course, inherit
those methods provided by Throwable. Thus, all exceptions, including those that you create,
have the methods defined by Throwable available to them. They are shown in Table 10-3.
Method Description
Throwable fillInStackTrace( ) Returns a Throwable object that contains a completed
stack trace. This object can be rethrown.
Throwable getCause( ) Returns the exception that underlies the current
exception. If there is no underlying exception, null
is returned.
String getLocalizedMessage( ) Returns a localized description of the exception.
String getMessage( ) Returns a description of the exception.
StackTraceElement[ ] getStackTrace( ) Returns an array that contains the stack trace, one
element at a time, as an array of StackTraceElement.
The method at the top of the stack is the last method
called before the exception was thrown. This method
is found in the first element of the array. The
StackTraceElement class gives your program access
to information about each element in the trace, such
as its method name.
Throwable initCause(Throwable
causeExc) Associates causeExc with the invoking exception as a
cause of the invoking exception. Returns a reference
to the exception.
void printStackTrace( ) Displays the stack trace.
void printStackTrace(PrintStream
stream) Sends the stack trace to the specified stream.
void printStackTrace(PrintWriter
stream) Sends the stack trace to the specified stream.
void setStackTrace(StackTraceElement
Sets the stack trace to the elements passed in
elements[ ]) elements. This method is for specialized applications,
not normal use.
String toString( )
T ABLE 10-3
Returns a String object containing a description of the
exception. This method is called by println( ) when
outputting a Throwable object.
The Methods Defined by Throwable
219220
Part I:
The Java Language
You may also wish to override one or more of these methods in exception classes that you
create.
Exception defines four constructors. Two were added by JDK 1.4 to support chained
exceptions, described in the next section. The other two are shown here:
Exception( )
Exception(String msg)
The first form creates an exception that has no description. The second form lets you specify
a description of the exception.
Although specifying a description when an exception is created is often useful, sometimes
it is better to override toString( ). Here’s why: The version of toString( ) defined by Throwable
(and inherited by Exception) first displays the name of the exception followed by a colon, which
is then followed by your description. By overriding toString( ), you can prevent the exception
name and colon from being displayed. This makes for a cleaner output, which is desirable in
some cases.
The following example declares a new subclass of Exception and then uses that subclass
to signal an error condition in a method. It overrides the toString( ) method, allowing a
carefully tailored description of the exception to be displayed.
// This program creates a custom exception type.
class MyException extends Exception 
class ExceptionDemo 
This example defines a subclass of Exception called MyException. This subclass is quite
simple: it has only a constructor plus an overloaded toString( ) method that displays theChapter 10:
Exception Handling
value of the exception. The ExceptionDemo class defines a method named compute( ) that
throws a MyException object. The exception is thrown when compute( )’s integer parameter
is greater than 10. The main( ) method sets up an exception handler for MyException, then
calls compute( ) with a legal value (less than 10) and an illegal one to show both paths through
the code. Here is the result:
Called
Normal
Called
Caught
compute(1)
exit
compute(20)
MyException[20]
Chained Exceptions
Beginning with JDK 1.4, a new feature has been incorporated into the exception subsystem:
chained exceptions. The chained exception feature allows you to associate another exception
with an exception. This second exception describes the cause of the first exception. For example,
imagine a situation in which a method throws an ArithmeticException because of an attempt
to divide by zero. However, the actual cause of the problem was that an I/O error occurred,
which caused the divisor to be set improperly. Although the method must certainly throw
an ArithmeticException, since that is the error that occurred, you might also want to let the
calling code know that the underlying cause was an I/O error. Chained exceptions let you
handle this, and any other situation in which layers of exceptions exist.
To allow chained exceptions, two constructors and two methods were added to Throwable.
The constructors are shown here:
Throwable(Throwable causeExc)
Throwable(String msg, Throwable causeExc)
In the first form, causeExc is the exception that causes the current exception. That is, causeExc
is the underlying reason that an exception occurred. The second form allows you to specify
a description at the same time that you specify a cause exception. These two constructors
have also been added to the Error, Exception, and RuntimeException classes.
The chained exception methods added to Throwable are getCause( ) and initCause( ).
These methods are shown in Table 10-3 and are repeated here for the sake of discussion.
Throwable getCause( )
Throwable initCause(Throwable causeExc)
The getCause( ) method returns the exception that underlies the current exception. If there
is no underlying exception, null is returned. The initCause( ) method associates causeExc with
the invoking exception and returns a reference to the exception. Thus, you can associate a
cause with an exception after the exception has been created. However, the cause exception
can be set only once. Thus, you can call initCause( ) only once for each exception object.
Furthermore, if the cause exception was set by a constructor, then you can’t set it again
using initCause( ). In general, initCause( ) is used to set a cause for legacy exception classes
that don’t support the two additional constructors described earlier.
Here is an example that illustrates the mechanics of handling chained exceptions:
// Demonstrate exception chaining.
class ChainExcDemo 
The output from the program is shown here:
Caught: java.lang.NullPointerException: top layer
Original cause: java.lang.ArithmeticException: cause
In this example, the top-level exception is NullPointerException. To it is added a cause
exception, ArithmeticException. When the exception is thrown out of demoproc( ), it is
caught by main( ). There, the top-level exception is displayed, followed by the underlying
exception, which is obtained by calling getCause( ).
Chained exceptions can be carried on to whatever depth is necessary. Thus, the cause
exception can, itself, have a cause. Be aware that overly long chains of exceptions may
indicate poor design.
Chained exceptions are not something that every program will need. However, in cases
in which knowledge of an underlying cause is useful, they offer an elegant solution.
Using Exceptions
Exception handling provides a powerful mechanism for controlling complex programs that
have many dynamic run-time characteristics. It is important to think of try, throw, and catch
as clean ways to handle errors and unusual boundary conditions in your program’s logic.
Unlike some other languages in which error return codes are used to indicate failure, Java
uses exceptions. Thus, when a method can fail, have it throw an exception. This is a cleaner
way to handle failure modes.
One last point: Java’s exception-handling statements should not be considered a general
mechanism for nonlocal branching. If you do so, it will only confuse your code and make it
hard to maintain.11
Multithreaded Programming
U
nlike many other computer languages, Java provides built-in support for multithreaded
programming. A multithreaded program contains two or more parts that can run
concurrently. Each part of such a program is called a thread, and each thread defines
a separate path of execution. Thus, multithreading is a specialized form of multitasking.
You are almost certainly acquainted with multitasking, because it is supported by virtually
all modern operating systems. However, there are two distinct types of multitasking: process-
based and thread-based. It is important to understand the difference between the two. For
most readers, process-based multitasking is the more familiar form. A process is, in essence,
a program that is executing. Thus, process-based multitasking is the feature that allows your
computer to run two or more programs concurrently. For example, process-based multitasking
enables you to run the Java compiler at the same time that you are using a text editor. In process-
based multitasking, a program is the smallest unit of code that can be dispatched by the
scheduler.
In a thread-based multitasking environment, the thread is the smallest unit of dispatchable
code. This means that a single program can perform two or more tasks simultaneously. For
instance, a text editor can format text at the same time that it is printing, as long as these
two actions are being performed by two separate threads. Thus, process-based multitasking
deals with the “big picture,” and thread-based multitasking handles the details.
Multitasking threads require less overhead than multitasking processes. Processes are
heavyweight tasks that require their own separate address spaces. Interprocess communication
is expensive and limited. Context switching from one process to another is also costly. Threads,
on the other hand, are lightweight. They share the same address space and cooperatively
share the same heavyweight process. Interthread communication is inexpensive, and context
switching from one thread to the next is low cost. While Java programs make use of process-
based multitasking environments, process-based multitasking is not under the control of
Java. However, multithreaded multitasking is.
Multithreading enables you to write very efficient programs that make maximum use of
the CPU, because idle time can be kept to a minimum. This is especially important for the
interactive, networked environment in which Java operates, because idle time is common.
For example, the transmission rate of data over a network is much slower than the rate at
which the computer can process it. Even local file system resources are read and written at a
much slower pace than they can be processed by the CPU. And, of course, user input is much
slower than the computer. In a single-threaded environment, your program has to wait for
223224
Part I:
The Java Language
each of these tasks to finish before it can proceed to the next one—even though the CPU is
sitting idle most of the time. Multithreading lets you gain access to this idle time and put it
to good use.
If you have programmed for operating systems such as Windows, then you are already
familiar with multithreaded programming. However, the fact that Java manages threads makes
multithreading especially convenient, because many of the details are handled for you.
The Java Thread Model
The Java run-time system depends on threads for many things, and all the class libraries
are designed with multithreading in mind. In fact, Java uses threads to enable the entire
environment to be asynchronous. This helps reduce inefficiency by preventing the waste
of CPU cycles.
The value of a multithreaded environment is best understood in contrast to its counterpart.
Single-threaded systems use an approach called an event loop with polling. In this model, a
single thread of control runs in an infinite loop, polling a single event queue to decide what
to do next. Once this polling mechanism returns with, say, a signal that a network file is
ready to be read, then the event loop dispatches control to the appropriate event handler.
Until this event handler returns, nothing else can happen in the system. This wastes CPU
time. It can also result in one part of a program dominating the system and preventing any
other events from being processed. In general, in a singled-threaded environment, when a
thread blocks (that is, suspends execution) because it is waiting for some resource, the entire
program stops running.
The benefit of Java’s multithreading is that the main loop/polling mechanism is eliminated.
One thread can pause without stopping other parts of your program. For example, the idle
time created when a thread reads data from a network or waits for user input can be utilized
elsewhere. Multithreading allows animation loops to sleep for a second between each frame
without causing the whole system to pause. When a thread blocks in a Java program, only
the single thread that is blocked pauses. All other threads continue to run.
Threads exist in several states. A thread can be running. It can be ready to run as soon as
it gets CPU time. A running thread can be suspended, which temporarily suspends its activity.
A suspended thread can then be resumed, allowing it to pick up where it left off. A thread
can be blocked when waiting for a resource. At any time, a thread can be terminated, which
halts its execution immediately. Once terminated, a thread cannot be resumed.
Thread Priorities
Java assigns to each thread a priority that determines how that thread should be treated
with respect to the others. Thread priorities are integers that specify the relative priority
of one thread to another. As an absolute value, a priority is meaningless; a higher-priority
thread doesn’t run any faster than a lower-priority thread if it is the only thread running.
Instead, a thread’s priority is used to decide when to switch from one running thread to
the next. This is called a context switch. The rules that determine when a context switch
takes place are simple:Chapter 11:
Multithreaded Programming
• A thread can voluntarily relinquish control. This is done by explicitly yielding, sleeping,
or blocking on pending I/O. In this scenario, all other threads are examined, and the
highest-priority thread that is ready to run is given the CPU.
• A thread can be preempted by a higher-priority thread. In this case, a lower-priority thread
that does not yield the processor is simply preempted—no matter what it is doing—
by a higher-priority thread. Basically, as soon as a higher-priority thread wants to
run, it does. This is called preemptive multitasking.
In cases where two threads with the same priority are competing for CPU cycles, the
situation is a bit complicated. For operating systems such as Windows, threads of equal
priority are time-sliced automatically in round-robin fashion. For other types of operating
systems, threads of equal priority must voluntarily yield control to their peers. If they don’t,
the other threads will not run.
C AUTION Portability problems can arise from the differences in the way that operating systems
context-switch threads of equal priority.
Synchronization
Because multithreading introduces an asynchronous behavior to your programs, there must be
a way for you to enforce synchronicity when you need it. For example, if you want two threads
to communicate and share a complicated data structure, such as a linked list, you need some
way to ensure that they don’t conflict with each other. That is, you must prevent one thread
from writing data while another thread is in the middle of reading it. For this purpose, Java
implements an elegant twist on an age-old model of interprocess synchronization: the monitor.
The monitor is a control mechanism first defined by C.A.R. Hoare. You can think of a monitor
as a very small box that can hold only one thread. Once a thread enters a monitor, all other
threads must wait until that thread exits the monitor. In this way, a monitor can be used to
protect a shared asset from being manipulated by more than one thread at a time.
Most multithreaded systems expose monitors as objects that your program must explicitly
acquire and manipulate. Java provides a cleaner solution. There is no class “Monitor”; instead,
each object has its own implicit monitor that is automatically entered when one of the object’s
synchronized methods is called. Once a thread is inside a synchronized method, no other
thread can call any other synchronized method on the same object. This enables you to write
very clear and concise multithreaded code, because synchronization support is built into the
language.
Messaging
After you divide your program into separate threads, you need to define how they will
communicate with each other. When programming with most other languages, you must
depend on the operating system to establish communication between threads. This, of
course, adds overhead. By contrast, Java provides a clean, low-cost way for two or more
threads to talk to each other, via calls to predefined methods that all objects have. Java’s
messaging system allows a thread to enter a synchronized method on an object, and then
wait there until some other thread explicitly notifies it to come out.
225226
Part I:
The Java Language
The Thread Class and the Runnable Interface
Java’s multithreading system is built upon the Thread class, its methods, and its companion
interface, Runnable. Thread encapsulates a thread of execution. Since you can’t directly refer
to the ethereal state of a running thread, you will deal with it through its proxy, the Thread
instance that spawned it. To create a new thread, your program will either extend Thread or
implement the Runnable interface.
The Thread class defines several methods that help manage threads. The ones that will
be used in this chapter are shown here:
Method Meaning
getName Obtain a thread’s name.
getPriority Obtain a thread’s priority.
isAlive Determine if a thread is still running.
join Wait for a thread to terminate.
run Entry point for the thread.
sleep Suspend a thread for a period of time.
start Start a thread by calling its run method.
Thus far, all the examples in this book have used a single thread of execution. The remainder
of this chapter explains how to use Thread and Runnable to create and manage threads,
beginning with the one thread that all Java programs have: the main thread.
The Main Thread
When a Java program starts up, one thread begins running immediately. This is usually
called the main thread of your program, because it is the one that is executed when your
program begins. The main thread is important for two reasons:
• It is the thread from which other “child” threads will be spawned.
• Often, it must be the last thread to finish execution because it performs various
shutdown actions.
Although the main thread is created automatically when your program is started, it can
be controlled through a Thread object. To do so, you must obtain a reference to it by calling
the method currentThread( ), which is a public static member of Thread. Its general form is
shown here:
static Thread currentThread( )
This method returns a reference to the thread in which it is called. Once you have a reference
to the main thread, you can control it just like any other thread.
Let’s begin by reviewing the following example:Chapter 11:
Multithreaded Programming
// Controlling the main Thread.
class CurrentThreadDemo 
In this program, a reference to the current thread (the main thread, in this case) is obtained
by calling currentThread( ), and this reference is stored in the local variable t. Next, the program
displays information about the thread. The program then calls setName( ) to change the
internal name of the thread. Information about the thread is then redisplayed. Next, a loop
counts down from five, pausing one second between each line. The pause is accomplished
by the sleep( ) method. The argument to sleep( ) specifies the delay period in milliseconds.
Notice the try/catch block around this loop. The sleep( ) method in Thread might throw
an InterruptedException. This would happen if some other thread wanted to interrupt this
sleeping one. This example just prints a message if it gets interrupted. In a real program, you
would need to handle this differently. Here is the output generated by this program:
Current thread: Thread[main,5,main]
After name change: Thread[My Thread,5,main]
5
4
3
2
1
Notice the output produced when t is used as an argument to println( ). This displays, in
order: the name of the thread, its priority, and the name of its group. By default, the name
of the main thread is main. Its priority is 5, which is the default value, and main is also the
name of the group of threads to which this thread belongs. A thread group is a data structure
that controls the state of a collection of threads as a whole. After the name of the thread is
changed, t is again output. This time, the new name of the thread is displayed.
227228
Part I:
The Java Language
Let’s look more closely at the methods defined by Thread that are used in the program.
The sleep( ) method causes the thread from which it is called to suspend execution for the
specified period of milliseconds. Its general form is shown here:
static void sleep(long milliseconds) throws InterruptedException
The number of milliseconds to suspend is specified in milliseconds. This method may throw
an InterruptedException.
The sleep( ) method has a second form, shown next, which allows you to specify the
period in terms of milliseconds and nanoseconds:
static void sleep(long milliseconds, int nanoseconds) throws InterruptedException
This second form is useful only in environments that allow timing periods as short as
nanoseconds.
As the preceding program shows, you can set the name of a thread by using setName( ).
You can obtain the name of a thread by calling getName( ) (but note that this is not shown in
the program). These methods are members of the Thread class and are declared like this:
final void setName(String threadName)
final String getName( )
Here, threadName specifies the name of the thread.
Creating a Thread
In the most general sense, you create a thread by instantiating an object of type Thread.
Java defines two ways in which this can be accomplished:
• You can implement the Runnable interface.
• You can extend the Thread class, itself.
The following two sections look at each method, in turn.
Implementing Runnable
The easiest way to create a thread is to create a class that implements the Runnable interface.
Runnable abstracts a unit of executable code. You can construct a thread on any object that
implements Runnable. To implement Runnable, a class need only implement a single method
called run( ), which is declared like this:
public void run( )
Inside run( ), you will define the code that constitutes the new thread. It is important to
understand that run( ) can call other methods, use other classes, and declare variables, just
like the main thread can. The only difference is that run( ) establishes the entry point for
another, concurrent thread of execution within your program. This thread will end when
run( ) returns.Chapter 11:
Multithreaded Programming
After you create a class that implements Runnable, you will instantiate an object of type
Thread from within that class. Thread defines several constructors. The one that we will use
is shown here:
Thread(Runnable threadOb, String threadName)
In this constructor, threadOb is an instance of a class that implements the Runnable interface.
This defines where execution of the thread will begin. The name of the new thread is specified
by threadName.
After the new thread is created, it will not start running until you call its start( ) method,
which is declared within Thread. In essence, start( ) executes a call to run( ). The start( )
method is shown here:
void start( )
Here is an example that creates a new thread and starts it running:
// Create a second thread.
class NewThread implements Runnable 
class ThreadDemo 
Inside NewThread’s constructor, a new Thread object is created by the following
statement:
t = new Thread(this, "Demo Thread");
Passing this as the first argument indicates that you want the new thread to call the run( )
method on this object. Next, start( ) is called, which starts the thread of execution beginning
at the run( ) method. This causes the child thread’s for loop to begin. After calling start( ),
NewThread’s constructor returns to main( ). When the main thread resumes, it enters its for
loop. Both threads continue running, sharing the CPU, until their loops finish. The output
produced by this program is as follows. (Your output may vary based on processor speed
and task load.)
Child thread: Thread[Demo Thread,5,main]
Main Thread: 5
Child Thread: 5
Child Thread: 4
Main Thread: 4
Child Thread: 3
Child Thread: 2
Main Thread: 3
Child Thread: 1
Exiting child thread.
Main Thread: 2
Main Thread: 1
Main thread exiting.
As mentioned earlier, in a multithreaded program, often the main thread must be the
last thread to finish running. In fact, for some older JVMs, if the main thread finishes before
a child thread has completed, then the Java run-time system may “hang.” The preceding
program ensures that the main thread finishes last, because the main thread sleeps for 1,000
milliseconds between iterations, but the child thread sleeps for only 500 milliseconds. This
causes the child thread to terminate earlier than the main thread. Shortly, you will see a
better way to wait for a thread to finish.
Extending Thread
The second way to create a thread is to create a new class that extends Thread, and then to
create an instance of that class. The extending class must override the run( ) method, which
is the entry point for the new thread. It must also call start( ) to begin execution of the new
thread. Here is the preceding program rewritten to extend Thread:Chapter 11:
Multithreaded Programming
// Create a second thread by extending Thread
class NewThread extends Thread 
class ExtendThread 
This program generates the same output as the preceding version. As you can see, the child
thread is created by instantiating an object of NewThread, which is derived from Thread.
Notice the call to super( ) inside NewThread. This invokes the following form of the
Thread constructor:
public Thread(String threadName)
Here, threadName specifies the name of the thread.
231232
Part I:
The Java Language
Choosing an Approach
At this point, you might be wondering why Java has two ways to create child threads, and
which approach is better. The answers to these questions turn on the same point. The Thread
class defines several methods that can be overridden by a derived class. Of these methods,
the only one that must be overridden is run( ). This is, of course, the same method required
when you implement Runnable. Many Java programmers feel that classes should be
extended only when they are being enhanced or modified in some way. So, if you will not
be overriding any of Thread’s other methods, it is probably best simply to implement
Runnable. This is up to you, of course. However, throughout the rest of this chapter, we
will create threads by using classes that implement Runnable.
Creating Multiple Threads
So far, you have been using only two threads: the main thread and one child thread. However,
your program can spawn as many threads as it needs. For example, the following program
creates three child threads:
// Create multiple threads.
class NewThread implements Runnable 
class MultiThreadDemo 
The output from this program is shown here:
New thread: Thread[One,5,main]
New thread: Thread[Two,5,main]
New thread: Thread[Three,5,main]
One: 5
Two: 5
Three: 5
One: 4
Two: 4
Three: 4
One: 3
Three: 3
Two: 3
One: 2
Three: 2
Two: 2
One: 1
Three: 1
Two: 1
One exiting.
Two exiting.
Three exiting.
Main thread exiting.
As you can see, once started, all three child threads share the CPU. Notice the call to
sleep(10000) in main( ). This causes the main thread to sleep for ten seconds and ensures
that it will finish last.
Using isAlive( ) and join( )
As mentioned, often you will want the main thread to finish last. In the preceding examples,
this is accomplished by calling sleep( ) within main( ), with a long enough delay to ensure
that all child threads terminate prior to the main thread. However, this is hardly a satisfactory
solution, and it also raises a larger question: How can one thread know when another thread
has ended? Fortunately, Thread provides a means by which you can answer this question.
233234
Part I:
The Java Language
Two ways exist to determine whether a thread has finished. First, you can call isAlive( )
on the thread. This method is defined by Thread, and its general form is shown here:
final boolean isAlive( )
The isAlive( ) method returns true if the thread upon which it is called is still running. It returns
false otherwise.
While isAlive( ) is occasionally useful, the method that you will more commonly use to
wait for a thread to finish is called join( ), shown here:
final void join( ) throws InterruptedException
This method waits until the thread on which it is called terminates. Its name comes from the
concept of the calling thread waiting until the specified thread joins it. Additional forms of
join( ) allow you to specify a maximum amount of time that you want to wait for the specified
thread to terminate.
Here is an improved version of the preceding example that uses join( ) to ensure that the
main thread is the last to stop. It also demonstrates the isAlive( ) method.
// Using join() to wait for threads to finish.
class NewThread implements Runnable 
class DemoJoin 
Sample output from this program is shown here. (Your output may vary based on processor
speed and task load.)
New thread: Thread[One,5,main]
New thread: Thread[Two,5,main]
New thread: Thread[Three,5,main]
Thread One is alive: true
Thread Two is alive: true
Thread Three is alive: true
Waiting for threads to finish.
One: 5
Two: 5
Three: 5
One: 4
Two: 4
Three: 4
One: 3
Two: 3
Three: 3
One: 2
Two: 2
Three: 2
235236
Part I:
The Java Language
One: 1
Two: 1
Three: 1
Two exiting.
Three exiting.
One exiting.
Thread One is alive: false
Thread Two is alive: false
Thread Three is alive: false
Main thread exiting.
As you can see, after the calls to join( ) return, the threads have stopped executing.
Thread Priorities
Thread priorities are used by the thread scheduler to decide when each thread should be
allowed to run. In theory, higher-priority threads get more CPU time than lower-priority
threads. In practice, the amount of CPU time that a thread gets often depends on several
factors besides its priority. (For example, how an operating system implements multitasking
can affect the relative availability of CPU time.) A higher-priority thread can also preempt a
lower-priority one. For instance, when a lower-priority thread is running and a higher-priority
thread resumes (from sleeping or waiting on I/O, for example), it will preempt the lower-
priority thread.
In theory, threads of equal priority should get equal access to the CPU. But you need to
be careful. Remember, Java is designed to work in a wide range of environments. Some of
those environments implement multitasking fundamentally differently than others. For safety,
threads that share the same priority should yield control once in a while. This ensures that
all threads have a chance to run under a nonpreemptive operating system. In practice, even
in nonpreemptive environments, most threads still get a chance to run, because most threads
inevitably encounter some blocking situation, such as waiting for I/O. When this happens,
the blocked thread is suspended and other threads can run. But, if you want smooth
multithreaded execution, you are better off not relying on this. Also, some types of tasks
are CPU-intensive. Such threads dominate the CPU. For these types of threads, you want
to yield control occasionally so that other threads can run.
To set a thread’s priority, use the setPriority( ) method, which is a member of Thread.
This is its general form:
final void setPriority(int level)
Here, level specifies the new priority setting for the calling thread. The value of level must be
within the range MIN_PRIORITY and MAX_PRIORITY. Currently, these values are 1 and
10, respectively. To return a thread to default priority, specify NORM_PRIORITY, which is
currently 5. These priorities are defined as static final variables within Thread.
You can obtain the current priority setting by calling the getPriority( ) method of Thread,
shown here:
final int getPriority( )Chapter 11:
Multithreaded Programming
Implementations of Java may have radically different behavior when it comes to scheduling.
The Windows XP/98/NT/2000 versions work, more or less, as you would expect. However,
other versions may work quite differently. Most of the inconsistencies arise when you have
threads that are relying on preemptive behavior, instead of cooperatively giving up CPU
time. The safest way to obtain predictable, cross-platform behavior with Java is to use threads
that voluntarily give up control of the CPU.
The following example demonstrates two threads at different priorities, which do not
run on a preemptive platform in the same way as they run on a nonpreemptive platform.
One thread is set two levels above the normal priority, as defined by Thread.NORM_
PRIORITY, and the other is set to two levels below it. The threads are started and allowed
to run for ten seconds. Each thread executes a loop, counting the number of iterations. After
ten seconds, the main thread stops both threads. The number of times that each thread made
it through the loop is then displayed.
// Demonstrate thread priorities.
class clicker implements Runnable 
class HiLoPri 
The output of this program, shown as follows when run under Windows, indicates that
the threads did context switch, even though neither voluntarily yielded the CPU nor blocked
for I/O. The higher-priority thread got the majority of the CPU time.
Low-priority thread: 4408112
High-priority thread: 589626904
Of course, the exact output produced by this program depends on the speed of your CPU
and the number of other tasks running in the system. When this same program is run under
a nonpreemptive system, different results will be obtained.
One other note about the preceding program. Notice that running is preceded by the
keyword volatile. Although volatile is examined more carefully in Chapter 13, it is used
here to ensure that the value of running is examined each time the following loop iterates:
while (running) 
Without the use of volatile, Java is free to optimize the loop in such a way that a local copy
of running is created. The use of volatile prevents this optimization, telling Java that running
may change in ways not directly apparent in the immediate code.
Synchronization
When two or more threads need access to a shared resource, they need some way to ensure
that the resource will be used by only one thread at a time. The process by which this is
achieved is called synchronization. As you will see, Java provides unique, language-level
support for it.
Key to synchronization is the concept of the monitor (also called a semaphore). A monitor
is an object that is used as a mutually exclusive lock, or mutex. Only one thread can own a
monitor at a given time. When a thread acquires a lock, it is said to have entered the monitor.
All other threads attempting to enter the locked monitor will be suspended until the first
thread exits the monitor. These other threads are said to be waiting for the monitor. A thread
that owns a monitor can reenter the same monitor if it so desires.Chapter 11:
Multithreaded Programming
If you have worked with synchronization when using other languages, such as C or C++,
you know that it can be a bit tricky to use. This is because these languages do not, themselves,
support synchronization. Instead, to synchronize threads, your programs need to utilize
operating system primitives. Fortunately, because Java implements synchronization through
language elements, most of the complexity associated with synchronization has been
eliminated.
You can synchronize your code in either of two ways. Both involve the use of the
synchronized keyword, and both are examined here.
Using Synchronized Methods
Synchronization is easy in Java, because all objects have their own implicit monitor associated
with them. To enter an object’s monitor, just call a method that has been modified with the
synchronized keyword. While a thread is inside a synchronized method, all other threads
that try to call it (or any other synchronized method) on the same instance have to wait. To
exit the monitor and relinquish control of the object to the next waiting thread, the owner of
the monitor simply returns from the synchronized method.
To understand the need for synchronization, let’s begin with a simple example that does
not use it—but should. The following program has three simple classes. The first one, Callme,
has a single method named call( ). The call( ) method takes a String parameter called msg.
This method tries to print the msg string inside of square brackets. The interesting thing
to notice is that after call( ) prints the opening bracket and the msg string, it calls Thread
.sleep(1000), which pauses the current thread for one second.
The constructor of the next class, Caller, takes a reference to an instance of the Callme
class and a String, which are stored in target and msg, respectively. The constructor also creates
a new thread that will call this object’s run( ) method. The thread is started immediately. The
run( ) method of Caller calls the call( ) method on the target instance of Callme, passing in
the msg string. Finally, the Synch class starts by creating a single instance of Callme, and
three instances of Caller, each with a unique message string. The same instance of Callme
is passed to each Caller.
// This program is not synchronized.
class Callme 
class Caller implements Runnable 
class Synch 
Here is the output produced by this program:
Hello[Synchronized[World]
]
]
As you can see, by calling sleep( ), the call( ) method allows execution to switch to another
thread. This results in the mixed-up output of the three message strings. In this program,
nothing exists to stop all three threads from calling the same method, on the same object, at
the same time. This is known as a race condition, because the three threads are racing each
other to complete the method. This example used sleep( ) to make the effects repeatable and
obvious. In most situations, a race condition is more subtle and less predictable, because
you can’t be sure when the context switch will occur. This can cause a program to run right
one time and wrong the next.
To fix the preceding program, you must serialize access to call( ). That is, you must restrict its
access to only one thread at a time. To do this, you simply need to precede call( )’s definition
with the keyword synchronized, as shown here:
class Callme {
synchronized void call(String msg) {
...Chapter 11:
Multithreaded Programming
This prevents other threads from entering call( ) while another thread is using it. After
synchronized has been added to call( ), the output of the program is as follows:
[Hello]
[Synchronized]
[World]
Any time that you have a method, or group of methods, that manipulates the internal
state of an object in a multithreaded situation, you should use the synchronized keyword
to guard the state from race conditions. Remember, once a thread enters any synchronized
method on an instance, no other thread can enter any other synchronized method on the same
instance. However, nonsynchronized methods on that instance will continue to be callable.
The synchronized Statement
While creating synchronized methods within classes that you create is an easy and effective
means of achieving synchronization, it will not work in all cases. To understand why, consider
the following. Imagine that you want to synchronize access to objects of a class that was not
designed for multithreaded access. That is, the class does not use synchronized methods.
Further, this class was not created by you, but by a third party, and you do not have access
to the source code. Thus, you can’t add synchronized to the appropriate methods within
the class. How can access to an object of this class be synchronized? Fortunately, the solution
to this problem is quite easy: You simply put calls to the methods defined by this class inside
a synchronized block.
This is the general form of the synchronized statement:
synchronized(object) 
Here, object is a reference to the object being synchronized. A synchronized block ensures
that a call to a method that is a member of object occurs only after the current thread has
successfully entered object’s monitor.
Here is an alternative version of the preceding example, using a synchronized block
within the run( ) method:
// This program uses a synchronized block.
class Callme 
class Caller implements Runnable 
class Synch1 
Here, the call( ) method is not modified by synchronized. Instead, the synchronized
statement is used inside Caller’s run( ) method. This causes the same correct output as the
preceding example, because each thread waits for the prior one to finish before proceeding.
Interthread Communication
The preceding examples unconditionally blocked other threads from asynchronous access
to certain methods. This use of the implicit monitors in Java objects is powerful, but you can
achieve a more subtle level of control through interprocess communication. As you will see,
this is especially easy in Java.
As discussed earlier, multithreading replaces event loop programming by dividing your
tasks into discrete, logical units. Threads also provide a secondary benefit: they do away
with polling. Polling is usually implemented by a loop that is used to check some condition
repeatedly. Once the condition is true, appropriate action is taken. This wastes CPU time.
For example, consider the classic queuing problem, where one thread is producing some
data and another is consuming it. To make the problem more interesting, suppose that the
producer has to wait until the consumer is finished before it generates more data. In a pollingChapter 11:
Multithreaded Programming
system, the consumer would waste many CPU cycles while it waited for the producer to
produce. Once the producer was finished, it would start polling, wasting more CPU cycles
waiting for the consumer to finish, and so on. Clearly, this situation is undesirable.
To avoid polling, Java includes an elegant interprocess communication mechanism via
the wait( ), notify( ), and notifyAll( ) methods. These methods are implemented as final
methods in Object, so all classes have them. All three methods can be called only from
within a synchronized context. Although conceptually advanced from a computer science
perspective, the rules for using these methods are actually quite simple:
• wait( ) tells the calling thread to give up the monitor and go to sleep until some
other thread enters the same monitor and calls notify( ).
• notify( ) wakes up a thread that called wait( ) on the same object.
• notifyAll( ) wakes up all the threads that called wait( ) on the same object. One of
the threads will be granted access.
These methods are declared within Object, as shown here:
final void wait( ) throws InterruptedException
final void notify( )
final void notifyAll( )
Additional forms of wait( ) exist that allow you to specify a period of time to wait.
Before working through an example that illustrates interthread communication, an
important point needs to be made. Although wait( ) normally waits until notify( ) or
notifyAll( ) is called, there is a possibility that in very rare cases the waiting thread could be
awakened due to a spurious wakeup. In this case, a waiting thread resumes without notify( )
or notifyAll( ) having been called. (In essence, the thread resumes for no apparent reason.)
Because of this remote possibility, Sun recommends that calls to wait( ) should take place
within a loop that checks the condition on which the thread is waiting. The following
example shows this technique.
Let’s now work through an example that uses wait( ) and notify( ). To begin, consider
the following sample program that incorrectly implements a simple form of the producer/
consumer problem. It consists of four classes: Q, the queue that you’re trying to synchronize;
Producer, the threaded object that is producing queue entries; Consumer, the threaded
object that is consuming queue entries; and PC, the tiny class that creates the single Q,
Producer, and Consumer.
// An incorrect implementation of a producer and consumer.
class Q 
243244
Part I:
The Java Language
class Producer implements Runnable 
class Consumer implements Runnable 
class PC 
Although the put( ) and get( ) methods on Q are synchronized, nothing stops the producer
from overrunning the consumer, nor will anything stop the consumer from consuming the
same queue value twice. Thus, you get the erroneous output shown here (the exact output
will vary with processor speed and task load):
Put:
Got:
Got:
Got:
Got:
1
1
1
1
1Chapter 11:
Got:
Put:
Put:
Put:
Put:
Put:
Put:
Got:
Multithreaded Programming
1
2
3
4
5
6
7
7
As you can see, after the producer put 1, the consumer started and got the same 1 five times
in a row. Then, the producer resumed and produced 2 through 7 without letting the consumer
have a chance to consume them.
The proper way to write this program in Java is to use wait( ) and notify( ) to signal in
both directions, as shown here:
// A correct implementation of a producer and consumer.
class Q 
class Producer implements Runnable 
class Consumer implements Runnable 
class PCFixed 
Inside get( ), wait( ) is called. This causes its execution to suspend until the Producer
notifies you that some data is ready. When this happens, execution inside get( ) resumes.
After the data has been obtained, get( ) calls notify( ). This tells Producer that it is okay to
put more data in the queue. Inside put( ), wait( ) suspends execution until the Consumer
has removed the item from the queue. When execution resumes, the next item of data is put
in the queue, and notify( ) is called. This tells the Consumer that it should now remove it.
Here is some output from this program, which shows the clean synchronous behavior:
Put:
Got:
Put:
Got:
Put:
1
1
2
2
3Chapter 11:
Got:
Put:
Got:
Put:
Got:
Multithreaded Programming
3
4
4
5
5
Deadlock
A special type of error that you need to avoid that relates specifically to multitasking is
deadlock, which occurs when two threads have a circular dependency on a pair of synchronized
objects. For example, suppose one thread enters the monitor on object X and another thread
enters the monitor on object Y. If the thread in X tries to call any synchronized method on Y,
it will block as expected. However, if the thread in Y, in turn, tries to call any synchronized
method on X, the thread waits forever, because to access X, it would have to release its own
lock on Y so that the first thread could complete. Deadlock is a difficult error to debug for
two reasons:
• In general, it occurs only rarely, when the two threads time-slice in just the right way.
• It may involve more than two threads and two synchronized objects. (That is, deadlock
can occur through a more convoluted sequence of events than just described.)
To understand deadlock fully, it is useful to see it in action. The next example creates two
classes, A and B, with methods foo( ) and bar( ), respectively, which pause briefly before
trying to call a method in the other class. The main class, named Deadlock, creates an A
and a B instance, and then starts a second thread to set up the deadlock condition. The
foo( ) and bar( ) methods use sleep( ) as a way to force the deadlock condition to occur.
// An example of deadlock.
class A 
class B 
class Deadlock implements Runnable 
When you run this program, you will see the output shown here:
MainThread entered A.foo
RacingThread entered B.bar
MainThread trying to call B.last()
RacingThread trying to call A.last()
Because the program has deadlocked, you need to press CTRL-C to end the program. You
can see a full thread and monitor cache dump by pressing CTRL-BREAK on a PC . You will see
that RacingThread owns the monitor on b, while it is waiting for the monitor on a. At theChapter 11:
Multithreaded Programming
same time, MainThread owns a and is waiting to get b. This program will never complete.
As this example illustrates, if your multithreaded program locks up occasionally, deadlock
is one of the first conditions that you should check for.
Suspending, Resuming, and Stopping Threads
Sometimes, suspending execution of a thread is useful. For example, a separate thread can
be used to display the time of day. If the user doesn’t want a clock, then its thread can be
suspended. Whatever the case, suspending a thread is a simple matter. Once suspended,
restarting the thread is also a simple matter.
The mechanisms to suspend, stop, and resume threads differ between early versions of
Java, such as Java 1.0, and modern versions, beginning with Java 2. Although you should
use the modern approach for all new code, you still need to understand how these operations
were accomplished for earlier Java environments. For example, you may need to update or
maintain older, legacy code. You also need to understand why a change was made. For these
reasons, the next section describes the original way that the execution of a thread was controlled,
followed by a section that describes the modern approach.
Suspending, Resuming, and Stopping Threads Using Java 1.1 and Earlier
Prior to Java 2, a program used suspend( ) and resume( ), which are methods defined by
Thread, to pause and restart the execution of a thread. They have the form shown below:
final void suspend( )
final void resume( )
The following program demonstrates these methods:
// Using suspend() and resume().
class NewThread implements Runnable 
249250
Part I:
The Java Language
class SuspendResume 
Sample output from this program is shown here. (Your output may differ based on processor
speed and task load.)
New thread: Thread[One,5,main]
One: 15
New thread: Thread[Two,5,main]
Two: 15
One: 14
Two: 14
One: 13
Two: 13
One: 12
Two: 12
One: 11
Two: 11
Suspending thread One
Two: 10
Two: 9
Two: 8Chapter 11:
Multithreaded Programming
Two: 7
Two: 6
Resuming thread One
Suspending thread Two
One: 10
One: 9
One: 8
One: 7
One: 6
Resuming thread Two
Waiting for threads to finish.
Two: 5
One: 5
Two: 4
One: 4
Two: 3
One: 3
Two: 2
One: 2
Two: 1
One: 1
Two exiting.
One exiting.
Main thread exiting.
The Thread class also defines a method called stop( ) that stops a thread. Its signature is
shown here:
final void stop( )
Once a thread has been stopped, it cannot be restarted using resume( ).
The Modern Way of Suspending, Resuming, and Stopping Threads
While the suspend( ), resume( ), and stop( ) methods defined by Thread seem to be a perfectly
reasonable and convenient approach to managing the execution of threads, they must not
be used for new Java programs. Here’s why. The suspend( ) method of the Thread class was
deprecated by Java 2 several years ago. This was done because suspend( ) can sometimes
cause serious system failures. Assume that a thread has obtained locks on critical data
structures. If that thread is suspended at that point, those locks are not relinquished. Other
threads that may be waiting for those resources can be deadlocked.
The resume( ) method is also deprecated. It does not cause problems, but cannot be
used without the suspend( ) method as its counterpart.
The stop( ) method of the Thread class, too, was deprecated by Java 2. This was done
because this method can sometimes cause serious system failures. Assume that a thread is
writing to a critically important data structure and has completed only part of its changes.
If that thread is stopped at that point, that data structure might be left in a corrupted state.
251252
Part I:
The Java Language
Because you can’t now use the suspend( ), resume( ), or stop( ) methods to control a
thread, you might be thinking that no way exists to pause, restart, or terminate a thread.
But, fortunately, this is not true. Instead, a thread must be designed so that the run( ) method
periodically checks to determine whether that thread should suspend, resume, or stop its
own execution. Typically, this is accomplished by establishing a flag variable that indicates
the execution state of the thread. As long as this flag is set to “running,” the run( ) method
must continue to let the thread execute. If this variable is set to “suspend,” the thread must
pause. If it is set to “stop,” the thread must terminate. Of course, a variety of ways exist in
which to write such code, but the central theme will be the same for all programs.
The following example illustrates how the wait( ) and notify( ) methods that are inherited
from Object can be used to control the execution of a thread. This example is similar to the
program in the previous section. However, the deprecated method calls have been removed.
Let us consider the operation of this program.
The NewThread class contains a boolean instance variable named suspendFlag, which
is used to control the execution of the thread. It is initialized to false by the constructor. The
run( ) method contains a synchronized statement block that checks suspendFlag. If that
variable is true, the wait( ) method is invoked to suspend the execution of the thread. The
mysuspend( ) method sets suspendFlag to true. The myresume( ) method sets suspendFlag
to false and invokes notify( ) to wake up the thread. Finally, the main( ) method has been
modified to invoke the mysuspend( ) and myresume( ) methods.
// Suspending and resuming a thread the modern way.
class NewThread implements Runnable 
class SuspendResume 
The output from this program is identical to that shown in the previous section. Later
in this book, you will see more examples that use the modern mechanism of thread control.
Although this mechanism isn’t as “clean” as the old way, nevertheless, it is the way required
to ensure that run-time errors don’t occur. It is the approach that must be used for all new code.
253254
Part I:
The Java Language
Using Multithreading
The key to utilizing Java’s multithreading features effectively is to think concurrently rather
than serially. For example, when you have two subsystems within a program that can execute
concurrently, make them individual threads. With the careful use of multithreading, you can
create very efficient programs. A word of caution is in order, however: If you create too many
threads, you can actually degrade the performance of your program rather than enhance it.
Remember, some overhead is associated with context switching. If you create too many threads,
more CPU time will be spent changing contexts than executing your program!12
Enumerations, Autoboxing,
and Annotations (Metadata)
T
his chapter examines three recent additions to the Java language: enumerations,
autoboxing, and annotations (also referred to as metadata). Each expands the power
of the language by offering a streamlined approach to handling common programming
tasks. This chapter also discusses Java’s type wrappers and introduces reflection.
Enumerations
Versions prior to JDK 5 lacked one feature that many programmers felt was needed:
enumerations. In its simplest form, an enumeration is a list of named constants. Although
Java offered other features that provide somewhat similar functionality, such as final
variables, many programmers still missed the conceptual purity of enumerations—especially
because enumerations are supported by most other commonly used languages. Beginning
with JDK 5, enumerations were added to the Java language, and they are now available to
the Java programmer.
In their simplest form, Java enumerations appear similar to enumerations in other
languages. However, this similarity is only skin deep. In languages such as C++, enumerations
are simply lists of named integer constants. In Java, an enumeration defines a class type. By
making enumerations into classes, the concept of the enumeration is greatly expanded. For
example, in Java, an enumeration can have constructors, methods, and instance variables.
Therefore, although enumerations were several years in the making, Java’s rich
implementation made them well worth the wait.
Enumeration Fundamentals
An enumeration is created using the enum keyword. For example, here is a simple
enumeration that lists various apple varieties:
// An enumeration of apple varieties.
enum Apple 
255256
Part I:
The Java Language
The identifiers Jonathan, GoldenDel, and so on, are called enumeration constants. Each is
implicitly declared as a public, static final member of Apple. Furthermore, their type is the
type of the enumeration in which they are declared, which is Apple in this case. Thus,
in the language of Java, these constants are called self-typed, in which “self” refers to the
enclosing enumeration.
Once you have defined an enumeration, you can create a variable of that type. However,
even though enumerations define a class type, you do not instantiate an enum using new.
Instead, you declare and use an enumeration variable in much the same way as you do one
of the primitive types. For example, this declares ap as a variable of enumeration type Apple:
Apple ap;
Because ap is of type Apple, the only values that it can be assigned (or can contain) are those
defined by the enumeration. For example, this assigns ap the value RedDel:
ap = Apple.RedDel;
Notice that the symbol RedDel is preceded by Apple.
Two enumeration constants can be compared for equality by using the = = relational
operator. For example, this statement compares the value in ap with the GoldenDel constant:
if(ap == Apple.GoldenDel) // ...
An enumeration value can also be used to control a switch statement. Of course, all
of the case statements must use constants from the same enum as that used by the switch
expression. For example, this switch is perfectly valid:
// Use an enum to control a switch statement.
switch(ap) {
case Jonathan:
// ...
case Winesap:
// ...
Notice that in the case statements, the names of the enumeration constants are used without
being qualified by their enumeration type name. That is, Winesap, not Apple.Winesap, is used.
This is because the type of the enumeration in the switch expression has already implicitly
specified the enum type of the case constants. There is no need to qualify the constants in
the case statements with their enum type name. In fact, attempting to do so will cause a
compilation error.
When an enumeration constant is displayed, such as in a println( ) statement, its name
is output. For example, given this statement:
System.out.println(Apple.Winesap);
the name Winesap is displayed.
The following program puts together all of the pieces and demonstrates the Apple
enumeration:Chapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
// An enumeration of apple varieties.
enum Apple 
class EnumDemo 
The output from the program is shown here:
Value of ap: RedDel
ap contains GoldenDel.
Golden Delicious is yellow.
257258
Part I:
The Java Language
The values( ) and valueOf( ) Methods
All enumerations automatically contain two predefined methods: values( ) and valueOf( ).
Their general forms are shown here:
public static enum-type[ ] values( )
public static enum-type valueOf(String str)
The values( ) method returns an array that contains a list of the enumeration constants. The
valueOf( ) method returns the enumeration constant whose value corresponds to the string
passed in str. In both cases, enum-type is the type of the enumeration. For example, in the case
of the Apple enumeration shown earlier, the return type of Apple.valueOf(“Winesap”) is
Winesap.
The following program demonstrates the values( ) and valueOf( ) methods:
// Use the built-in enumeration methods.
// An enumeration of apple varieties.
enum Apple 
class EnumDemo2 
The output from the program is shown here:
Here are all Apple constants:
Jonathan
GoldenDel
RedDel
Winesap
Cortland
ap contains WinesapChapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
Notice that this program uses a for-each style for loop to cycle through the array of
constants obtained by calling values( ). For the sake of illustration, the variable allapples
was created and assigned a reference to the enumeration array. However, this step is not
necessary because the for could have been written as shown here, eliminating the need for
the allapples variable:
for(Apple a : Apple.values())
System.out.println(a);
Now, notice how the value corresponding to the name Winesap was obtained by calling
valueOf( ).
ap = Apple.valueOf("Winesap");
As explained, valueOf( ) returns the enumeration value associated with the name of the
constant represented as a string.
N OTE C/C++ programmers will notice that Java makes it much easier to translate between the
human-readable form of an enumeration constant and its binary value than do these other
languages. This is a significant advantage to Java’s approach to enumerations.
Java Enumerations Are Class Types
As explained, a Java enumeration is a class type. Although you don’t instantiate an enum
using new, it otherwise has much the same capabilities as other classes. The fact that enum
defines a class gives powers to the Java enumeration that enumerations in other
languages simply do not have. For example, you can give them constructors, add instance
variables and methods, and even implement interfaces.
It is important to understand that each enumeration constant is an object of its enumeration
type. Thus, when you define a constructor for an enum, the constructor is called when each
enumeration constant is created. Also, each enumeration constant has its own copy of any
instance variables defined by the enumeration. For example, consider the following version
of Apple:
// Use an enum constructor, instance variable, and method.
enum Apple 
class EnumDemo3 
The output is shown here:
Winesap costs 15 cents.
All apple prices:
Jonathan costs 10 cents.
GoldenDel costs 9 cents.
RedDel costs 12 cents.
Winesap costs 15 cents.
Cortland costs 8 cents.
This version of Apple adds three things. The first is the instance variable price, which is
used to hold the price of each variety of apple. The second is the Apple constructor, which
is passed the price of an apple. The third is the method getPrice( ), which returns the value
of price.
When the variable ap is declared in main( ), the constructor for Apple is called once for
each constant that is specified. Notice how the arguments to the constructor are specified,
by putting them inside parentheses after each constant, as shown here:
Jonathan(10), GoldenDel(9), RedDel(12), Winesap(15), Cortland(8);
These values are passed to the p parameter of Apple( ), which then assigns this value to price.
Again, the constructor is called once for each constant.
Because each enumeration constant has its own copy of price, you can obtain the price of
a specified type of apple by calling getPrice( ). For example, in main( ) the price of a Winesap
is obtained by the following call:
Apple.Winesap.getPrice()
The prices of all varieties are obtained by cycling through the enumeration using a for loop.
Because there is a copy of price for each enumeration constant, the value associated with
one constant is separate and distinct from the value associated with another constant. This
is a powerful concept, which is only available when enumerations are implemented as classes,
as Java does.
Although the preceding example contains only one constructor, an enum can offer two
or more overloaded forms, just as can any other class. For example, this version of Apple
provides a default constructor that initializes the price to 1 – , to indicate that no price data
is available:Chapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
// Use an enum constructor.
enum Apple 
Notice that in this version, RedDel is not given an argument. This means that the default
constructor is called, and RedDel’s price variable is given the value –1.
Here are two restrictions that apply to enumerations. First, an enumeration can’t inherit
another class. Second, an enum cannot be a superclass. This means that an enum can’t be
extended. Otherwise, enum acts much like any other class type. The key is to remember that
each of the enumeration constants is an object of the class in which it is defined.
Enumerations Inherit Enum
Although you can’t inherit a superclass when declaring an enum, all enumerations
automatically inherit one: java.lang.Enum. This class defines several methods that are
available for use by all enumerations. The Enum class is described in detail in Part II,
but three of its methods warrant a discussion at this time.
You can obtain a value that indicates an enumeration constant’s position in the list of
constants. This is called its ordinal value, and it is retrieved by calling the ordinal( ) method,
shown here:
final int ordinal( )
It returns the ordinal value of the invoking constant. Ordinal values begin at zero. Thus, in
the Apple enumeration, Jonathan has an ordinal value of zero, GoldenDel has an ordinal
value of 1, RedDel has an ordinal value of 2, and so on.
You can compare the ordinal value of two constants of the same enumeration by using
the compareTo( ) method. It has this general form:
final int compareTo(enum-type e)
Here, enum-type is the type of the enumeration, and e is the constant being compared to
the invoking constant. Remember, both the invoking constant and e must be of the same
enumeration. If the invoking constant has an ordinal value less than e’s, then compareTo( )
returns a negative value. If the two ordinal values are the same, then zero is returned. If the
invoking constant has an ordinal value greater than e’s, then a positive value is returned.
You can compare for equality an enumeration constant with any other object by using
equals( ), which overrides the equals( ) method defined by Object. Although equals( ) can
compare an enumeration constant to any other object, those two objects will only be equal if
261262
Part I:
The Java Language
they both refer to the same constant, within the same enumeration. Simply having ordinal
values in common will not cause equals( ) to return true if the two constants are from
different enumerations.
Remember, you can compare two enumeration references for equality by using = =.
The following program demonstrates the ordinal( ), compareTo( ), and equals( ) methods:
// Demonstrate ordinal(), compareTo(), and equals().
// An enumeration of apple varieties.
enum Apple 
class EnumDemo4 Chapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
The output from the program is shown here:
Here are all apple constants and their ordinal values:
Jonathan 0
GoldenDel 1
RedDel 2
Winesap 3
Cortland 4
GoldenDel comes before RedDel
RedDel equals RedDel
RedDel equals RedDel
RedDel == RedDel
Another Enumeration Example
Before moving on, we will look at a different example that uses an enum. In Chapter 9, an
automated “decision maker” program was created. In that version, variables called NO,
YES, MAYBE, LATER, SOON, and NEVER were declared within an interface and used to
represent the possible answers. While there is nothing technically wrong with that approach,
the enumeration is a better choice. Here is an improved version of that program that uses an
enum called Answers to define the answers. You should compare this version to the original
in Chapter 9.
//
//
//
//
An improved version of the "Decision Maker"
program from Chapter 9. This version uses an
enum, rather than interface variables, to
represent the answers.
import java.util.Random;
// An enumeration of the possible answers.
enum Answers 
class Question 
class AskMe 
Type Wrappers
As you know, Java uses primitive types (also called simple types), such as int or double, to
hold the basic data types supported by the language. Primitive types, rather than objects,
are used for these quantities for the sake of performance. Using objects for these values would
add an unacceptable overhead to even the simplest of calculations. Thus, the primitive types
are not part of the object hierarchy, and they do not inherit Object.
Despite the performance benefit offered by the primitive types, there are times when
you will need an object representation. For example, you can’t pass a primitive type by
reference to a method. Also, many of the standard data structures implemented by Java
operate on objects, which means that you can’t use these data structures to store primitive
types. To handle these (and other) situations, Java provides type wrappers, which are classes
that encapsulate a primitive type within an object. The type wrapper classes are describedChapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
in detail in Part II, but they are introduced here because they relate directly to Java’s
autoboxing feature.
The type wrappers are Double, Float, Long, Integer, Short, Byte, Character, and Boolean.
These classes offer a wide array of methods that allow you to fully integrate the primitive
types into Java’s object hierarchy. Each is briefly examined next.
Character
Character is a wrapper around a char. The constructor for Character is
Character(char ch)
Here, ch specifies the character that will be wrapped by the Character object being created.
To obtain the char value contained in a Character object, call charValue( ), shown here:
char charValue( )
It returns the encapsulated character.
Boolean
Boolean is a wrapper around boolean values. It defines these constructors:
Boolean(boolean boolValue)
Boolean(String boolString)
In the first version, boolValue must be either true or false. In the second version, if boolString
contains the string “true” (in uppercase or lowercase), then the new Boolean object will be
true. Otherwise, it will be false.
To obtain a boolean value from a Boolean object, use booleanValue( ), shown here:
boolean booleanValue( )
It returns the boolean equivalent of the invoking object.
The Numeric Type Wrappers
By far, the most commonly used type wrappers are those that represent numeric values.
These are Byte, Short, Integer, Long, Float, and Double. All of the numeric type wrappers
inherit the abstract class Number. Number declares methods that return the value of an
object in each of the different number formats. These methods are shown here:
byte byteValue( )
double doubleValue( )
float floatValue( )
int intValue( )
long longValue( )
short shortValue( )
For example, doubleValue( ) returns the value of an object as a double, floatValue( )
returns the value as a float, and so on. These methods are implemented by each of the
numeric type wrappers.
265266
Part I:
The Java Language
All of the numeric type wrappers define constructors that allow an object to be constructed
from a given value, or a string representation of that value. For example, here are the
constructors defined for Integer:
Integer(int num)
Integer(String str)
If str does not contain a valid numeric value, then a NumberFormatException is thrown.
All of the type wrappers override toString( ). It returns the human-readable form of the
value contained within the wrapper. This allows you to output the value by passing a type
wrapper object to println( ), for example, without having to convert it into its primitive type.
The following program demonstrates how to use a numeric type wrapper to
encapsulate a value and then extract that value.
// Demonstrate a type wrapper.
class Wrap 
This program wraps the integer value 100 inside an Integer object called iOb. The program
then obtains this value by calling intValue( ) and stores the result in i.
The process of encapsulating a value within an object is called boxing. Thus, in the program,
this line boxes the value 100 into an Integer:
Integer iOb = new Integer(100);
The process of extracting a value from a type wrapper is called unboxing. For example, the
program unboxes the value in iOb with this statement:
int i = iOb.intValue();
The same general procedure used by the preceding program to box and unbox values has
been employed since the original version of Java. However, with the release of JDK 5, Java
fundamentally improved on this through the addition of autoboxing, described next.
Autoboxing
Beginning with JDK 5, Java added two important features: autoboxing and auto-unboxing.
Autoboxing is the process by which a primitive type is automatically encapsulated (boxed)
into its equivalent type wrapper whenever an object of that type is needed. There is no need
to explicitly construct an object. Auto-unboxing is the process by which the value of a boxed
object is automatically extracted (unboxed) from a type wrapper when its value is needed.
There is no need to call a method such as intValue( ) or doubleValue( ).Chapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
The addition of autoboxing and auto-unboxing greatly streamlines the coding of several
algorithms, removing the tedium of manually boxing and unboxing values. It also helps
prevent errors. Moreover, it is very important to generics, which operates only on objects.
Finally, autoboxing makes working with the Collections Framework (described in Part II)
much easier.
With autoboxing it is no longer necessary to manually construct an object in order to
wrap a primitive type. You need only assign that value to a type-wrapper reference. Java
automatically constructs the object for you. For example, here is the modern way to construct
an Integer object that has the value 100:
Integer iOb = 100; // autobox an int
Notice that no object is explicitly created through the use of new. Java handles this for you,
automatically.
To unbox an object, simply assign that object reference to a primitive-type variable.
For example, to unbox iOb, you can use this line:
int i = iOb; // auto-unbox
Java handles the details for you.
Here is the preceding program rewritten to use autoboxing/unboxing:
// Demonstrate autoboxing/unboxing.
class AutoBox 
Autoboxing and Methods
In addition to the simple case of assignments, autoboxing automatically occurs whenever
a primitive type must be converted into an object; auto-unboxing takes place whenever an
object must be converted into a primitive type. Thus, autoboxing/unboxing might occur when
an argument is passed to a method, or when a value is returned by a method. For example,
consider this example:
// Autoboxing/unboxing takes place with
// method parameters and return values.
class AutoBox2 
This program displays the following result:
100
In the program, notice that m( ) specifies an Integer parameter and returns an int result.
Inside main( ), m( ) is passed the value 100. Because m( ) is expecting an Integer, this value
is automatically boxed. Then, m( ) returns the int equivalent of its argument. This causes v
to be auto-unboxed. Next, this int value is assigned to iOb in main( ), which causes the int
return value to be autoboxed.
Autoboxing/Unboxing Occurs in Expressions
In general, autoboxing and unboxing take place whenever a conversion into an object or from
an object is required. This applies to expressions. Within an expression, a numeric object is
automatically unboxed. The outcome of the expression is reboxed, if necessary. For example,
consider the following program:
// Autoboxing/unboxing occurs inside expressions.
class AutoBox3 
The output is shown here:
Original value of iOb: 100
After ++iOb: 101
iOb2 after expression: 134
i after expression: 134
In the program, pay special attention to this line:
++iOb;
This causes the value in iOb to be incremented. It works like this: iOb is unboxed, the
value is incremented, and the result is reboxed.
Auto-unboxing also allows you to mix different types of numeric objects in an expression.
Once the values are unboxed, the standard type promotions and conversions are applied. For
example, the following program is perfectly valid:
class AutoBox4 
The output is shown here:
dOb after expression: 198.6
As you can see, both the Double object dOb and the Integer object iOb participated
in the addition, and the result was reboxed and stored in dOb.
Because of auto-unboxing, you can use integer numeric objects to control a switch
statement. For example, consider this fragment:
Integer iOb = 2;
switch(iOb) 
When the switch expression is evaluated, iOb is unboxed and its int value is obtained.
As the examples in the program show, because of autoboxing/unboxing, using numeric
objects in an expression is both intuitive and easy. In the past, such code would have involved
casts and calls to methods such as intValue( ).
Autoboxing/Unboxing Boolean and Character Values
As described earlier, Java also supplies wrappers for boolean and char. These are Boolean
and Character. Autoboxing/unboxing applies to these wrappers, too. For example, consider
the following program:
// Autoboxing/unboxing a Boolean and Character.
class AutoBox5 
The output is shown here:
b is true
ch2 is x
The most important thing to notice about this program is the auto-unboxing of b inside
the if conditional expression. As you should recall, the conditional expression that controls
an if must evaluate to type boolean. Because of auto-unboxing, the boolean value contained
within b is automatically unboxed when the conditional expression is evaluated. Thus, with
the advent of autoboxing/unboxing, a Boolean object can be used to control an if statement.
Because of auto-unboxing, a Boolean object can now also be used to control any of Java’s
loop statements. When a Boolean is used as the conditional expression of a while, for, or
do/while, it is automatically unboxed into its boolean equivalent. For example, this is now
perfectly valid code:
Boolean b;
// ...
while(b) { // ...Chapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
Autoboxing/Unboxing Helps Prevent Errors
In addition to the convenience that it offers, autoboxing/unboxing can also help prevent
errors. For example, consider the following program:
// An error produced by manual unboxing.
class UnboxingError 
This program displays not the expected value of 1000, but 2 – 4! The reason is that the value
inside iOb is manually unboxed by calling byteValue( ), which causes the truncation of the
value stored in iOb, which is 1,000. This results in the garbage value of 2 – 4 being assigned
to i. Auto-unboxing prevents this type of error because the value in iOb will always auto-
unbox into a value compatible with int.
In general, because autoboxing always creates the proper object, and auto-unboxing
always produces the proper value, there is no way for the process to produce the wrong
type of object or value. In the rare instances where you want a type different than that
produced by the automated process, you can still manually box and unbox values. Of
course, the benefits of autoboxing/unboxing are lost. In general, new code should employ
autoboxing/unboxing. It is the way that modern Java code will be written.
A Word of Warning
Now that Java includes autoboxing and auto-unboxing, some might be tempted to use objects
such as Integer or Double exclusively, abandoning primitives altogether. For example, with
autoboxing/unboxing it is possible to write code like this:
// A bad use of autoboxing/unboxing!
Double a, b, c;
a = 10.0;
b = 4.0;
c = Math.sqrt(a*a + b*b);
System.out.println("Hypotenuse is " + c);
In this example, objects of type Double hold values that are used to calculate the hypotenuse
of a right triangle. Although this code is technically correct and does, in fact, work properly,
it is a very bad use of autoboxing/unboxing. It is far less efficient than the equivalent code
written using the primitive type double. The reason is that each autobox and auto-unbox
adds overhead that is not present if the primitive type is used.
271272
Part I:
The Java Language
In general, you should restrict your use of the type wrappers to only those cases in which
an object representation of a primitive type is required. Autoboxing/unboxing was not added
to Java as a “back door” way of eliminating the primitive types.
Annotations (Metadata)
Beginning with JDK 5, a new facility was added to Java that enables you to embed
supplemental information into a source file. This information, called an annotation, does not
change the actions of a program. Thus, an annotation leaves the semantics of a program
unchanged. However, this information can be used by various tools during both development
and deployment. For example, an annotation might be processed by a source-code generator.
The term metadata is also used to refer to this feature, but the term annotation is the most
descriptive and more commonly used.
Annotation Basics
An annotation is created through a mechanism based on the interface. Let’s begin with an
example. Here is the declaration for an annotation called MyAnno:
// A simple annotation type.
@interface MyAnno 
First, notice the @ that precedes the keyword interface. This tells the compiler that
an annotation type is being declared. Next, notice the two members str( ) and val( ). All
annotations consist solely of method declarations. However, you don’t provide bodies for
these methods. Instead, Java implements these methods. Moreover, the methods act much
like fields, as you will see.
An annotation cannot include an extends clause. However, all annotation types
automatically extend the Annotation interface. Thus, Annotation is a super-interface of all
annotations. It is declared within the java.lang.annotation package. It overrides hashCode( ),
equals( ), and toString( ), which are defined by Object. It also specifies annotationType( ),
which returns a Class object that represents the invoking annotation.
Once you have declared an annotation, you can use it to annotate a declaration. Any
type of declaration can have an annotation associated with it. For example, classes, methods,
fields, parameters, and enum constants can be annotated. Even an annotation can be annotated.
In all cases, the annotation precedes the rest of the declaration.
When you apply an annotation, you give values to its members. For example, here is an
example of MyAnno being applied to a method:
// Annotate a method.
@MyAnno(str = "Annotation Example", val = 100)
public static void myMeth() { // ...
This annotation is linked with the method myMeth( ). Look closely at the annotation syntax.
The name of the annotation, preceded by an @, is followed by a parenthesized list of member
initializations. To give a member a value, that member’s name is assigned a value. Therefore,
in the example, the string “Annotation Example” is assigned to the str member of MyAnno.Chapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
Notice that no parentheses follow str in this assignment. When an annotation member is
given a value, only its name is used. Thus, annotation members look like fields in this context.
Specifying a Retention Policy
Before exploring annotations further, it is necessary to discuss annotation retention policies.
A retention policy determines at what point an annotation is discarded. Java defines three
such policies, which are encapsulated within the java.lang.annotation.RetentionPolicy
enumeration. They are SOURCE, CLASS, and RUNTIME.
An annotation with a retention policy of SOURCE is retained only in the source file
and is discarded during compilation.
An annotation with a retention policy of CLASS is stored in the .class file during
compilation. However, it is not available through the JVM during run time.
An annotation with a retention policy of RUNTIME is stored in the .class file during
compilation and is available through the JVM during run time. Thus, RUNTIME retention
offers the greatest annotation persistence.
A retention policy is specified for an annotation by using one of Java’s built-in annotations:
@Retention. Its general form is shown here:
@Retention(retention-policy)
Here, retention-policy must be one of the previously discussed enumeration constants. If no
retention policy is specified for an annotation, then the default policy of CLASS is used.
The following version of MyAnno uses @Retention to specify the RUNTIME retention
policy. Thus, MyAnno will be available to the JVM during program execution.
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno 
Obtaining Annotations at Run Time by Use of Reflection
Although annotations are designed mostly for use by other development or deployment tools,
if they specify a retention policy of RUNTIME, then they can be queried at run time by any
Java program through the use of reflection. Reflection is the feature that enables information
about a class to be obtained at run time. The reflection API is contained in the java.lang.reflect
package. There are a number of ways to use reflection, and we won’t examine them all here.
We will, however, walk through a few examples that apply to annotations.
The first step to using reflection is to obtain a Class object that represents the class
whose annotations you want to obtain. Class is one of Java’s built-in classes and is defined
in java.lang. It is described in detail in Part II. There are various ways to obtain a Class
object. One of the easiest is to call getClass( ), which is a method defined by Object. Its
general form is shown here:
final Class getClass( )
It returns the Class object that represents the invoking object. (getClass( ) and several other
reflection-related methods make use of the generics feature. However, because generics are not
discussed until Chapter 14, these methods are shown and used here in their raw form. As a result,
you will see a warning message when you compile the following programs. In Chapter 14, you
will learn about generics in detail.)
273274
Part I:
The Java Language
After you have obtained a Class object, you can use its methods to obtain information
about the various items declared by the class, including its annotations. If you want to obtain
the annotations associated with a specific item declared within a class, you must first obtain an
object that represents that item. For example, Class supplies (among others) the getMethod( ),
getField( ), and getConstructor( ) methods, which obtain information about a method, field,
and constructor, respectively. These methods return objects of type Method, Field, and
Constructor.
To understand the process, let’s work through an example that obtains the annotations
associated with a method. To do this, you first obtain a Class object that represents the class, and
then call getMethod( ) on that Class object, specifying the name of the method. getMethod( )
has this general form:
Method getMethod(String methName, Class ... paramTypes)
The name of the method is passed in methName. If the method has arguments, then Class
objects representing those types must also be specified by paramTypes. Notice that paramTypes
is a varargs parameter. This means that you can specify as many parameter types as needed,
including zero. getMethod( ) returns a Method object that represents the method. If the method
can’t be found, NoSuchMethodException is thrown.
From a Class, Method, Field, or Constructor object, you can obtain a specific annotation
associated with that object by calling getAnnotation( ). Its general form is shown here:
Annotation getAnnotation(Class annoType)
Here, annoType is a Class object that represents the annotation in which you are interested.
The method returns a reference to the annotation. Using this reference, you can obtain the
values associated with the annotation’s members. The method returns null if the annotation
is not found, which will be the case if the annotation does not have RUNTIME retention.
Here is a program that assembles all of the pieces shown earlier and uses reflection to
display the annotation associated with a method.
import java.lang.annotation.*;
import java.lang.reflect.*;
// An annotation type declaration.
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno 
class Meta 
The output from the program is shown here:
Annotation Example 100
This program uses reflection as described to obtain and display the values of str and val
in the MyAnno annotation associated with myMeth( ) in the Meta class. There are two things
to pay special attention to. First, in this line
MyAnno anno = m.getAnnotation(MyAnno.class);
notice the expression MyAnno.class. This expression evaluates to a Class object of type
MyAnno, the annotation. This construct is called a class literal. You can use this type of
expression whenever a Class object of a known class is needed. For example, this statement
could have been used to obtain the Class object for Meta:
Class c = Meta.class;
Of course, this approach only works when you know the class name of an object in advance,
which might not always be the case. In general, you can obtain a class literal for classes,
interfaces, primitive types, and arrays.
The second point of interest is the way the values associated with str and val are obtained
when they are output by the following line:
System.out.println(anno.str() + " " + anno.val());
Notice that they are invoked using the method-call syntax. This same approach is used
whenever the value of an annotation member is required.
275276
Part I:
The Java Language
A Second Reflection Example
In the preceding example, myMeth( ) has no parameters. Thus, when getMethod( ) was
called, only the name myMeth was passed. However, to obtain a method that has parameters,
you must specify class objects representing the types of those parameters as arguments to
getMethod( ). For example, here is a slightly different version of the preceding program:
import java.lang.annotation.*;
import java.lang.reflect.*;
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno 
class Meta 
The output from this version is shown here:
Two Parameters 19
In this version, myMeth( ) takes a String and an int parameter. To obtain information
about this method, getMethod( ) must be called as shown here:
Method m = c.getMethod("myMeth", String.class, int.class);
Here, the Class objects representing String and int are passed as additional arguments.Chapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
Obtaining All Annotations
You can obtain all annotations that have RUNTIME retention that are associated with an
item by calling getAnnotations( ) on that item. It has this general form:
Annotation[ ] getAnnotations( )
It returns an array of the annotations. getAnnotations( ) can be called on objects of type
Class, Method, Constructor, and Field.
Here is another reflection example that shows how to obtain all annotations associated
with a class and with a method. It declares two annotations. It then uses those annotations
to annotate a class and a method.
// Show all annotations for a class and a method.
import java.lang.annotation.*;
import java.lang.reflect.*;
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno 
@Retention(RetentionPolicy.RUNTIME)
@interface What 
@What(description = "An annotation test class")
@MyAnno(str = "Meta2", val = 99)
class Meta2 
The output is shown here:
All annotations for Meta2:
@What(description=An annotation test class)
@MyAnno(str=Meta2, val=99)
All annotations for myMeth:
@What(description=An annotation test method)
@MyAnno(str=Testing, val=100)
The program uses getAnnotations( ) to obtain an array of all annotations associated
with the Meta2 class and with the myMeth( ) method. As explained, getAnnotations( )
returns an array of Annotation objects. Recall that Annotation is a super-interface of all
annotation interfaces and that it overrides toString( ) in Object. Thus, when a reference to
an Annotation is output, its toString( ) method is called to generate a string that describes
the annotation, as the preceding output shows.
The AnnotatedElement Interface
The methods getAnnotation( ) and getAnnotations( ) used by the preceding examples are
defined by the AnnotatedElement interface, which is defined in java.lang.reflect. This
interface supports reflection for annotations and is implemented by the classes Method, Field,
Constructor, Class, and Package.
In addition to getAnnotation( ) and getAnnotations( ), AnnotatedElement defines two
other methods. The first is getDeclaredAnnotations( ), which has this general form:
Annotation[ ] getDeclaredAnnotations( )
It returns all non-inherited annotations present in the invoking object. The second is
isAnnotationPresent( ), which has this general form:
boolean isAnnotationPresent(Class annoType)
It returns true if the annotation specified by annoType is associated with the invoking
object. It returns false otherwise.
N OTE The methods getAnnotation( ) and isAnnotationPresent( ) make use of the generics
feature to ensure type safety. Because generics are not discussed until Chapter 14, their
signatures are shown in this chapter in their raw forms.Chapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
Using Default Values
You can give annotation members default values that will be used if no value is specified
when the annotation is applied. A default value is specified by adding a default clause to
a member’s declaration. It has this general form:
type member( ) default value;
Here, value must be of a type compatible with type.
Here is @MyAnno rewritten to include default values:
// An annotation type declaration that includes defaults.
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno 
This declaration gives a default value of “Testing” to str and 9000 to val. This means that
neither value needs to be specified when @MyAnno is used. However, either or both can be
given values if desired. Therefore, following are the four ways that @MyAnno can be used:
@MyAnno() // both str and val default
@MyAnno(str = "some string") // val defaults
@MyAnno(val = 100) // str defaults
@MyAnno(str = "Testing", val = 100) // no defaults
The following program demonstrates the use of default values in an annotation.
import java.lang.annotation.*;
import java.lang.reflect.*;
// An annotation type declaration that includes defaults.
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno 
class Meta3 
The output is shown here:
Testing 9000
Marker Annotations
A marker annotation is a special kind of annotation that contains no members. Its sole purpose
is to mark a declaration. Thus, its presence as an annotation is sufficient. The best way to
determine if a marker annotation is present is to use the method isAnnotationPresent( ),
which is a defined by the AnnotatedElement interface.
Here is an example that uses a marker annotation. Because a marker interface contains
no members, simply determining whether it is present or absent is sufficient.
import java.lang.annotation.*;
import java.lang.reflect.*;
// A marker annotation.
@Retention(RetentionPolicy.RUNTIME)
@interface MyMarker 
class Marker 
The output, shown here, confirms that @MyMarker is present:
MyMarker is present.
In the program, notice that you do not need to follow @MyMarker with parentheses
when it is applied. Thus, @MyMarker is applied simply by using its name, like this:
@MyMarker
It is not wrong to supply an empty set of parentheses, but they are not needed.
Single-Member Annotations
A single-member annotation contains only one member. It works like a normal annotation
except that it allows a shorthand form of specifying the value of the member. When only one
member is present, you can simply specify the value for that member when the annotation
is applied—you don’t need to specify the name of the member. However, in order to use
this shorthand, the name of the member must be value.
Here is an example that creates and uses a single-member annotation:
import java.lang.annotation.*;
import java.lang.reflect.*;
// A single-member annotation.
@Retention(RetentionPolicy.RUNTIME)
@interface MySingle 
class Single 
As expected, this program displays the value 100. In the program, @MySingle is used to
annotate myMeth( ), as shown here:
@MySingle(100)
Notice that value = need not be specified.
You can use the single-value syntax when applying an annotation that has other members,
but those other members must all have default values. For example, here the value xyz is added,
with a default value of zero:
@interface SomeAnno 
In cases in which you want to use the default for xyz, you can apply @SomeAnno, as
shown next, by simply specifying the value of value by using the single-member syntax.
@SomeAnno(88)
In this case, xyz defaults to zero, and value gets the value 88. Of course, to specify a different
value for xyz requires that both members be explicitly named, as shown here:
@SomeAnno(value = 88, xyz = 99)
Remember, whenever you are using a single-member annotation, the name of that member
must be value.
The Built-In Annotations
Java defines many built-in annotations. Most are specialized, but seven are general purpose.
Of these, four are imported from java.lang.annotation: @Retention, @Documented, @Target,
and @Inherited. Three—@Override, @Deprecated, and @SuppressWarnings—are included
in java.lang. Each is described here.
@Retention
@Retention is designed to be used only as an annotation to another annotation. It specifies
the retention policy as described earlier in this chapter.
@Documented
The @Documented annotation is a marker interface that tells a tool that an annotation is to
be documented. It is designed to be used only as an annotation to an annotation declaration.
@Target
The @Target annotation specifies the types of declarations to which an annotation can be
applied. It is designed to be used only as an annotation to another annotation. @Target takesChapter 12:
Enumerations, Autoboxing, and Annotations (Metadata)
one argument, which must be a constant from the ElementType enumeration. This argument
specifies the types of declarations to which the annotation can be applied. The constants are
shown here along with the type of declaration to which they correspond.
Target Constant
Annotation Can Be Applied To
ANNOTATION_TYPE Another annotation
CONSTRUCTOR Constructor
FIELD Field
LOCAL_VARIABLE Local variable
METHOD Method
PACKAGE Package
PARAMETER Parameter
TYPE Class, interface, or enumeration
You can specify one or more of these values in a @Target annotation. To specify multiple
values, you must specify them within a braces-delimited list. For example, to specify that an
annotation applies only to fields and local variables, you can use this @Target annotation:
@Target(  )
@Inherited
@Inherited is a marker annotation that can be used only on another annotation declaration.
Furthermore, it affects only annotations that will be used on class declarations. @Inherited
causes the annotation for a superclass to be inherited by a subclass. Therefore, when a request
for a specific annotation is made to the subclass, if that annotation is not present in the subclass,
then its superclass is checked. If that annotation is present in the superclass, and if it is annotated
with @Inherited, then that annotation will be returned.
@Override
@Override is a marker annotation that can be used only on methods. A method annotated
with @Override must override a method from a superclass. If it doesn’t, a compile-time
error will result. It is used to ensure that a superclass method is actually overridden, and
not simply overloaded.
@Deprecated
@Deprecated is a marker annotation. It indicates that a declaration is obsolete and has been
replaced by a newer form.
@SuppressWarnings
@SuppressWarnings specifies that one or more warnings that might be issued by the compiler
are to be suppressed. The warnings to suppress are specified by name, in string form. This
annotation can be applied to any type of declaration.
283284
Part I:
The Java Language
Some Restrictions
There are a number of restrictions that apply to annotation declarations. First, no annotation
can inherit another. Second, all methods declared by an annotation must be without parameters.
Furthermore, they must return one of the following:
• A primitive type, such as int or double
• An object of type String or Class
• An enum type
• Another annotation type
• An array of one of the preceding types
Annotations cannot be generic. In other words, they cannot take type parameters. (Generics
are described in Chapter 14.) Finally, annotation methods cannot specify a throws clause.13
I/O, Applets, and
Other Topics
T
his chapter introduces two of Java’s most important packages: io and applet. The io
package supports Java’s basic I/O (input/output) system, including file I/O. The applet
package supports applets. Support for both I/O and applets comes from Java’s core
API libraries, not from language keywords. For this reason, an in-depth discussion of these
topics is found in Part II of this book, which examines Java’s API classes. This chapter discusses
the foundation of these two subsystems so that you can see how they are integrated into the
Java language and how they fit into the larger context of the Java programming and execution
environment. This chapter also examines the last of Java’s keywords: transient, volatile,
instanceof, native, strictfp, and assert. It concludes by examining static import and by
describing another use for the this keyword.
I/O Basics
As you may have noticed while reading the preceding 12 chapters, not much use has been
made of I/O in the example programs. In fact, aside from print( ) and println( ), none of the
I/O methods have been used significantly. The reason is simple: most real applications of
Java are not text-based, console programs. Rather, they are graphically oriented programs that
rely upon Java’s Abstract Window Toolkit (AWT) or Swing for interaction with the user.
Although text-based programs are excellent as teaching examples, they do not constitute an
important use for Java in the real world. Also, Java’s support for console I/O is limited and
somewhat awkward to use—even in simple example programs. Text-based console I/O is
just not very important to Java programming.
The preceding paragraph notwithstanding, Java does provide strong, flexible support
for I/O as it relates to files and networks. Java’s I/O system is cohesive and consistent. In
fact, once you understand its fundamentals, the rest of the I/O system is easy to master.
285286
Part I:
The Java Language
Streams
Java programs perform I/O through streams. A stream is an abstraction that either produces
or consumes information. A stream is linked to a physical device by the Java I/O system.
All streams behave in the same manner, even if the actual physical devices to which they are
linked differ. Thus, the same I/O classes and methods can be applied to any type of device.
This means that an input stream can abstract many different kinds of input: from a disk file,
a keyboard, or a network socket. Likewise, an output stream may refer to the console, a disk
file, or a network connection. Streams are a clean way to deal with input/output without
having every part of your code understand the difference between a keyboard and a network,
for example. Java implements streams within class hierarchies defined in the java.io package.
Byte Streams and Character Streams
Java defines two types of streams: byte and character. Byte streams provide a convenient
means for handling input and output of bytes. Byte streams are used, for example, when
reading or writing binary data. Character streams provide a convenient means for handling
input and output of characters. They use Unicode and, therefore, can be internationalized.
Also, in some cases, character streams are more efficient than byte streams.
The original version of Java (Java 1.0) did not include character streams and, thus, all
I/O was byte-oriented. Character streams were added by Java 1.1, and certain byte-oriented
classes and methods were deprecated. This is why older code that doesn’t use character streams
should be updated to take advantage of them, where appropriate.
One other point: at the lowest level, all I/O is still byte-oriented. The character-based
streams simply provide a convenient and efficient means for handling characters.
An overview of both byte-oriented streams and character-oriented streams is presented
in the following sections.
The Byte Stream Classes
Byte streams are defined by using two class hierarchies. At the top are two abstract classes:
InputStream and OutputStream. Each of these abstract classes has several concrete subclasses
that handle the differences between various devices, such as disk files, network connections,
and even memory buffers. The byte stream classes are shown in Table 13-1. A few of these
classes are discussed later in this section. Others are described in Part II. Remember, to use
the stream classes, you must import java.io.
The abstract classes InputStream and OutputStream define several key methods that
the other stream classes implement. Two of the most important are read( ) and write( ),
which, respectively, read and write bytes of data. Both methods are declared as abstract
inside InputStream and OutputStream. They are overridden by derived stream classes.
The Character Stream Classes
Character streams are defined by using two class hierarchies. At the top are two abstract
classes, Reader and Writer. These abstract classes handle Unicode character streams. Java
has several concrete subclasses of each of these. The character stream classes are shown in
Table 13-2.
The abstract classes Reader and Writer define several key methods that the other stream
classes implement. Two of the most important methods are read( ) and write( ), which read
and write characters of data, respectively. These methods are overridden by derived stream
classes.Chapter 13:
Stream Class Meaning
BufferedInputStream Buffered input stream
I / O , A p p l e t s , a n d O t h e r To p i c s
BufferedOutputStream Buffered output stream
ByteArrayInputStream Input stream that reads from a byte array
ByteArrayOutputStream Output stream that writes to a byte array
DataInputStream An input stream that contains methods for reading the Java standard
data types
DataOutputStream An output stream that contains methods for writing the Java standard
data types
FileInputStream Input stream that reads from a file
FileOutputStream Output stream that writes to a file
FilterInputStream Implements InputStream
FilterOutputStream Implements OutputStream
InputStream Abstract class that describes stream input
ObjectInputStream Input stream for objects
ObjectOutputStream Output stream for objects
OutputStream Abstract class that describes stream output
PipedInputStream Input pipe
PipedOutputStream Output pipe
PrintStream Output stream that contains print( ) and println( )
PushbackInputStream Input stream that supports one-byte “unget,” which returns a byte to
the input stream
RandomAccessFile Supports random access file I/O
SequenceInputStream Input stream that is a combination of two or more input streams that
will be read sequentially, one after the other
T ABLE 13-1
The Byte Stream Classes
Stream Class
Meaning
BufferedReader Buffered input character stream
BufferedWriter Buffered output character stream
CharArrayReader Input stream that reads from a character array
CharArrayWriter Output stream that writes to a character array
FileReader Input stream that reads from a file
FileWriter Output stream that writes to a file
FilterReader Filtered reader
FilterWriter Filtered writer
T ABLE 13-2
The Character Stream I/O Classes
287288
Part I:
The Java Language
Stream Class Meaning
InputStreamReader Input stream that translates bytes to characters
LineNumberReader Input stream that counts lines
OutputStreamWriter Output stream that translates characters to bytes
PipedReader Input pipe
PipedWriter Output pipe
PrintWriter Output stream that contains print( ) and println( )
PushbackReader Input stream that allows characters to be returned to the input stream
Reader Abstract class that describes character stream input
StringReader Input stream that reads from a string
StringWriter Output stream that writes to a string
Writer Abstract class that describes character stream output
T ABLE 13-2
The Character Stream I/O Classes (continued)
The Predefined Streams
As you know, all Java programs automatically import the java.lang package. This package
defines a class called System, which encapsulates several aspects of the run-time environment.
For example, using some of its methods, you can obtain the current time and the settings of
various properties associated with the system. System also contains three predefined stream
variables: in, out, and err. These fields are declared as public, static, and final within
System. This means that they can be used by any other part of your program and without
reference to a specific System object.
System.out refers to the standard output stream. By default, this is the console. System.in
refers to standard input, which is the keyboard by default. System.err refers to the standard
error stream, which also is the console by default. However, these streams may be redirected
to any compatible I/O device.
System.in is an object of type InputStream; System.out and System.err are objects of
type PrintStream. These are byte streams, even though they typically are used to read and
write characters from and to the console. As you will see, you can wrap these within character-
based streams, if desired.
The preceding chapters have been using System.out in their examples. You can use
System.err in much the same way. As explained in the next section, use of System.in is
a little more complicated.
Reading Console Input
In Java 1.0, the only way to perform console input was to use a byte stream, and older code
that uses this approach persists. Today, using a byte stream to read console input is still
technically possible, but doing so is not recommended. The preferred method of reading
console input is to use a character-oriented stream, which makes your program easier to
internationalize and maintain.Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
In Java, console input is accomplished by reading from System.in. To obtain a character-
based stream that is attached to the console, wrap System.in in a BufferedReader object.
BufferedReader supports a buffered input stream. Its most commonly used constructor
is shown here:
BufferedReader(Reader inputReader)
Here, inputReader is the stream that is linked to the instance of BufferedReader that is being
created. Reader is an abstract class. One of its concrete subclasses is InputStreamReader,
which converts bytes to characters. To obtain an InputStreamReader object that is linked to
System.in, use the following constructor:
InputStreamReader(InputStream inputStream)
Because System.in refers to an object of type InputStream, it can be used for inputStream.
Putting it all together, the following line of code creates a BufferedReader that is connected
to the keyboard:
BufferedReader br = new BufferedReader(new
InputStreamReader(System.in));
After this statement executes, br is a character-based stream that is linked to the console
through System.in.
Reading Characters
To read a character from a BufferedReader, use read( ). The version of read( ) that we will
be using is
int read( ) throws IOException
Each time that read( ) is called, it reads a character from the input stream and returns it as
an integer value. It returns 1 – when the end of the stream is encountered. As you can see,
it can throw an IOException.
The following program demonstrates read( ) by reading characters from the console
until the user types a "q.” Notice that any I/O exceptions that might be generated are
simply thrown out of main( ). Such an approach is common when reading from the console,
but you can handle these types of errors yourself, if you chose.
// Use a BufferedReader to read characters from the console.
import java.io.*;
class BRRead 
Here is a sample run:
Enter characters, 'q' to quit.
123abcq
1
2
3
a
b
c
q
This output may look a little different from what you expected, because System.in is line
buffered, by default. This means that no input is actually passed to the program until you
press ENTER . As you can guess, this does not make read( ) particularly valuable for interactive
console input.
Reading Strings
To read a string from the keyboard, use the version of readLine( ) that is a member of the
BufferedReader class. Its general form is shown here:
String readLine( ) throws IOException
As you can see, it returns a String object.
The following program demonstrates BufferedReader and the readLine( ) method;
the program reads and displays lines of text until you enter the word “stop”:
// Read a string from console using a BufferedReader.
import java.io.*;
class BRReadLines 
The next example creates a tiny text editor. It creates an array of String objects and then
reads in lines of text, storing each line in the array. It will read up to 100 lines or until you
enter “stop.” It uses a BufferedReader to read from the console.
// A tiny editor.
import java.io.*;
class TinyEdit 
Here is a sample run:
Enter lines of text.
Enter 'stop' to quit.
This is line one.
This is line two.
Java makes working with strings easy.
Just create String objects.
stop
Here is your file:
This is line one.
This is line two.
Java makes working with strings easy.
Just create String objects.
291292
Part I:
The Java Language
Writing Console Output
Console output is most easily accomplished with print( ) and println( ), described earlier,
which are used in most of the examples in this book. These methods are defined by the
class PrintStream (which is the type of object referenced by System.out). Even though
System.out is a byte stream, using it for simple program output is still acceptable. However,
a character-based alternative is described in the next section.
Because PrintStream is an output stream derived from OutputStream, it also implements
the low-level method write( ). Thus, write( ) can be used to write to the console. The simplest
form of write( ) defined by PrintStream is shown here:
void write(int byteval)
This method writes to the stream the byte specified by byteval. Although byteval is declared
as an integer, only the low-order eight bits are written. Here is a short example that uses
write( ) to output the character “A” followed by a newline to the screen:
// Demonstrate System.out.write().
class WriteDemo 
You will not often use write( ) to perform console output (although doing so might be
useful in some situations), because print( ) and println( ) are substantially easier to use.
The PrintWriter Class
Although using System.out to write to the console is acceptable, its use is recommended
mostly for debugging purposes or for sample programs, such as those found in this book.
For real-world programs, the recommended method of writing to the console when using
Java is through a PrintWriter stream. PrintWriter is one of the character-based classes.
Using a character-based class for console output makes it easier to internationalize your
program.
PrintWriter defines several constructors. The one we will use is shown here:
PrintWriter(OutputStream outputStream, boolean flushOnNewline)
Here, outputStream is an object of type OutputStream, and flushOnNewline controls whether
Java flushes the output stream every time a println( ) method is called. If flushOnNewline is
true, flushing automatically takes place. If false, flushing is not automatic.
PrintWriter supports the print( ) and println( ) methods for all types including Object.
Thus, you can use these methods in the same way as they have been used with System.out.
If an argument is not a simple type, the PrintWriter methods call the object’s toString( )
method and then print the result.Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
To write to the console by using a PrintWriter, specify System.out for the output stream
and flush the stream after each newline. For example, this line of code creates a PrintWriter
that is connected to console output:
PrintWriter pw = new PrintWriter(System.out, true);
The following application illustrates using a PrintWriter to handle console output:
// Demonstrate PrintWriter
import java.io.*;
public class PrintWriterDemo 
The output from this program is shown here:
This is a string
-7
4.5E-7
Remember, there is nothing wrong with using System.out to write simple text output
to the console when you are learning Java or debugging your programs. However, using a
PrintWriter will make your real-world applications easier to internationalize. Because no
advantage is gained by using a PrintWriter in the sample programs shown in this book, we
will continue to use System.out to write to the console.
Reading and Writing Files
Java provides a number of classes and methods that allow you to read and write files. In Java,
all files are byte-oriented, and Java provides methods to read and write bytes from and to a
file. However, Java allows you to wrap a byte-oriented file stream within a character-based
object. This technique is described in Part II. This chapter examines the basics of file I/O.
Two of the most often-used stream classes are FileInputStream and FileOutputStream,
which create byte streams linked to files. To open a file, you simply create an object of one of
these classes, specifying the name of the file as an argument to the constructor. While both
classes support additional, overridden constructors, the following are the forms that we will
be using:
FileInputStream(String fileName) throws FileNotFoundException
FileOutputStream(String fileName) throws FileNotFoundException
293294
Part I:
The Java Language
Here, fileName specifies the name of the file that you want to open. When you create an
input stream, if the file does not exist, then FileNotFoundException is thrown. For output
streams, if the file cannot be created, then FileNotFoundException is thrown. When an
output file is opened, any preexisting file by the same name is destroyed.
When you are done with a file, you should close it by calling close( ). It is defined by
both FileInputStream and FileOutputStream, as shown here:
void close( ) throws IOException
To read from a file, you can use a version of read( ) that is defined within FileInputStream.
The one that we will use is shown here:
int read( ) throws IOException
Each time that it is called, it reads a single byte from the file and returns the byte as an integer
value. read( ) returns 1 – when the end of the file is encountered. It can throw an IOException.
The following program uses read( ) to input and display the contents of a text file, the name
of which is specified as a command-line argument. Note the try/catch blocks that handle
two errors that might occur when this program is used—the specified file not being found
or the user forgetting to include the name of the file. You can use this same approach
whenever you use command-line arguments. Other I/O exceptions that might occur
are simply thrown out of main( ), which is acceptable for this simple example. However,
often you will want to handle all I/O exceptions yourself when working with files.
/* Display a text file.
To use this program, specify the name
of the file that you want to see.
For example, to see a file called TEST.TXT,
use the following command line.
java ShowFile TEST.TXT
*/
import java.io.*;
class ShowFile 
To write to a file, you can use the write( ) method defined by FileOutputStream. Its
simplest form is shown here:
void write(int byteval) throws IOException
This method writes the byte specified by byteval to the file. Although byteval is declared as
an integer, only the low-order eight bits are written to the file. If an error occurs during
writing, an IOException is thrown. The next example uses write( ) to copy a text file:
/* Copy a text file.
To use this program, specify the name
of the source file and the destination file.
For example, to copy a file called FIRST.TXT
to a file called SECOND.TXT, use the following
command line.
java CopyFile FIRST.TXT SECOND.TXT
*/
import java.io.*;
class CopyFile 
Notice the way that potential I/O errors are handled in this program. Unlike some other
computer languages, including C and C++, which use error codes to report file errors, Java
uses its exception handling mechanism. Not only does this make file handling cleaner, but
it also enables Java to easily differentiate the end-of-file condition from file errors when
input is being performed. In C/C++, many input functions return the same value when
an error occurs and when the end of the file is reached. (That is, in C/C++, an EOF condition
often is mapped to the same value as an input error.) This usually means that the programmer
must include extra program statements to determine which event actually occurred. In Java,
errors are passed to your program via exceptions, not by values returned by read( ).
Thus, when read( ) returns 1 – , it means only one thing: the end of the file has been
encountered.
Applet Fundamentals
All of the preceding examples in this book have been Java console-based applications. However,
these types of applications constitute only one class of Java programs. Another type of program
is the applet. As mentioned in Chapter 1, applets are small applications that are accessed on an
Internet server, transported over the Internet, automatically installed, and run as part of a web
document. After an applet arrives on the client, it has limited access to resources so that it
can produce a graphical user interface and run complex computations without introducing
the risk of viruses or breaching data integrity.Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
Many of the issues connected with the creation and use of applets are found in Part II,
when the applet package is examined and also when Swing is described in Part III. However,
the fundamentals connected to the creation of an applet are presented here, because applets
are not structured in the same way as the programs that have been used thus far. As you
will see, applets differ from console-based applications in several key areas.
Let’s begin with the simple applet shown here:
import java.awt.*;
import java.applet.*;
public class SimpleApplet extends Applet 
This applet begins with two import statements. The first imports the Abstract Window
Toolkit (AWT) classes. Applets interact with the user (either directly or indirectly) through
the AWT, not through the console-based I/O classes. The AWT contains support for a
window-based, graphical user interface. As you might expect, the AWT is quite large
and sophisticated, and a complete discussion of it consumes several chapters in Part II of
this book. Fortunately, this simple applet makes very limited use of the AWT. (Applets can
also use Swing to provide the graphical user interface, but this approach is described later in
this book.) The second import statement imports the applet package, which contains the
class Applet. Every applet that you create must be a subclass of Applet.
The next line in the program declares the class SimpleApplet. This class must be declared
as public, because it will be accessed by code that is outside the program.
Inside SimpleApplet, paint( ) is declared. This method is defined by the AWT and must
be overridden by the applet. paint( ) is called each time that the applet must redisplay its
output. This situation can occur for several reasons. For example, the window in which the
applet is running can be overwritten by another window and then uncovered. Or, the applet
window can be minimized and then restored. paint( ) is also called when the applet begins
execution. Whatever the cause, whenever the applet must redraw its output, paint( ) is called.
The paint( ) method has one parameter of type Graphics. This parameter contains the graphics
context, which describes the graphics environment in which the applet is running. This context
is used whenever output to the applet is required.
Inside paint( ) is a call to drawString( ), which is a member of the Graphics class.
This method outputs a string beginning at the specified X,Y location. It has the following
general form:
void drawString(String message, int x, int y)
Here, message is the string to be output beginning at x,y. In a Java window, the upper-left
corner is location 0,0. The call to drawString( ) in the applet causes the message “A Simple
Applet” to be displayed beginning at location 20,20.
Notice that the applet does not have a main( ) method. Unlike Java programs, applets
do not begin execution at main( ). In fact, most applets don’t even have a main( ) method.
Instead, an applet begins execution when the name of its class is passed to an applet viewer
or to a network browser.
297298
Part I:
The Java Language
After you enter the source code for SimpleApplet, compile in the same way that you
have been compiling programs. However, running SimpleApplet involves a different process.
In fact, there are two ways in which you can run an applet:
• Executing the applet within a Java-compatible web browser.
• Using an applet viewer, such as the standard tool, appletviewer. An applet viewer
executes your applet in a window. This is generally the fastest and easiest way to
test your applet.
Each of these methods is described next.
To execute an applet in a web browser, you need to write a short HTML text file that
contains a tag that loads the applet. Currently, Sun recommends using the APPLET tag for
this purpose. Here is the HTML file that executes SimpleApplet:
<applet code="SimpleApplet" width=200 height=60>
</applet>
The width and height statements specify the dimensions of the display area used by the
applet. (The APPLET tag contains several other options that are examined more closely in
Part II.) After you create this file, you can execute your browser and then load this file, which
causes SimpleApplet to be executed.
To execute SimpleApplet with an applet viewer, you may also execute the HTML file
shown earlier. For example, if the preceding HTML file is called RunApp.html, then the
following command line will run SimpleApplet:
C:\>appletviewer RunApp.html
However, a more convenient method exists that you can use to speed up testing. Simply
include a comment at the head of your Java source code file that contains the APPLET tag.
By doing so, your code is documented with a prototype of the necessary HTML statements,
and you can test your compiled applet merely by starting the applet viewer with your Java
source code file. If you use this method, the SimpleApplet source file looks like this:
import java.awt.*;
import java.applet.*;
/*
<applet code="SimpleApplet" width=200 height=60>
</applet>
*/
public class SimpleApplet extends Applet 
With this approach, you can quickly iterate through applet development by using these
three steps:
1. Edit a Java source file.
2. Compile your program.Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
3. Execute the applet viewer, specifying the name of your applet’s source file. The applet
viewer will encounter the APPLET tag within the comment and execute your applet.
The window produced by SimpleApplet, as displayed by the applet viewer, is shown in
the following illustration:
While the subject of applets is more fully discussed later in this book, here are the key
points that you should remember now:
• Applets do not need a main( ) method.
• Applets must be run under an applet viewer or a Java-compatible browser.
• User I/O is not accomplished with Java’s stream I/O classes. Instead, applets use
the interface provided by the AWT or Swing.
The transient and volatile Modifiers
Java defines two interesting type modifiers: transient and volatile. These modifiers are used
to handle somewhat specialized situations.
When an instance variable is declared as transient, then its value need not persist when
an object is stored. For example:
class T 
Here, if an object of type T is written to a persistent storage area, the contents of a would
not be saved, but the contents of b would.
The volatile modifier tells the compiler that the variable modified by volatile can be
changed unexpectedly by other parts of your program. One of these situations involves
multithreaded programs. (You saw an example of this in Chapter 11.) In a multithreaded
program, sometimes two or more threads share the same variable. For efficiency considerations,
each thread can keep its own, private copy of such a shared variable. The real (or master) copy of
the variable is updated at various times, such as when a synchronized method is entered. While
this approach works fine, it may be inefficient at times. In some cases, all that really matters is
that the master copy of a variable always reflects its current state. To ensure this, simply specify
the variable as volatile, which tells the compiler that it must always use the master copy of a
volatile variable (or, at least, always keep any private copies up-to-date with the master copy,
and vice versa). Also, accesses to the master variable must be executed in the precise order in
which they are executed on any private copy.
299300
Part I:
The Java Language
Using instanceof
Sometimes, knowing the type of an object during run time is useful. For example, you might
have one thread of execution that generates various types of objects, and another thread
that processes these objects. In this situation, it might be useful for the processing thread to
know the type of each object when it receives it. Another situation in which knowledge of
an object’s type at run time is important involves casting. In Java, an invalid cast causes a
run-time error. Many invalid casts can be caught at compile time. However, casts involving
class hierarchies can produce invalid casts that can be detected only at run time. For example,
a superclass called A can produce two subclasses, called B and C. Thus, casting a B object
into type A or casting a C object into type A is legal, but casting a B object into type C (or
vice versa) isn’t legal. Because an object of type A can refer to objects of either B or C, how
can you know, at run time, what type of object is actually being referred to before attempting
the cast to type C? It could be an object of type A, B, or C. If it is an object of type B, a run-
time exception will be thrown. Java provides the run-time operator instanceof to answer
this question.
The instanceof operator has this general form:
objref instanceof type
Here, objref is a reference to an instance of a class, and type is a class type. If objref is of the
specified type or can be cast into the specified type, then the instanceof operator evaluates to
true. Otherwise, its result is false. Thus, instanceof is the means by which your program can
obtain run-time type information about an object.
The following program demonstrates instanceof:
// Demonstrate instanceof operator.
class A 
class B 
class C extends A 
class D extends A 
class InstanceOf 
The output from this program is shown here:
a is instance of A
b is instance of B
Object");
Object");
Object");
Object");
301302
Part I:
The Java Language
c is instance of C
c can be cast to A
ob now refers to d
ob is instance of D
ob now refers to c
ob cannot be cast to D
ob can be cast to A
a
b
c
d
may
may
may
may
be
be
be
be
cast
cast
cast
cast
to
to
to
to
Object
Object
Object
Object
The instanceof operator isn’t needed by most programs, because, generally, you know
the type of object with which you are working. However, it can be very useful when you’re
writing generalized routines that operate on objects of a complex class hierarchy.
strictfp
A relatively new keyword is strictfp. With the creation of Java 2, the floating-point computation
model was relaxed slightly. Specifically, the new model does not require the truncation of
certain intermediate values that occur during a computation. This prevents overflow or
underflow in some cases. By modifying a class or a method with strictfp, you ensure that
floating-point calculations (and thus all truncations) take place precisely as they did in
earlier versions of Java. When a class is modified by strictfp, all the methods in the class
are also modified by strictfp automatically.
For example, the following fragment tells Java to use the original floating-point model
for calculations in all methods defined within MyClass:
strictfp class MyClass { //...
Frankly, most programmers never need to use strictfp, because it affects only a very small
class of problems.
Native Methods
Although it is rare, occasionally you may want to call a subroutine that is written in a
language other than Java. Typically, such a subroutine exists as executable code for the CPU
and environment in which you are working—that is, native code. For example, you may
want to call a native code subroutine to achieve faster execution time. Or, you may want to
use a specialized, third-party library, such as a statistical package. However, because Java
programs are compiled to bytecode, which is then interpreted (or compiled on-the-fly) by
the Java run-time system, it would seem impossible to call a native code subroutine from
within your Java program. Fortunately, this conclusion is false. Java provides the nativeChapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
keyword, which is used to declare native code methods. Once declared, these methods can
be called from inside your Java program just as you call any other Java method.
To declare a native method, precede the method with the native modifier, but do not
define any body for the method. For example:
public native int meth() ;
After you declare a native method, you must write the native method and follow a rather
complex series of steps to link it with your Java code.
Most native methods are written in C. The mechanism used to integrate C code with a
Java program is called the Java Native Interface (JNI). A detailed description of the JNI is
beyond the scope of this book, but the following description provides sufficient information
for most applications.
N OTE The precise steps that you need to follow will vary between different Java environments.
They also depend on the language that you are using to implement the native method. The
following discussion assumes a Windows environment. The language used to implement the
native method is C.
The easiest way to understand the process is to work through an example. To begin, enter
the following short program, which uses a native method called test( ):
// A simple example that uses a native method.
public class NativeDemo 
Notice that the test( ) method is declared as native and has no body. This is the method that
we will implement in C shortly. Also notice the static block. As explained earlier in this book,
a static block is executed only once, when your program begins execution (or, more precisely,
when its class is first loaded). In this case, it is used to load the dynamic link library that
contains the native implementation of test( ). (You will see how to create this library soon.)
303304
Part I:
The Java Language
The library is loaded by the loadLibrary( ) method, which is part of the System class.
This is its general form:
static void loadLibrary(String filename)
Here, filename is a string that specifies the name of the file that holds the library. For the
Windows environment, this file is assumed to have the .DLL extension.
After you enter the program, compile it to produce NativeDemo.class. Next, you must
use javah.exe to produce one file: NativeDemo.h. (javah.exe is included in the JDK.) You
will include NativeDemo.h in your implementation of test( ). To produce NativeDemo.h,
use the following command:
javah -jni NativeDemo
This command produces a header file called NativeDemo.h. This file must be included in
the C file that implements test( ). The output produced by this command is shown here:
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class NativeDemo */
#ifndef _Included_NativeDemo
#define _Included_NativeDemo
#ifdef _ _cplusplus
extern "C" 
#endif
#endif
Pay special attention to the following line, which defines the prototype for the test( )
function that you will create:
JNIEXPORT void JNICALL Java_NativeDemo_test(JNIEnv *, jobject);
Notice that the name of the function is Java_NativeDemo_test( ). You must use this as the
name of the native function that you implement. That is, instead of creating a C function called
test( ), you will create one called Java_NativeDemo_test( ). The NativeDemo component of the
prefix is added because it identifies the test( ) method as being part of the NativeDemo
class. Remember, another class may define its own native test( ) method that is completely
different from the one declared by NativeDemo. Including the class name in the prefix
provides a way to differentiate between differing versions. As a general rule, native functions
will be given a name whose prefix includes the name of the class in which they are declared.Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
After producing the necessary header file, you can write your implementation of test( )
and store it in a file named NativeDemo.c:
/* This file contains the C version of the
test() method.
*/
#include <jni.h>
#include "NativeDemo.h"
#include <stdio.h>
JNIEXPORT void JNICALL Java_NativeDemo_test(JNIEnv *env, jobject obj)

Notice that this file includes jni.h, which contains interfacing information. This file is provided
by your Java compiler. The header file NativeDemo.h was created by javah earlier.
In this function, the GetObjectClass( ) method is used to obtain a C structure that has
information about the class NativeDemo. The GetFieldID( ) method returns a C structure
with information about the field named “i” for the class. GetIntField( ) retrieves the original
value of that field. SetIntField( ) stores an updated value in that field. (See the file jni.h for
additional methods that handle other types of data.)
After creating NativeDemo.c, you must compile it and create a DLL. To do this by using the
Microsoft C/C++ compiler, use the following command line. (You might need to specify the
path to jni.h and its subordinate file jni_md.h.)
Cl /LD NativeDemo.c
This produces a file called NativeDemo.dll. Once this is done, you can execute the Java
program, which will produce the following output:
This is ob.i before the native method: 10
Starting the native method.
i = 10
Ending the native method.
This is ob.i after the native method: 20
305306
Part I:
The Java Language
Problems with Native Methods
Native methods seem to offer great promise, because they enable you to gain access to an
existing base of library routines, and they offer the possibility of faster run-time execution.
But native methods also introduce two significant problems:
• Potential security risk Because a native method executes actual machine code,
it can gain access to any part of the host system. That is, native code is not confined
to the Java execution environment. This could allow a virus infection, for example.
For this reason, applets cannot use native methods. Also, the loading of DLLs can
be restricted, and their loading is subject to the approval of the security manager.
• Loss of portability Because the native code is contained in a DLL, it must be
present on the machine that is executing the Java program. Further, because each
native method is CPU- and operating system–
dependent, each DLL is inherently
nonportable. Thus, a Java application that uses native methods will be able to run
only on a machine for which a compatible DLL has been installed.
The use of native methods should be restricted, because they render your Java programs
nonportable and pose significant security risks.
Using assert
Another relatively new addition to Java is the keyword assert. It is used during program
development to create an assertion, which is a condition that should be true during the
execution of the program. For example, you might have a method that should always return
a positive integer value. You might test this by asserting that the return value is greater than
zero using an assert statement. At run time, if the condition actually is true, no other action
takes place. However, if the condition is false, then an AssertionError is thrown. Assertions
are often used during testing to verify that some expected condition is actually met. They are
not usually used for released code.
The assert keyword has two forms. The first is shown here:
assert condition;
Here, condition is an expression that must evaluate to a Boolean result. If the result is true,
then the assertion is true and no other action takes place. If the condition is false, then the
assertion fails and a default AssertionError object is thrown.
The second form of assert is shown here:
assert condition : expr;
In this version, expr is a value that is passed to the AssertionError constructor. This value is
converted to its string format and displayed if an assertion fails. Typically, you will specify
a string for expr, but any non-void expression is allowed as long as it defines a reasonable
string conversion.Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
Here is an example that uses assert. It verifies that the return value of getnum( ) is positive.
// Demonstrate assert.
class AssertDemo 
To enable assertion checking at run time, you must specify the -ea option. For example,
to enable assertions for AssertDemo, execute it using this line:
java -ea AssertDemo
After compiling and running as just described, the program creates the following output:
n is 3
n is 2
n is 1
Exception in thread "main" java.lang.AssertionError
at AssertDemo.main(AssertDemo.java:17)
In main( ), repeated calls are made to the method getnum( ), which returns an integer value.
The return value of getnum( ) is assigned to n and then tested using this assert statement:
assert n > 0; // will fail when n is 0
This statement will fail when n equals 0, which it will after the fourth call. When this happens,
an exception is thrown.
307308
Part I:
The Java Language
As explained, you can specify the message displayed when an assertion fails. For example,
if you substitute
assert n > 0 : "n is negative!";
for the assertion in the preceding program, then the following output will be generated:
n is 3
n is 2
n is 1
Exception in thread "main" java.lang.AssertionError: n is
negative!
at AssertDemo.main(AssertDemo.java:17)
One important point to understand about assertions is that you must not rely on them
to perform any action actually required by the program. The reason is that normally, released
code will be run with assertions disabled. For example, consider this variation of the preceding
program:
// A poor way to use assert!!!
class AssertDemo 
In this version of the program, the call to getnum( ) is moved inside the assert statement.
Although this works fine if assertions are enabled, it will cause a malfunction when assertions
are disabled, because the call to getnum( ) will never be executed! In fact, n must now be
initialized, because the compiler will recognize that it might not be assigned a value by the
assert statement.
Assertions are a good addition to Java because they streamline the type of error checking
that is common during development. For example, prior to assert, if you wanted to verify that
n was positive in the preceding program, you had to use a sequence of code similar to this:Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
if(n < 0) 
With assert, you need only one line of code. Furthermore, you don’t have to remove the
assert statements from your released code.
Assertion Enabling and Disabling Options
When executing code, you can disable assertions by using the -da option. You can enable or
disable a specific package by specifying its name after the -ea or -da option. For example, to
enable assertions in a package called MyPack, use
-ea:MyPack
To disable assertions in MyPack, use
-da:MyPack
To enable or disable all subpackages of a package, follow the package name with three dots.
For example,
-ea:MyPack...
You can also specify a class with the -ea or -da option. For example, this enables
AssertDemo individually:
-ea:AssertDemo
Static Import
JDK 5 added a new feature to Java called static import that expands the capabilities of the
import keyword. By following import with the keyword static, an import statement can
be used to import the static members of a class or interface. When using static import, it is
possible to refer to static members directly by their names, without having to qualify them
with the name of their class. This simplifies and shortens the syntax required to use a static
member.
To understand the usefulness of static import, let’s begin with an example that does
not use it. The following program computes the hypotenuse of a right triangle. It uses two
static methods from Java’s built-in math class Math, which is part of java.lang. The first is
Math.pow( ), which returns a value raised to a specified power. The second is Math.sqrt( ),
which returns the square root of its argument.
// Compute the hypotenuse of a right triangle.
class Hypot 
Because pow( ) and sqrt( ) are static methods, they must be called through the use of
their class’ name, Math. This results in a somewhat unwieldy hypotenuse calculation:
hypot = Math.sqrt(Math.pow(side1, 2) +
Math.pow(side2, 2));
As this simple example illustrates, having to specify the class name each time pow( ) or
sqrt( ) (or any of Java’s other math methods, such as sin( ), cos( ), and tan( )) is used can
grow tedious.
You can eliminate the tedium of specifying the class name through the use of static
import, as shown in the following version of the preceding program:
// Use static import to bring sqrt() and pow() into view.
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
// Compute the hypotenuse of a right triangle.
class Hypot Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
In this version, the names sqrt and pow are brought into view by these static import
statements:
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
After these statements, it is no longer necessary to qualify sqrt( ) or pow( ) with their class name.
Therefore, the hypotenuse calculation can more conveniently be specified, as shown here:
hypot = sqrt(pow(side1, 2) + pow(side2, 2));
As you can see, this form is considerably more readable.
There are two general forms of the import static statement. The first, which is used by
the preceding example, brings into view a single name. Its general form is shown here:
import static pkg.type-name.static-member-name;
Here, type-name is the name of a class or interface that contains the desired static member. Its full
package name is specified by pkg. The name of the member is specified by static-member-name.
The second form of static import imports all static members of a given class or interface.
Its general form is shown here:
import static pkg.type-name.*;
If you will be using many static methods or fields defined by a class, then this form lets you
bring them into view without having to specify each individually. Therefore, the preceding
program could have used this single import statement to bring both pow( ) and sqrt( ) (and
all other static members of Math) into view:
import static java.lang.Math.*;
Of course, static import is not limited just to the Math class or just to methods. For example,
this brings the static field System.out into view:
import static java.lang.System.out;
After this statement, you can output to the console without having to qualify out with
System, as shown here:
out.println("After importing System.out, you can use out directly.");
Whether importing System.out as just shown is a good idea is subject to debate. Although
it does shorten the statement, it is no longer instantly clear to anyone reading the program
that the out being referred to is System.out.
One other point: in addition to importing the static members of classes and interfaces
defined by the Java API, you can also use static import to import the static members of classes
and interfaces that you create.
311312
Part I:
The Java Language
As convenient as static import can be, it is important not to abuse it. Remember, the reason
that Java organizes its libraries into packages is to avoid namespace collisions. When you
import static members, you are bringing those members into the global namespace. Thus,
you are increasing the potential for namespace conflicts and for the inadvertent hiding of
other names. If you are using a static member once or twice in the program, it’s best not to
import it. Also, some static names, such as System.out, are so recognizable that you might
not want to import them. Static import is designed for those situations in which you are using
a static member repeatedly, such as when performing a series of mathematical computations.
In essence, you should use, but not abuse, this feature.
Invoking Overloaded Constructors Through this( )
When working with overloaded constructors, it is sometimes useful for one constructor to
invoke another. In Java, this is accomplished by using another form of the this keyword.
The general form is shown here:
this(arg-list)
When this( ) is executed, the overloaded constructor that matches the parameter list
specified by arg-list is executed first. Then, if there are any statements inside the original
constructor, they are executed. The call to this( ) must be the first statement within the
constructor.
To understand how this( ) can be used, let’s work through a short example. First,
consider the following class that does not use this( ):
class MyClass Chapter 13:
I / O , A p p l e t s , a n d O t h e r To p i c s
This class contains three constructors, each of which initializes the values of a and b. The
first is passed individual values for a and b. The second is passed just one value, which is
assigned to both a and b. The third gives a and b default values of zero.
By using this( ), it is possible to rewrite MyClass as shown here:
class MyClass 
In this version of MyClass, the only constructor that actually assigns values to the a and
b fields is MyClass(int, int). The other two constructors simply invoke that constructor
(either directly or indirectly) through this( ). For example, consider what happens when this
statement executes:
MyClass mc = new MyClass(8);
The call to MyClass(8) causes this(8, 8) to be executed, which translates into a call to
MyClass(8, 8), because this is the version of the MyClass constructor whose parameter list
matches the arguments passed via this( ). Now, consider the following statement, which
uses the default constructor:
MyClass mc2 = new MyClass();
In this case, this(0) is called. This causes MyClass(0) to be invoked because it is the
constructor with the matching parameter list. Of course, MyClass(0) then calls MyClass(0,
0) as just described.
One reason why invoking overloaded constructors through this( ) can be useful is that it
can prevent the unnecessary duplication of code. In many cases, reducing duplicate code
decreases the time it takes to load your class because often the object code is smaller. This is
especially important for programs delivered via the Internet in which load times are an
issue. Using this( ) can also help structure your code when constructors contain a large
amount of duplicate code.
313314
Part I:
The Java Language
However, you need to be careful. Constructors that call this( ) will execute a bit slower
than those that contain all of their initialization code inline. This is because the call and
return mechanism used when the second constructor is invoked adds overhead. If your
class will be used to create only a handful of objects, or if the constructors in the class that
call this( ) will be seldom used, then this decrease in run-time performance is probably
insignificant. However, if your class will be used to create a large number of objects (on the
order of thousands) during program execution, then the negative impact of the increased
overhead could be meaningful. Because object creation affects all users of your class, there
will be cases in which you must carefully weigh the benefits of faster load time against the
increased time it takes to create an object.
Here is another consideration: for very short constructors, such as those used by MyClass,
there is often little difference in the size of the object code whether this( ) is used or not.
(Actually, there are cases in which no reduction in the size of the object code is achieved.)
This is because the bytecode that sets up and returns from the call to this( ) adds instructions
to the object file. Therefore, in these types of situations, even though duplicate code is
eliminated, using this( ) will not obtain significant savings in terms of load time. However,
the added cost in terms of overhead to each object’s construction will still be incurred.
Therefore, this( ) is most applicable to constructors that contain large amounts of initialization
code, not for those that simply set the value of a handful of fields.
There are two restrictions you need to keep in mind when using this( ). First, you cannot
use any instance variable of the constructor’s class in a call to this( ). Second, you cannot use
super( ) and this( ) in the same constructor because each must be the first statement in the
constructor.14
Generics
S
ince the original 1.0 release in 1995, many new features have been added to Java. The one
that has had the most profound impact is generics. Introduced by JDK 5, generics changed
Java in two important ways. First, it added a new syntactical element to the language.
Second, it caused changes to many of the classes and methods in the core API. Because generics
represented such a large change to the language, some programmers were reluctant to adopt its
use. However, with the release of JDK 6, generics can no longer be ignored. Simply put, if you
will be programming in Java SE 6, you will be using generics. Fortunately, generics are not
difficult to use, and they provide significant benefits for the Java programmer.
Through the use of generics, it is possible to create classes, interfaces, and methods that
will work in a type-safe manner with various kinds of data. Many algorithms are logically the
same no matter what type of data they are being applied to. For example, the mechanism that
supports a stack is the same whether that stack is storing items of type Integer, String, Object,
or Thread. With generics, you can define an algorithm once, independently of any specific
type of data, and then apply that algorithm to a wide variety of data types without any additional
effort. The expressive power generics add to the language fundamentally changes the way
that Java code is written.
Perhaps the one feature of Java that has been most significantly affected by generics is
the Collections Framework. The Collections Framework is part of the Java API and is described
in detail in Chapter 17, but a brief mention is useful now. A collection is a group of objects.
The Collections Framework defines several classes, such as lists and maps, that manage
collections. The collection classes have always been able to work with any type of object.
The benefit that generics add is that the collection classes can now be used with complete
type safety. Thus, in addition to providing a powerful, new language element, generics also
enabled an existing feature to be substantially improved. This is why generics represent such
an important addition to Java.
This chapter describes the syntax, theory, and use of generics. It also shows how generics
provide type safety for some previously difficult cases. Once you have completed this chapter,
you will want to examine Chapter 17, which covers the Collections Framework. There you
will find many examples of generics at work.
R EMEMBER Generics were added by JDK 5. Source code using generics cannot be compiled by
earlier versions of javac.
315316
Part I:
The Java Language
What Are Generics?
At its core, the term generics means parameterized types. Parameterized types are important
because they enable you to create classes, interfaces, and methods in which the type of data
upon which they operate is specified as a parameter. Using generics, it is possible to create
a single class, for example, that automatically works with different types of data. A class,
interface, or method that operates on a parameterized type is called generic, as in generic class
or generic method.
It is important to understand that Java has always given you the ability to create generalized
classes, interfaces, and methods by operating through references of type Object. Because Object
is the superclass of all other classes, an Object reference can refer to any type object. Thus, in
pre-generics code, generalized classes, interfaces, and methods used Object references to
operate on various types of objects. The problem was that they could not do so with type safety.
Generics add the type safety that was lacking. They also streamline the process, because
it is no longer necessary to explicitly employ casts to translate between Object and the type
of data that is actually being operated upon. With generics, all casts are automatic and implicit.
Thus, generics expand your ability to reuse code and let you do so safely and easily.
N OTE A Warning to C++ Programmers: Although generics are similar to templates in C++, they
are not the same. There are some fundamental differences between the two approaches to generic
types. If you have a background in C++, it is important not to jump to conclusions about how
generics work in Java.
A Simple Generics Example
Let’s begin with a simple example of a generic class. The following program defines two
classes. The first is the generic class Gen, and the second is GenDemo, which uses Gen.
// A simple generic class.
// Here, T is a type parameter that
// will be replaced by a real type
// when an object of type Gen is created.
class Gen<T> Chapter 14:
Generics
// Demonstrate the generic class.
class GenDemo 
The output produced by the program is shown here:
Type of T is java.lang.Integer
value: 88
Type of T is java.lang.String
value: Generics Test
Let’s examine this program carefully.
First, notice how Gen is declared by the following line:
class Gen<T> {
Here, T is the name of a type parameter. This name is used as a placeholder for the actual
type that will be passed to Gen when an object is created. Thus, T is used within Gen whenever
the type parameter is needed. Notice that T is contained within < >. This syntax can be
generalized. Whenever a type parameter is being declared, it is specified within angle
brackets. Because Gen uses a type parameter, Gen is a generic class, which is also called a
parameterized type.
317318
Part I:
The Java Language
Next, T is used to declare an object called ob, as shown here:
T ob; // declare an object of type T
As explained, T is a placeholder for the actual type that will be specified when a Gen object
is created. Thus, ob will be an object of the type passed to T. For example, if type String is
passed to T, then in that instance, ob will be of type String.
Now consider Gen’s constructor:
Gen(T o) 
Notice that its parameter, o, is of type T. This means that the actual type of o is determined
by the type passed to T when a Gen object is created. Also, because both the parameter o
and the member variable ob are of type T, they will both be of the same actual type when a
Gen object is created.
The type parameter T can also be used to specify the return type of a method, as is the
case with the getob( ) method, shown here:
T getob() 
Because ob is also of type T, its type is compatible with the return type specified by getob( ).
The showType( ) method displays the type of T by calling getName( ) on the Class object
returned by the call to getClass( ) on ob. The getClass( ) method is defined by Object and is
thus a member of all class types. It returns a Class object that corresponds to the type of the
class of the object on which it is called. Class defines the getName( ) method, which returns
a string representation of the class name.
The GenDemo class demonstrates the generic Gen class. It first creates a version of Gen
for integers, as shown here:
Gen<Integer> iOb;
Look closely at this declaration. First, notice that the type Integer is specified within the
angle brackets after Gen. In this case, Integer is a type argument that is passed to Gen’s type
parameter, T. This effectively creates a version of Gen in which all references to T are translated
into references to Integer. Thus, for this declaration, ob is of type Integer, and the return type
of getob( ) is of type Integer.
Before moving on, it’s necessary to state that the Java compiler does not actually create
different versions of Gen, or of any other generic class. Although it’s helpful to think in
these terms, it is not what actually happens. Instead, the compiler removes all generic type
information, substituting the necessary casts, to make your code behave as if a specific version
of Gen were created. Thus, there is really only one version of Gen that actually exists in your
program. The process of removing generic type information is called erasure, and we will
return to this topic later in this chapter.Chapter 14:
Generics
The next line assigns to iOb a reference to an instance of an Integer version of the Gen
class:
iOb = new Gen<Integer>(88);
Notice that when the Gen constructor is called, the type argument Integer is also specified.
This is necessary because the type of the object (in this case iOb) to which the reference is
being assigned is of type Gen<Integer>. Thus, the reference returned by new must also be
of type Gen<Integer>. If it isn’t, a compile-time error will result. For example, the following
assignment will cause a compile-time error:
iOb = new Gen<Double>(88.0); // Error!
Because iOb is of type Gen<Integer>, it can’t be used to refer to an object of Gen<Double>.
This type checking is one of the main benefits of generics because it ensures type safety.
As the comments in the program state, the assignment
iOb = new Gen<Integer>(88);
makes use of autoboxing to encapsulate the value 88, which is an int, into an Integer. This
works because Gen<Integer> creates a constructor that takes an Integer argument. Because
an Integer is expected, Java will automatically box 88 inside one. Of course, the assignment
could also have been written explicitly, like this:
iOb = new Gen<Integer>(new Integer(88));
However, there would be no benefit to using this version.
The program then displays the type of ob within iOb, which is Integer. Next, the program
obtains the value of ob by use of the following line:
int v = iOb.getob();
Because the return type of getob( ) is T, which was replaced by Integer when iOb was
declared, the return type of getob( ) is also Integer, which unboxes into int when assigned
to v (which is an int). Thus, there is no need to cast the return type of getob( ) to Integer.
Of course, it’s not necessary to use the auto-unboxing feature. The preceding line could
have been written like this, too:
int v = iOb.getob().intValue();
However, the auto-unboxing feature makes the code more compact.
Next, GenDemo declares an object of type Gen<String>:
Gen<String> strOb = new Gen<String>("Generics Test");
Because the type argument is String, String is substituted for T inside Gen. This creates
(conceptually) a String version of Gen, as the remaining lines in the program demonstrate.
319320
Part I:
The Java Language
Generics Work Only with Objects
When declaring an instance of a generic type, the type argument passed to the type parameter
must be a class type. You cannot use a primitive type, such as int or char. For example, with
Gen, it is possible to pass any class type to T, but you cannot pass a primitive type to a type
parameter. Therefore, the following declaration is illegal:
Gen<int> strOb = new Gen<int>(53); // Error, can't use primitive type
Of course, not being able to specify a primitive type is not a serious restriction because you
can use the type wrappers (as the preceding example did) to encapsulate a primitive type.
Further, Java’s autoboxing and auto-unboxing mechanism makes the use of the type wrapper
transparent.
Generic Types Differ Based on Their Type Arguments
A key point to understand about generic types is that a reference of one specific version of a
generic type is not type compatible with another version of the same generic type. For example,
assuming the program just shown, the following line of code is in error and will not compile:
iOb = strOb; // Wrong!
Even though both iOb and strOb are of type Gen<T>, they are references to different types
because their type parameters differ. This is part of the way that generics add type safety and
prevent errors.
How Generics Improve Type Safety
At this point, you might be asking yourself the following question: Given that the same
functionality found in the generic Gen class can be achieved without generics, by simply
specifying Object as the data type and employing the proper casts, what is the benefit of
making Gen generic? The answer is that generics automatically ensure the type safety of all
operations involving Gen. In the process, they eliminate the need for you to enter casts and
to type-check code by hand.
To understand the benefits of generics, first consider the following program that creates
a non-generic equivalent of Gen:
// NonGen is functionally equivalent to Gen
// but does not use generics.
class NonGen 
// Demonstrate the non-generic class.
class NonGenDemo 
There are several things of interest in this version. First, notice that NonGen replaces all
uses of T with Object. This makes NonGen able to store any type of object, as can the generic
version. However, it also prevents the Java compiler from having any real knowledge about
the type of data actually stored in NonGen, which is bad for two reasons. First, explicit casts
must be employed to retrieve the stored data. Second, many kinds of type mismatch errors
cannot be found until run time. Let’s look closely at each problem.
321322
Part I:
The Java Language
Notice this line:
int v = (Integer) iOb.getob();
Because the return type of getob( ) is Object, the cast to Integer is necessary to enable that
value to be auto-unboxed and stored in v. If you remove the cast, the program will not compile.
With the generic version, this cast was implicit. In the non-generic version, the cast must be
explicit. This is not only an inconvenience, but also a potential source of error.
Now, consider the following sequence from near the end of the program:
// This compiles, but is conceptually wrong!
iOb = strOb;
v = (Integer) iOb.getob(); // run-time error!
Here, strOb is assigned to iOb. However, strOb refers to an object that contains a string, not
an integer. This assignment is syntactically valid because all NonGen references are the same,
and any NonGen reference can refer to any other NonGen object. However, the statement is
semantically wrong, as the next line shows. Here, the return type of getob( ) is cast to Integer,
and then an attempt is made to assign this value to v. The trouble is that iOb now refers to
an object that stores a String, not an Integer. Unfortunately, without the use of generics, the
Java compiler has no way to know this. Instead, a run-time exception occurs when the cast
to Integer is attempted. As you know, it is extremely bad to have run-time exceptions occur
in your code!
The preceding sequence can’t occur when generics are used. If this sequence were
attempted in the generic version of the program, the compiler would catch it and report an
error, thus preventing a serious bug that results in a run-time exception. The ability to create
type-safe code in which type-mismatch errors are caught at compile time is a key advantage
of generics. Although using Object references to create “generic” code has always been
possible, that code was not type safe, and its misuse could result in run-time exceptions.
Generics prevent this from occurring. In essence, through generics, what were once
run-time errors have become compile-time errors. This is a major advantage.
A Generic Class with Two Type Parameters
You can declare more than one type parameter in a generic type. To specify two or more
type parameters, simply use a comma-separated list. For example, the following TwoGen
class is a variation of the Gen class that has two type parameters:
// A simple generic class with two type
// parameters: T and V.
class TwoGen<T, V> 
// Demonstrate TwoGen.
class SimpGen 
The output from this program is shown here:
Type of T is java.lang.Integer
Type of V is java.lang.String
value: 88
value: Generics
Notice how TwoGen is declared:
class TwoGen<T, V> {
It specifies two type parameters: T and V, separated by a comma. Because it has two type
parameters, two type arguments must be passed to TwoGen when an object is created, as
shown next:
TwoGen<Integer, String> tgObj =
new TwoGen<Integer, String>(88, "Generics");
323324
Part I:
The Java Language
In this case, Integer is substituted for T, and String is substituted for V.
Although the two type arguments differ in this example, it is possible for both types to
be the same. For example, the following line of code is valid:
TwoGen<String, String> x = new TwoGen<String, String>("A", "B");
In this case, both T and V would be of type String. Of course, if the type arguments were
always the same, then two type parameters would be unnecessary.
The General Form of a Generic Class
The generics syntax shown in the preceding examples can be generalized. Here is the syntax
for declaring a generic class:
class class-name<type-param-list> { // ...
Here is the syntax for declaring a reference to a generic class:
class-name<type-arg-list> var-name =
new class-name<type-arg-list>(cons-arg-list);
Bounded Types
In the preceding examples, the type parameters could be replaced by any class type. This is
fine for many purposes, but sometimes it is useful to limit the types that can be passed to a
type parameter. For example, assume that you want to create a generic class that contains a
method that returns the average of an array of numbers. Furthermore, you want to use the
class to obtain the average of an array of any type of number, including integers, floats, and
doubles. Thus, you want to specify the type of the numbers generically, using a type parameter.
To create such a class, you might try something like this:
// Stats attempts (unsuccessfully) to
// create a generic class that can compute
// the average of an array of numbers of
// any given type.
//
// The class contains an error!
class Stats<T> 
In Stats, the average( ) method attempts to obtain the double version of each number in
the nums array by calling doubleValue( ). Because all numeric classes, such as Integer and
Double, are subclasses of Number, and Number defines the doubleValue( ) method, this
method is available to all numeric wrapper classes. The trouble is that the compiler has no
way to know that you are intending to create Stats objects using only numeric types. Thus,
when you try to compile Stats, an error is reported that indicates that the doubleValue( )
method is unknown. To solve this problem, you need some way to tell the compiler that
you intend to pass only numeric types to T. Furthermore, you need some way to ensure that
only numeric types are actually passed.
To handle such situations, Java provides bounded types. When specifying a type parameter,
you can create an upper bound that declares the superclass from which all type arguments
must be derived. This is accomplished through the use of an extends clause when specifying
the type parameter, as shown here:
<T extends superclass>
This specifies that T can only be replaced by superclass, or subclasses of superclass. Thus,
superclass defines an inclusive, upper limit.
You can use an upper bound to fix the Stats class shown earlier by specifying Number
as an upper bound, as shown here:
// In this version of Stats, the type argument for
// T must be either Number, or a class derived
// from Number.
class Stats<T extends Number> 
325326
Part I:
The Java Language
// Demonstrate Stats.
class BoundsDemo 
The output is shown here:
Average is 3.0
Average is 3.3
Notice how Stats is now declared by this line:
class Stats<T extends Number> {
Because the type T is now bounded by Number, the Java compiler knows that all objects of
type T can call doubleValue( ) because it is a method declared by Number. This is, by itself,
a major advantage. However, as an added bonus, the bounding of T also prevents nonnumeric
Stats objects from being created. For example, if you try removing the comments from the
lines at the end of the program, and then try recompiling, you will receive compile-time
errors because String is not a subclass of Number.
In addition to using a class type as a bound, you can also use an interface type. In fact,
you can specify multiple interfaces as bounds. Furthermore, a bound can include both a
class type and one or more interfaces. In this case, the class type must be specified first.
When a bound includes an interface type, only type arguments that implement that
interface are legal. When specifying a bound that has a class and an interface, or multiple
interfaces, use the & operator to connect them. For example,
class Gen<T extends MyClass & MyInterface> { // ...Chapter 14:
Generics
Here, T is bounded by a class called MyClass and an interface called MyInterface. Thus,
any type argument passed to T must be a subclass of MyClass and implement MyInterface.
Using Wildcard Arguments
As useful as type safety is, sometimes it can get in the way of perfectly acceptable constructs.
For example, given the Stats class shown at the end of the preceding section, assume that
you want to add a method called sameAvg( ) that determines if two Stats objects contain
arrays that yield the same average, no matter what type of numeric data each object holds.
For example, if one object contains the double values 1.0, 2.0, and 3.0, and the other object
contains the integer values 2, 1, and 3, then the averages will be the same. One way to
implement sameAvg( ) is to pass it a Stats argument, and then compare the average of that
argument against the invoking object, returning true only if the averages are the same. For
example, you want to be able to call sameAvg( ), as shown here:
Integer inums[] = ;
Double dnums[] = ;
Stats<Integer> iob = new Stats<Integer>(inums);
Stats<Double> dob = new Stats<Double>(dnums);
if(iob.sameAvg(dob))
System.out.println("Averages are the same.");
else
System.out.println("Averages differ.");
At first, creating sameAvg( ) seems like an easy problem. Because Stats is generic and its
average( ) method can work on any type of Stats object, it seems that creating sameAvg( )
would be straightforward. Unfortunately, trouble starts as soon as you try to declare a
parameter of type Stats. Because Stats is a parameterized type, what do you specify for
Stats’ type parameter when you declare a parameter of that type?
At first, you might think of a solution like this, in which T is used as the type parameter:
// This won't work!
// Determine if two averages are the same.
boolean sameAvg(Stats<T> ob) 
The trouble with this attempt is that it will work only with other Stats objects whose type is
the same as the invoking object. For example, if the invoking object is of type Stats<Integer>,
then the parameter ob must also be of type Stats<Integer>. It can’t be used to compare the
average of an object of type Stats<Double> with the average of an object of type Stats<Short>,
for example. Therefore, this approach won’t work except in a very narrow context and does
not yield a general (that is, generic) solution.
327328
Part I:
The Java Language
To create a generic sameAvg( ) method, you must use another feature of Java generics:
the wildcard argument. The wildcard argument is specified by the ?, and it represents an
unknown type. Using a wildcard, here is one way to write the sameAvg( ) method:
// Determine if two averages are the same.
// Notice the use of the wildcard.
boolean sameAvg(Stats<?> ob) 
Here, Stats<?> matches any Stats object, allowing any two Stats objects to have their
averages compared. The following program demonstrates this:
// Use a wildcard.
class Stats<T extends Number> 
// Demonstrate wildcard.
class WildcardDemo 
The output is shown here:
iob average
dob average
fob average
Averages of
Averages of
is 3.0
is 3.3
is 3.0
iob and dob differ.
iob and fob are the same.
One last point: It is important to understand that the wildcard does not affect what type
of Stats objects can be created. This is governed by the extends clause in the Stats declaration.
The wildcard simply matches any valid Stats object.
Bounded Wildcards
Wildcard arguments can be bounded in much the same way that a type parameter can be
bounded. A bounded wildcard is especially important when you are creating a generic type
that will operate on a class hierarchy. To understand why, let’s work through an example.
Consider the following hierarchy of classes that encapsulate coordinates:
// Two-dimensional coordinates.
class TwoD 
329330
Part I:
The Java Language
// Three-dimensional coordinates.
class ThreeD extends TwoD 
// Four-dimensional coordinates.
class FourD extends ThreeD 
At the top of the hierarchy is TwoD, which encapsulates a two-dimensional, XY coordinate.
TwoD is inherited by ThreeD, which adds a third dimension, creating an XYZ coordinate.
ThreeD is inherited by FourD, which adds a fourth dimension (time), yielding a
four-dimensional coordinate.
Shown next is a generic class called Coords, which stores an array of coordinates:
// This class holds an array of coordinate objects.
class Coords<T extends TwoD> 
Notice that Coords specifies a type parameter bounded by TwoD. This means that any
array stored in a Coords object will contain objects of type TwoD or one of its subclasses.
Now, assume that you want to write a method that displays the X and Y coordinates
for each element in the coords array of a Coords object. Because all types of Coords objects
have at least two coordinates (X and Y), this is easy to do using a wildcard, as shown here:
static void showXY(Coords<?> c) 
Because Coords is a bounded generic type that specifies TwoD as an upper bound, all
objects that can be used to create a Coords object will be arrays of type TwoD, or of classes
derived from TwoD. Thus, showXY( ) can display the contents of any Coords object.Chapter 14:
Generics
However, what if you want to create a method that displays the X, Y, and Z coordinates
of a ThreeD or FourD object? The trouble is that not all Coords objects will have three
coordinates, because a Coords<TwoD> object will only have X and Y. Therefore, how do
you write a method that displays the X, Y, and Z coordinates for Coords<ThreeD> and
Coords<FourD> objects, while preventing that method from being used with Coords<TwoD>
objects? The answer is the bounded wildcard argument.
A bounded wildcard specifies either an upper bound or a lower bound for the type
argument. This enables you to restrict the types of objects upon which a method will operate.
The most common bounded wildcard is the upper bound, which is created using an extends
clause in much the same way it is used to create a bounded type.
Using a bounded wildcard, it is easy to create a method that displays the X, Y, and Z
coordinates of a Coords object, if that object actually has those three coordinates. For example,
the following showXYZ( ) method shows the X, Y, and Z coordinates of the elements stored
in a Coords object, if those elements are actually of type ThreeD (or are derived from ThreeD):
static void showXYZ(Coords<? extends ThreeD> c) 
Notice that an extends clause has been added to the wildcard in the declaration of
parameter c. It states that the ? can match any type as long as it is ThreeD, or a class
derived from ThreeD. Thus, the extends clause establishes an upper bound that the ? can
match. Because of this bound, showXYZ( ) can be called with references to objects of type
Coords<ThreeD> or Coords<FourD>, but not with a reference of type Coords<TwoD>.
Attempting to call showXZY( ) with a Coords<TwoD> reference results in a compile-time
error, thus ensuring type safety.
Here is an entire program that demonstrates the actions of a bounded wildcard argument:
// Bounded Wildcard arguments.
// Two-dimensional coordinates.
class TwoD 
// Three-dimensional coordinates.
class ThreeD extends TwoD 
// Four-dimensional coordinates.
class FourD extends ThreeD 
// This class holds an array of coordinate objects.
class Coords<T extends TwoD> 
// Demonstrate a bounded wildcard.
class BoundedWildcard 
The output from the program is shown here:
Contents of tdlocs.
X Y Coordinates:
0 0
7 9
18 4
-1 -23
Contents of fdlocs.
X Y Coordinates:
1 2
6 8
22 9
3 -2
X Y Z Coordinates:
1 2 3
6 8 14
22 9 4
3 -2 -23
Generics
333334
Part I:
The Java Language
X Y Z T Coordinates:
1 2 3 4
6 8 14 8
22 9 4 9
3 -2 -23 17
Notice these commented-out lines:
//
//
showXYZ(tdlocs); // Error, not a ThreeD
showAll(tdlocs); // Error, not a FourD
Because tdlocs is a Coords(TwoD) object, it cannot be used to call showXYZ( ) or
showAll( ) because bounded wildcard arguments in their declarations prevent it. To prove
this to yourself, try removing the comment symbols, and then attempt to compile the
program. You will receive compilation errors because of the type mismatches.
In general, to establish an upper bound for a wildcard, use the following type of wildcard
expression:
<? extends superclass>
where superclass is the name of the class that serves as the upper bound. Remember, this is an
inclusive clause because the class forming the upper bound (that is, specified by superclass) is
also within bounds.
You can also specify a lower bound for a wildcard by adding a super clause to a wildcard
declaration. Here is its general form:
<? super subclass>
In this case, only classes that are superclasses of subclass are acceptable arguments. This is an
exclusive clause, because it will not match the class specified by subclass.
Creating a Generic Method
As the preceding examples have shown, methods inside a generic class can make use of a
class’ type parameter and are, therefore, automatically generic relative to the type parameter.
However, it is possible to declare a generic method that uses one or more type parameters
of its own. Furthermore, it is possible to create a generic method that is enclosed within a
non-generic class.
Let’s begin with an example. The following program declares a non-generic class called
GenMethDemo and a static generic method within that class called isIn( ). The isIn( ) method
determines if an object is a member of an array. It can be used with any type of object and
array as long as the array contains objects that are compatible with the type of the object
being sought.
// Demonstrate a simple generic method.
class GenMethDemo 
// Oops! Won't compile! Types must be compatible.
if(isIn("two", nums))
System.out.println("two is in strs");
The output from the program is shown here:
2 is in nums
7 is not in nums
two is in strs
seven is not in strs
Let’s examine isIn( ) closely. First, notice how it is declared by this line:
static <T, V extends T> boolean isIn(T x, V[] y) {
The type parameters are declared before the return type of the method. Second, notice that
the type V is upper-bounded by T. Thus, V must either be the same as type T, or a subclass
of T. This relationship enforces that isIn( ) can be called only with arguments that are compatible
with each other. Also notice that isIn( ) is static, enabling it to be called independently of any
object. Understand, though, that generic methods can be either static or non-static. There is
no restriction in this regard.
335336
Part I:
The Java Language
Now, notice how isIn( ) is called within main( ) by use of the normal call syntax, without
the need to specify type arguments. This is because the types of the arguments are automatically
discerned, and the types of T and V are adjusted accordingly. For example, in the first call:
if(isIn(2, nums))
the type of the first argument is Integer (due to autoboxing), which causes Integer to be
substituted for T. The base type of the second argument is also Integer, which makes Integer
a substitute for V, too.
In the second call, String types are used, and the types of T and V are replaced by String.
Now, notice the commented-out code, shown here:
//
//
if(isIn("two", nums))
System.out.println("two is in strs");
If you remove the comments and then try to compile the program, you will receive an error. The
reason is that the type parameter V is bounded by T in the extends clause in V’s declaration.
This means that V must be either type T, or a subclass of T. In this case, the first argument is of
type String, making T into String, but the second argument is of type Integer, which is not a
subclass of String. This causes a compile-time type-mismatch error. This ability to enforce type
safety is one of the most important advantages of generic methods.
The syntax used to create isIn( ) can be generalized. Here is the syntax for a generic method:
<type-param-list> ret-type meth-name(param-list) { // ...
In all cases, type-param-list is a comma-separated list of type parameters. Notice that for
a generic method, the type parameter list precedes the return type.
Generic Constructors
It is also possible for constructors to be generic, even if their class is not. For example, consider
the following short program:
// Use a generic constructor.
class GenCons 
class GenConsDemo 
The output is shown here:
val: 100.0
val: 123.5
Because GenCons( ) specifies a parameter of a generic type, which must be a subclass of
Number, GenCons( ) can be called with any numeric type, including Integer, Float, or
Double. Therefore, even though GenCons is not a generic class, its constructor is generic.
Generic Interfaces
In addition to generic classes and methods, you can also have generic interfaces. Generic
interfaces are specified just like generic classes. Here is an example. It creates an interface
called MinMax that declares the methods min( ) and max( ), which are expected to return
the minimum and maximum value of some set of objects.
// A generic interface example.
// A Min/Max interface.
interface MinMax<T extends Comparable<T>> 
// Now, implement MinMax
class MyClass<T extends Comparable<T>> implements MinMax<T> 
class GenIFDemo 
The output is shown here:
Max
Min
Max
Min
value
value
value
value
in
in
in
in
inums: 8
inums: 2
chs: w
chs: b
Although most aspects of this program should be easy to understand, a couple of key
points need to be made. First, notice that MinMax is declared like this:
interface MinMax<T extends Comparable<T>> {
In general, a generic interface is declared in the same way as is a generic class. In this case,
the type parameter is T, and its upper bound is Comparable, which is an interface defined by
java.lang. A class that implements Comparable defines objects that can be ordered. Thus,
requiring an upper bound of Comparable ensures that MinMax can be used only with
objects that are capable of being compared. (See Chapter 16 for more information on
Comparable.) Notice that Comparable is also generic. (It was retrofitted for generics by
JDK 5.) It takes a type parameter that specifies the type of the objects being compared.
Next, MinMax is implemented by MyClass. Notice the declaration of MyClass,
shown here:
class MyClass<T extends Comparable<T>> implements MinMax<T> {
Pay special attention to the way that the type parameter T is declared by MyClass and
then passed to MinMax. Because MinMax requires a type that implements Comparable,
the implementing class (MyClass in this case) must specify the same bound. Furthermore,
once this bound has been established, there is no need to specify it again in the implements
clause. In fact, it would be wrong to do so. For example, this line is incorrect and won’t compile:Chapter 14:
Generics
// This is wrong!
class MyClass<T extends Comparable<T>>
implements MinMax<T extends Comparable<T>> {
Once the type parameter has been established, it is simply passed to the interface without
further modification.
In general, if a class implements a generic interface, then that class must also be generic,
at least to the extent that it takes a type parameter that is passed to the interface. For example,
the following attempt to declare MyClass is in error:
class MyClass implements MinMax<T> { // Wrong!
Because MyClass does not declare a type parameter, there is no way to pass one to MinMax.
In this case, the identifier T is simply unknown, and the compiler reports an error. Of course,
if a class implements a specific type of generic interface, such as shown here:
class MyClass implements MinMax<Integer> { // OK
then the implementing class does not need to be generic.
The generic interface offers two benefits. First, it can be implemented for different types
of data. Second, it allows you to put constraints (that is, bounds) on the types of data for which
the interface can be implemented. In the MinMax example, only types that implement the
Comparable interface can be passed to T.
Here is the generalized syntax for a generic interface:
interface interface-name<type-param-list> { // ...
Here, type-param-list is a comma-separated list of type parameters. When a generic interface
is implemented, you must specify the type arguments, as shown here:
class class-name<type-param-list>
implements interface-name<type-arg-list> {
Raw Types and Legacy Code
Because support for generics is a recent addition to Java, it was necessary to provide some
transition path from old, pre-generics code. At the time of this writing, there are still millions
and millions of lines of pre-generics legacy code that must remain both functional and
compatible with generics. Pre-generics code must be able to work with generics, and
generic code must be able to work with pre-generic code.
To handle the transition to generics, Java allows a generic class to be used without any
type arguments. This creates a raw type for the class. This raw type is compatible with legacy
code, which has no knowledge of generics. The main drawback to using the raw type is that
the type safety of generics is lost.
Here is an example that shows a raw type in action:
// Demonstrate a raw type.
class Gen<T> 
// Demonstrate raw type.
class RawDemo 
// This assignment also overrides type safety.
raw = iOb; // OK, but potentially wrong
d = (Double) raw.getob(); // run-time error
This program contains several interesting things. First, a raw type of the generic Gen
class is created by the following declaration:
Gen raw = new Gen(new Double(98.6));Chapter 14:
Generics
Notice that no type arguments are specified. In essence, this creates a Gen object whose
type T is replaced by Object.
A raw type is not type safe. Thus, a variable of a raw type can be assigned a reference to
any type of Gen object. The reverse is also allowed; a variable of a specific Gen type can be
assigned a reference to a raw Gen object. However, both operations are potentially unsafe
because the type checking mechanism of generics is circumvented.
This lack of type safety is illustrated by the commented-out lines at the end of the program.
Let’s examine each case. First, consider the following situation:
//
int i = (Integer) raw.getob(); // run-time error
In this statement, the value of ob inside raw is obtained, and this value is cast to Integer.
The trouble is that raw contains a Double value, not an integer value. However, this cannot
be detected at compile time because the type of raw is unknown. Thus, this statement fails
at run time.
The next sequence assigns to a strOb (a reference of type Gen<String>) a reference to
a raw Gen object:
strOb = raw; // OK, but potentially wrong
//
String str = strOb.getob(); // run-time error
The assignment, itself, is syntactically correct, but questionable. Because strOb is of type
Gen<String>, it is assumed to contain a String. However, after the assignment, the object
referred to by strOb contains a Double. Thus, at run time, when an attempt is made to assign
the contents of strOb to str, a run-time error results because strOb now contains a Double.
Thus, the assignment of a raw reference to a generic reference bypasses the type-safety
mechanism.
The following sequence inverts the preceding case:
//
raw = iOb; // OK, but potentially wrong
d = (Double) raw.getob(); // run-time error
Here, a generic reference is assigned to a raw reference variable. Although this is syntactically
correct, it can lead to problems, as illustrated by the second line. In this case, raw now refers
to an object that contains an Integer object, but the cast assumes that it contains a Double.
This error cannot be prevented at compile time. Rather, it causes a run-time error.
Because of the potential for danger inherent in raw types, javac displays unchecked warnings
when a raw type is used in a way that might jeopardize type safety. In the preceding program,
these lines generate unchecked warnings:
Gen raw = new Gen(new Double(98.6));
strOb = raw; // OK, but potentially wrong
In the first line, it is the call to the Gen constructor without a type argument that causes the
warning. In the second line, it is the assignment of a raw reference to a generic variable that
generates the warning.
341342
Part I:
The Java Language
At first, you might think that this line should also generate an unchecked warning, but
it does not:
raw = iOb; // OK, but potentially wrong
No compiler warning is issued because the assignment does not cause any further loss of
type safety than had already occurred when raw was created.
One final point: You should limit the use of raw types to those cases in which you must
mix legacy code with newer, generic code. Raw types are simply a transitional feature and
not something that should be used for new code.
Generic Class Hierarchies
Generic classes can be part of a class hierarchy in just the same way as a non-generic class.
Thus, a generic class can act as a superclass or be a subclass. The key difference between
generic and non-generic hierarchies is that in a generic hierarchy, any type arguments needed
by a generic superclass must be passed up the hierarchy by all subclasses. This is similar to
the way that constructor arguments must be passed up a hierarchy.
Using a Generic Superclass
Here is a simple example of a hierarchy that uses a generic superclass:
// A simple generic class hierarchy.
class Gen<T> 
// A subclass of Gen.
class Gen2<T> extends Gen<T> 
In this hierarchy, Gen2 extends the generic class Gen. Notice how Gen2 is declared by
the following line:
class Gen2<T> extends Gen<T> {Chapter 14:
Generics
The type parameter T is specified by Gen2 and is also passed to Gen in the extends clause.
This means that whatever type is passed to Gen2 will also be passed to Gen. For example,
this declaration,
Gen2<Integer> num = new Gen2<Integer>(100);
passes Integer as the type parameter to Gen. Thus, the ob inside the Gen portion of Gen2
will be of type Integer.
Notice also that Gen2 does not use the type parameter T except to pass it to the Gen
superclass. Thus, even if a subclass of a generic superclass would otherwise not need to
be generic, it still must specify the type parameter(s) required by its generic superclass.
Of course, a subclass is free to add its own type parameters, if needed. For example, here
is a variation on the preceding hierarchy in which Gen2 adds a type parameter of its own:
// A subclass can add its own type parameters.
class Gen<T> 
// A subclass of Gen that defines a second
// type parameter, called V.
class Gen2<T, V> extends Gen<T> 
// Create an object of type Gen2.
class HierDemo 
Notice the declaration of this version of Gen2, which is shown here:
class Gen2<T, V> extends Gen<T> {
Here, T is the type passed to Gen, and V is the type that is specific to Gen2. V is used to
declare an object called ob2, and as a return type for the method getob2( ). In main( ), a
Gen2 object is created in which type parameter T is String, and type parameter V is Integer.
The program displays the following, expected, result:
Value is: 99
A Generic Subclass
It is perfectly acceptable for a non-generic class to be the superclass of a generic subclass.
For example, consider this program:
// A non-generic class can be the superclass
// of a generic subclass.
// A non-generic class.
class NonGen 
// A generic subclass.
class Gen<T> extends NonGen 
// Create a Gen object.
class HierDemo2 
The output from the program is shown here:
Hello 47
In the program, notice how Gen inherits NonGen in the following declaration:
class Gen<T> extends NonGen {
Because NonGen is not generic, no type argument is specified. Thus, even though Gen
declares the type parameter T, it is not needed by (nor can it be used by) NonGen. Thus,
NonGen is inherited by Gen in the normal way. No special conditions apply.
Run-Time Type Comparisons Within a Generic Hierarchy
Recall the run-time type information operator instanceof that was described in Chapter 13.
As explained, instanceof determines if an object is an instance of a class. It returns true if
an object is of the specified type or can be cast to the specified type. The instanceof operator
can be applied to objects of generic classes. The following class demonstrates some of the
type compatibility implications of a generic hierarchy:
// Use the instanceof operator with a generic class hierarchy.
class Gen<T> 
345346
Part I:
The Java Language
// A subclass of Gen.
class Gen2<T> extends Gen<T> 
// Demonstrate run-time type ID implications of generic
// class hierarchy.
class HierDemo3 
// The following can't be compiled because
// generic type info does not exist at run time.
if(iOb2 instanceof Gen2<Integer>)
System.out.println("iOb2 is instance of Gen2<Integer>");Chapter 14:
Generics
The output from the program is shown here:
iOb2 is instance of Gen2
iOb2 is instance of Gen
strOb2 is instance of Gen2
strOb2 is instance of Gen
iOb is instance of Gen
In this program, Gen2 is a subclass of Gen, which is generic on type parameter T. In
main( ), three objects are created. The first is iOb, which is an object of type Gen<Integer>.
The second is iOb2, which is an instance of Gen2<Integer>. Finally, strOb2 is an object of
type Gen2<String>.
Then, the program performs these instanceof tests on the type of iOb2:
// See if iOb2 is some form of Gen2.
if(iOb2 instanceof Gen2<?>)
System.out.println("iOb2 is instance of Gen2");
// See if iOb2 is some form of Gen.
if(iOb2 instanceof Gen<?>)
System.out.println("iOb2 is instance of Gen");
As the output shows, both succeed. In the first test, iOb2 is checked against Gen2<?>. This
test succeeds because it simply confirms that iOb2 is an object of some type of Gen2 object.
The use of the wildcard enables instanceof to determine if iOb2 is an object of any type of
Gen2. Next, iOb2 is tested against Gen<?>, the superclass type. This is also true because
iOb2 is some form of Gen, the superclass. The next few lines in main( ) show the same
sequence (and same results) for strOb2.
Next, iOb, which is an instance of Gen<Integer> (the superclass), is tested by these lines:
// See if iOb is an instance of Gen2, which it is not.
if(iOb instanceof Gen2<?>)
System.out.println("iOb is instance of Gen2");
// See if iOb is an instance of Gen, which it is.
if(iOb instanceof Gen<?>)
System.out.println("iOb is instance of Gen");
The first if fails because iOb is not some type of Gen2 object. The second test succeeds because
iOb is some type of Gen object.
Now, look closely at these commented-out lines:
//
//
// The following can't be compiled because
// generic type info does not exist at run time.
if(iOb2 instanceof Gen2<Integer>)
System.out.println("iOb2 is instance of Gen2<Integer>");
As the comments indicate, these lines can’t be compiled because they attempt to compare
iOb2 with a specific type of Gen2, in this case, Gen2<Integer>. Remember, there is no generic
347348
Part I:
The Java Language
type information available at run time. Therefore, there is no way for instanceof to know if
iOb2 is an instance of Gen2<Integer> or not.
Casting
You can cast one instance of a generic class into another only if the two are otherwise
compatible and their type arguments are the same. For example, assuming the foregoing
program, this cast is legal:
(Gen<Integer>) iOb2 // legal
because iOb2 is an instance of Gen<Integer>. But, this cast:
(Gen<Long>) iOb2 // illegal
is not legal because iOb2 is not an instance of Gen<Long>.
Overriding Methods in a Generic Class
A method in a generic class can be overridden just like any other method. For example,
consider this program in which the method getob( ) is overridden:
// Overriding a generic method in a generic class.
class Gen<T> 
// A subclass of Gen that overrides getob().
class Gen2<T> extends Gen<T> Chapter 14:
Generics
// Demonstrate generic method override.
class OverrideDemo 
The output is shown here:
Gen's getob(): 88
Gen2's getob(): 99
Gen2's getob(): Generics Test
As the output confirms, the overridden version of getob( ) is called for objects of type Gen2,
but the superclass version is called for objects of type Gen.
Erasure
Usually, it is not necessary to know the details about how the Java compiler transforms
your source code into object code. However, in the case of generics, some general
understanding of the process is important because it explains why the generic features work
as they do—and why their behavior is sometimes a bit surprising. For this reason, a brief
discussion of how generics are implemented in Java is in order.
An important constraint that governed the way that generics were added to Java was
the need for compatibility with previous versions of Java. Simply put, generic code had to
be compatible with preexisting, non-generic code. Thus, any changes to the syntax of the
Java language, or to the JVM, had to avoid breaking older code. The way Java implements
generics while satisfying this constraint is through the use of erasure.
In general, here is how erasure works. When your Java code is compiled, all generic type
information is removed (erased). This means replacing type parameters with their bound
type, which is Object if no explicit bound is specified, and then applying the appropriate
casts (as determined by the type arguments) to maintain type compatibility with the types
specified by the type arguments. The compiler also enforces this type compatibility. This
approach to generics means that no type parameters exist at run time. They are simply a
source-code mechanism.
349350
Part I:
The Java Language
To better understand how erasure works, consider the following two classes:
// Here, T is bound by Object by default.
class Gen<T> 
// Here, T is bound by String.
class GenStr<T extends String> 
After these two classes are compiled, the T in Gen will be replaced by Object. The T in
GenStr will be replaced by String. You can confirm this by running javap on their compiled
classes. The results are shown here:
class Gen extends java.lang.Object
class GenStr extends java.lang.Object
Within the code for Gen and GenStr, casts are employed to ensure proper typing. For
example, this sequence:
Gen<Integer> iOb = new Gen<Integer>(99);
int x = iOb.getob();
would be compiled as if it were written like this:Chapter 14:
Generics
Gen iOb = new Gen(99);
int x = (Integer) iOb.getob();
Because of erasure, some things work a bit differently than you might think. For example,
consider this short program that creates two objects of the generic Gen class just shown:
class GenTypeDemo 
The output from this program is shown here:
Gen
Gen
As you can see, the types of both iOb and fOb are Gen, not the Gen<Integer> and
Gen<Float> that you might have expected. Remember, all type parameters are erased
during compilation. At run time, only raw types actually exist.
Bridge Methods
Occasionally, the compiler will need to add a bridge method to a class to handle situations in
which the type erasure of an overriding method in a subclass does not produce the same
erasure as the method in the superclass. In this case, a method is generated that uses the
type erasure of the superclass, and this method calls the method that has the type erasure
specified by the subclass. Of course, bridge methods only occur at the bytecode level, are
not seen by you, and are not available for your use.
Although bridge methods are not something that you will normally need to be concerned
with, it is still instructive to see a situation in which one is generated. Consider the following
program:
// A situation that creates a bridge method.
class Gen<T> 
// A subclass of Gen.
class Gen2 extends Gen<String> 
// Demonstrate a situation that requires a bridge method.
class BridgeDemo 
In the program, the subclass Gen2 extends Gen, but does so using a String-specific version
of Gen, as its declaration shows:
class Gen2 extends Gen<String> {
Furthermore, inside Gen2, getob( ) is overridden with String specified as the return type:
// A String-specific override of getob().
String getob() 
All of this is perfectly acceptable. The only trouble is that because of type erasure, the
expected form of getob( ) will be
Object getob() { // ...
To handle this problem, the compiler generates a bridge method with the preceding signature
that calls the String version. Thus, if you examine the class file for Gen2 by using javap, you
will see the following methods:
class Gen2 extends GenChapter 14:
Generics
As you can see, the bridge method has been included. (The comment was added by the author,
and not by javap.)
There is one last point to make about bridge methods. Notice that the only difference
between the two getob( ) methods is their return type. Normally, this would cause an error,
but because this does not occur in your source code, it does not cause a problem and is handled
correctly by the JVM.
Ambiguity Errors
The inclusion of generics gives rise to a new type of error that you must guard against:
ambiguity. Ambiguity errors occur when erasure causes two seemingly distinct generic
declarations to resolve to the same erased type, causing a conflict. Here is an example that
involves method overloading:
// Ambiguity caused by erasure on
// overloaded methods.
class MyGenClass<T, V> 
Notice that MyGenClass declares two generic types: T and V. Inside MyGenClass, an
attempt is made to overload set( ) based on parameters of type T and V. This looks reasonable
because T and V appear to be different types. However, there are two ambiguity problems here.
First, as MyGenClass is written, there is no requirement that T and V actually be different
types. For example, it is perfectly correct (in principle) to construct a MyGenClass object as
shown here:
MyGenClass<String, String> obj = new MyGenClass<String, String>()
In this case, both T and V will be replaced by String. This makes both versions of set( )
identical, which is, of course, an error.
The second and more fundamental problem is that the type erasure of set( ) reduces both
versions to the following:
void set(Object o) { // ...
Thus, the overloading of set( ) as attempted in MyGenClass is inherently ambiguous.
353354
Part I:
The Java Language
Ambiguity errors can be tricky to fix. For example, if you know that V will always be some
type of String, you might try to fix MyGenClass by rewriting its declaration as shown here:
class MyGenClass<T, V extends String> {
// almost OK!
This change causes MyGenClass to compile, and you can even instantiate objects like the
one shown here:
MyGenClass<Integer, String> x = new MyGenClass<Integer, String>();
This works because Java can accurately determine which method to call. However,
ambiguity returns when you try this line:
MyGenClass<String, String> x = new MyGenClass<String, String>();
In this case, since both T and V are String, which version of set( ) is to be called?
Frankly, in the preceding example, it would be much better to use two separate method
names, rather than trying to overload set( ). Often, the solution to ambiguity involves the
restructuring of the code, because ambiguity often means that you have a conceptual error
in your design.
Some Generic Restrictions
There are a few restrictions that you need to keep in mind when using generics. They
involve creating objects of a type parameter, static members, exceptions, and arrays. Each is
examined here.
Type Parameters Can’t Be Instantiated
It is not possible to create an instance of a type parameter. For example, consider this class:
// Can't create an instance of T.
class Gen<T> 
Here, it is illegal to attempt to create an instance of T. The reason should be easy to
understand: because T does not exist at run time, how would the compiler know what type
of object to create? Remember, erasure removes all type parameters during the compilation
process.
Restrictions on Static Members
No static member can use a type parameter declared by the enclosing class. For example, all
of the static members of this class are illegal:
class Wrong<T> 
Although you can’t declare static members that use a type parameter declared by the
enclosing class, you can declare static generic methods, which define their own type parameters,
as was done earlier in this chapter.
Generic Array Restrictions
There are two important generics restrictions that apply to arrays. First, you cannot instantiate
an array whose base type is a type parameter. Second, you cannot create an array of type-
specific generic references. The following short program shows both situations:
// Generics and arrays.
class Gen<T extends Number> 
class GenArrays 
355356
Part I:
The Java Language
As the program shows, it’s valid to declare a reference to an array of type T, as this line does:
T vals[]; // OK
But, you cannot instantiate an array of T, as this commented-out line attempts:
// vals = new T[10]; // can't create an array of T
The reason you can’t create an array of T is that T does not exist at run time, so there is no
way for the compiler to know what type of array to actually create.
However, you can pass a reference to a type-compatible array to Gen( ) when an object
is created and assign that reference to vals, as the program does in this line:
vals = nums; // OK to assign reference to existent array
This works because the array passed to Gen has a known type, which will be the same type
as T at the time of object creation.
Inside main( ), notice that you can’t declare an array of references to a specific generic type.
That is, this line
// Gen<Integer> gens[] = new Gen<Integer>[10]; // Wrong!
won’t compile. Arrays of specific generic types simply aren’t allowed, because they can lead
to a loss of type safety.
You can create an array of references to a generic type if you use a wildcard, however,
as shown here:
Gen<?> gens[] = new Gen<?>[10]; // OK
This approach is better than using an array of raw types, because at least some type checking
will still be enforced.
Generic Exception Restriction
A generic class cannot extend Throwable. This means that you cannot create generic exception
classes.
Final Thoughts on Generics
Generics are a powerful extension to Java because they streamline the creation of type-safe,
reusable code. Although the generic syntax can seem a bit overwhelming at first, it will
become second nature after you use it a while. Generic code will be a part of the future for
all Java programmers.II
The Java Library
C HAPTER 15
String Handling
C HAPTER 16
Exploring java.lang
C HAPTER 17
java.util Part 1: The
Collections Framework
C HAPTER 18
java.util Part 2: More
Utility Classes
C HAPTER 19
Input/Output: Exploring
java.io
C HAPTER 20
Networking
C HAPTER 21
The Applet Class
C HAPTER 22
Event Handling
C HAPTER 23
Introducing the AWT:
Working with Windows,
Graphics, and Text
C HAPTER 24
Using AWT Controls, Layout
Managers, and Menus
C HAPTER 25
Images
C HAPTER 26
The Concurrency Utilities
C HAPTER 27
NIO, Regular Expressions,
and Other PackagesThis page intentionally left blank15
String Handling
A
brief overview of Java’s string handling was presented in Chapter 7. In this chapter,
it is described in detail. As is the case in most other programming languages, in Java
a string is a sequence of characters. But, unlike many other languages that implement
strings as character arrays, Java implements strings as objects of type String.
Implementing strings as built-in objects allows Java to provide a full complement of
features that make string handling convenient. For example, Java has methods to compare
two strings, search for a substring, concatenate two strings, and change the case of letters
within a string. Also, String objects can be constructed a number of ways, making it easy to
obtain a string when needed.
Somewhat unexpectedly, when you create a String object, you are creating a string that
cannot be changed. That is, once a String object has been created, you cannot change the
characters that comprise that string. At first, this may seem to be a serious restriction. However,
such is not the case. You can still perform all types of string operations. The difference is that
each time you need an altered version of an existing string, a new String object is created
that contains the modifications. The original string is left unchanged. This approach is used
because fixed, immutable strings can be implemented more efficiently than changeable ones.
For those cases in which a modifiable string is desired, Java provides two options: StringBuffer
and StringBuilder. Both hold strings that can be modified after they are created.
The String, StringBuffer, and StringBuilder classes are defined in java.lang. Thus, they
are available to all programs automatically. All are declared final, which means that none of
these classes may be subclassed. This allows certain optimizations that increase performance
to take place on common string operations. All three implement the CharSequence interface.
One last point: To say that the strings within objects of type String are unchangeable means
that the contents of the String instance cannot be changed after it has been created. However,
a variable declared as a String reference can be changed to point at some other String object
at any time.
The String Constructors
The String class supports several constructors. To create an empty String, you call the default
constructor. For example,
String s = new String();
will create an instance of String with no characters in it.
357358
Part II:
The Java Library
Frequently, you will want to create strings that have initial values. The String class
provides a variety of constructors to handle this. To create a String initialized by an array
of characters, use the constructor shown here:
String(char chars[ ])
Here is an example:
char chars[] = ;
String s = new String(chars);
This constructor initializes s with the string “abc”.
You can specify a subrange of a character array as an initializer using the following
constructor:
String(char chars[ ], int startIndex, int numChars)
Here, startIndex specifies the index at which the subrange begins, and numChars specifies
the number of characters to use. Here is an example:
char chars[] = ;
String s = new String(chars, 2, 3);
This initializes s with the characters cde.
You can construct a String object that contains the same character sequence as another
String object using this constructor:
String(String strObj)
Here, strObj is a String object. Consider this example:
// Construct one String from another.
class MakeString 
The output from this program is as follows:
Java
Java
As you can see, s1 and s2 contain the same string.
Even though Java’s char type uses 16 bits to represent the basic Unicode character set,
the typical format for strings on the Internet uses arrays of 8-bit bytes constructed from theChapter 15:
String Handling
ASCII character set. Because 8-bit ASCII strings are common, the String class provides
constructors that initialize a string when given a byte array. Their forms are shown here:
String(byte asciiChars[ ])
String(byte asciiChars[ ], int startIndex, int numChars)
Here, asciiChars specifies the array of bytes. The second form allows you to specify a
subrange. In each of these constructors, the byte-to-character conversion is done by using
the default character encoding of the platform. The following program illustrates these
constructors:
// Construct string from subset of char array.
class SubStringCons 
This program generates the following output:
ABCDEF
CDE
Extended versions of the byte-to-string constructors are also defined in which you can
specify the character encoding that determines how bytes are converted to characters. However,
most of the time, you will want to use the default encoding provided by the platform.
N OTE The contents of the array are copied whenever you create a String object from an array. If you
modify the contents of the array after you have created the string, the String will be unchanged.
You can construct a String from a StringBuffer by using the constructor shown here:
String(StringBuffer strBufObj)
String Constructors Added by J2SE 5
J2SE 5 added two constructors to String. The first supports the extended Unicode character
set and is shown here:
String(int codePoints[ ], int startIndex, int numChars)
Here, codePoints is an array that contains Unicode code points. The resulting string is
constructed from the range that begins at startIndex and runs for numChars.
N OTE A discussion of Unicode code points and how they are handled by Java is found in Chapter 16.
359360
Part II:
The Java Library
The second new constructor supports the new StringBuilder class. It is shown here:
String(StringBuilder strBuildObj)
This constructs a String from the StringBuilder passed in strBuildObj.
String Length
The length of a string is the number of characters that it contains. To obtain this value, call the
length( ) method, shown here:
int length( )
The following fragment prints “3”, since there are three characters in the string s:
char chars[] = ;
String s = new String(chars);
System.out.println(s.length());
Special String Operations
Because strings are a common and important part of programming, Java has added special
support for several string operations within the syntax of the language. These operations
include the automatic creation of new String instances from string literals, concatenation of
multiple String objects by use of the + operator, and the conversion of other data types to a
string representation. There are explicit methods available to perform all of these functions,
but Java does them automatically as a convenience for the programmer and to add clarity.
String Literals
The earlier examples showed how to explicitly create a String instance from an array of
characters by using the new operator. However, there is an easier way to do this using a
string literal. For each string literal in your program, Java automatically constructs a String
object. Thus, you can use a string literal to initialize a String object. For example, the following
code fragment creates two equivalent strings:
char chars[] = ;
String s1 = new String(chars);
String s2 = "abc"; // use string literal
Because a String object is created for every string literal, you can use a string literal any
place you can use a String object. For example, you can call methods directly on a quoted
string as if it were an object reference, as the following statement shows. It calls the length( )
method on the string “abc”. As expected, it prints “3”.
System.out.println("abc".length());
String Concatenation
In general, Java does not allow operators to be applied to String objects. The one exception
to this rule is the + operator, which concatenates two strings, producing a String object as theChapter 15:
String Handling
result. This allows you to chain together a series of + operations. For example, the following
fragment concatenates three strings:
String age = "9";
String s = "He is " + age + " years old.";
System.out.println(s);
This displays the string “He is 9 years old.”
One practical use of string concatenation is found when you are creating very long strings.
Instead of letting long strings wrap around within your source code, you can break them into
smaller pieces, using the + to concatenate them. Here is an example:
// Using concatenation to prevent long lines.
class ConCat 
String Concatenation with Other Data Types
You can concatenate strings with other types of data. For example, consider this slightly
different version of the earlier example:
int age = 9;
String s = "He is " + age + " years old.";
System.out.println(s);
In this case, age is an int rather than another String, but the output produced is the same
as before. This is because the int value in age is automatically converted into its string
representation within a String object. This string is then concatenated as before. The compiler
will convert an operand to its string equivalent whenever the other operand of the + is an
instance of String.
Be careful when you mix other types of operations with string concatenation expressions,
however. You might get surprising results. Consider the following:
String s = "four: " + 2 + 2;
System.out.println(s);
This fragment displays
four: 22
rather than the
four: 4
361362
Part II:
The Java Library
that you probably expected. Here’s why. Operator precedence causes the concatenation of
“four” with the string equivalent of 2 to take place first. This result is then concatenated with
the string equivalent of 2 a second time. To complete the integer addition first, you must use
parentheses, like this:
String s = "four: " + (2 + 2);
Now s contains the string “four: 4”.
String Conversion and toString( )
When Java converts data into its string representation during concatenation, it does so by
calling one of the overloaded versions of the string conversion method valueOf( ) defined
by String. valueOf( ) is overloaded for all the simple types and for type Object. For the simple
types, valueOf( ) returns a string that contains the human-readable equivalent of the value
with which it is called. For objects, valueOf( ) calls the toString( ) method on the object. We
will look more closely at valueOf( ) later in this chapter. Here, let’s examine the toString( )
method, because it is the means by which you can determine the string representation for
objects of classes that you create.
Every class implements toString( ) because it is defined by Object. However, the default
implementation of toString( ) is seldom sufficient. For most important classes that you create,
you will want to override toString( ) and provide your own string representations. Fortunately,
this is easy to do. The toString( ) method has this general form:
String toString( )
To implement toString( ), simply return a String object that contains the human-readable
string that appropriately describes an object of your class.
By overriding toString( ) for classes that you create, you allow them to be fully integrated
into Java’s programming environment. For example, they can be used in print( ) and println( )
statements and in concatenation expressions. The following program demonstrates this by
overriding toString( ) for the Box class:
// Override toString() for Box class.
class Box Chapter 15:
String Handling
class toStringDemo 
The output of this program is shown here:
Dimensions are 10.0 by 14.0 by 12.0
Box b: Dimensions are 10.0 by 14.0 by 12.0
As you can see, Box’s toString( ) method is automatically invoked when a Box object
is used in a concatenation expression or in a call to println( ).
Character Extraction
The String class provides a number of ways in which characters can be extracted from a
String object. Each is examined here. Although the characters that comprise a string within
a String object cannot be indexed as if they were a character array, many of the String methods
employ an index (or offset) into the string for their operation. Like arrays, the string indexes
begin at zero.
charAt( )
To extract a single character from a String, you can refer directly to an individual character
via the charAt( ) method. It has this general form:
char charAt(int where)
Here, where is the index of the character that you want to obtain. The value of where must be
nonnegative and specify a location within the string. charAt( ) returns the character at the
specified location. For example,
char ch;
ch = "abc".charAt(1);
assigns the value “b” to ch.
getChars( )
If you need to extract more than one character at a time, you can use the getChars( ) method.
It has this general form:
void getChars(int sourceStart, int sourceEnd, char target[ ], int targetStart)
Here, sourceStart specifies the index of the beginning of the substring, and sourceEnd
specifies an index that is one past the end of the desired substring. Thus, the substring contains
363364
Part II:
The Java Library
the characters from sourceStart through sourceEnd–
1. The array that will receive the characters
is specified by target. The index within target at which the substring will be copied is passed
in targetStart. Care must be taken to assure that the target array is large enough to hold the
number of characters in the specified substring.
The following program demonstrates getChars( ):
class getCharsDemo 
Here is the output of this program:
demo
getBytes( )
There is an alternative to getChars( ) that stores the characters in an array of bytes. This method
is called getBytes( ), and it uses the default character-to-byte conversions provided by the
platform. Here is its simplest form:
byte[ ] getBytes( )
Other forms of getBytes( ) are also available. getBytes( ) is most useful when you
are exporting a String value into an environment that does not support 16-bit Unicode
characters. For example, most Internet protocols and text file formats use 8-bit ASCII for
all text interchange.
toCharArray( )
If you want to convert all the characters in a String object into a character array, the easiest
way is to call toCharArray( ). It returns an array of characters for the entire string. It has this
general form:
char[ ] toCharArray( )
This function is provided as a convenience, since it is possible to use getChars( ) to achieve
the same result.
String Comparison
The String class includes several methods that compare strings or substrings within strings.
Each is examined here.Chapter 15:
String Handling
equals( ) and equalsIgnoreCase( )
To compare two strings for equality, use equals( ). It has this general form:
boolean equals(Object str)
Here, str is the String object being compared with the invoking String object. It returns
true if the strings contain the same characters in the same order, and false otherwise. The
comparison is case-sensitive.
To perform a comparison that ignores case differences, call equalsIgnoreCase( ). When
it compares two strings, it considers A-Z to be the same as a-z. It has this general form:
boolean equalsIgnoreCase(String str)
Here, str is the String object being compared with the invoking String object. It, too, returns
true if the strings contain the same characters in the same order, and false otherwise.
Here is an example that demonstrates equals( ) and equalsIgnoreCase( ):
// Demonstrate equals() and equalsIgnoreCase().
class equalsDemo 
" +
" +
" +
s4 + " -> " +
The output from the program is shown here:
Hello
Hello
Hello
Hello
equals Hello -> true
equals Good-bye -> false
equals HELLO -> false
equalsIgnoreCase HELLO -> true
regionMatches( )
The regionMatches( ) method compares a specific region inside a string with another specific
region in another string. There is an overloaded form that allows you to ignore case in such
comparisons. Here are the general forms for these two methods:
boolean regionMatches(int startIndex, String str2,
int str2StartIndex, int numChars)
365366
Part II:
The Java Library
boolean regionMatches(boolean ignoreCase,
int startIndex, String str2,
int str2StartIndex, int numChars)
For both versions, startIndex specifies the index at which the region begins within the
invoking String object. The String being compared is specified by str2. The index at which
the comparison will start within str2 is specified by str2StartIndex. The length of the substring
being compared is passed in numChars. In the second version, if ignoreCase is true, the case
of the characters is ignored. Otherwise, case is significant.
startsWith( ) and endsWith( )
String defines two routines that are, more or less, specialized forms of regionMatches( ).
The startsWith( ) method determines whether a given String begins with a specified string.
Conversely, endsWith( ) determines whether the String in question ends with a specified
string. They have the following general forms:
boolean startsWith(String str)
boolean endsWith(String str)
Here, str is the String being tested. If the string matches, true is returned. Otherwise, false
is returned. For example,
"Foobar".endsWith("bar")
and
"Foobar".startsWith("Foo")
are both true.
A second form of startsWith( ), shown here, lets you specify a starting point:
boolean startsWith(String str, int startIndex)
Here, startIndex specifies the index into the invoking string at which point the search will
begin. For example,
"Foobar".startsWith("bar", 3)
returns true.
equals( ) Versus ==
It is important to understand that the equals( ) method and the == operator perform two
different operations. As just explained, the equals( ) method compares the characters inside
a String object. The == operator compares two object references to see whether they refer
to the same instance. The following program shows how two different String objects can
contain the same characters, but references to these objects will not compare as equal:
// equals() vs ==
class EqualsNotEqualTo 
The variable s1 refers to the String instance created by “Hello”. The object referred to by
s2 is created with s1 as an initializer. Thus, the contents of the two String objects are identical,
but they are distinct objects. This means that s1 and s2 do not refer to the same objects and
are, therefore, not ==, as is shown here by the output of the preceding example:
Hello equals Hello -> true
Hello == Hello -> false
compareTo( )
Often, it is not enough to simply know whether two strings are identical. For sorting
applications, you need to know which is less than, equal to, or greater than the next. A string
is less than another if it comes before the other in dictionary order. A string is greater than
another if it comes after the other in dictionary order. The String method compareTo( ) serves
this purpose. It has this general form:
int compareTo(String str)
Here, str is the String being compared with the invoking String. The result of the comparison
is returned and is interpreted, as shown here:
Value Meaning
Less than zero The invoking string is less than str.
Greater than zero The invoking string is greater than str.
Zero The two strings are equal.
Here is a sample program that sorts an array of strings. The program uses compareTo( )
to determine sort ordering for a bubble sort:
// A bubble sort for Strings.
class SortString 
The output of this program is the list of words:
Now
aid
all
come
country
for
good
is
men
of
the
the
their
time
to
to
As you can see from the output of this example, compareTo( ) takes into account uppercase
and lowercase letters. The word “Now” came out before all the others because it begins with
an uppercase letter, which means it has a lower value in the ASCII character set.
If you want to ignore case differences when comparing two strings, use
compareToIgnoreCase( ), as shown here:
int compareToIgnoreCase(String str)
This method returns the same results as compareTo( ), except that case differences are ignored.
You might want to try substituting it into the previous program. After doing so, “Now”
will no longer be first.
Searching Strings
The String class provides two methods that allow you to search a string for a specified
character or substring:
• indexOf( ) Searches for the first occurrence of a character or substring.
• lastIndexOf( ) Searches for the last occurrence of a character or substring.
These two methods are overloaded in several different ways. In all cases, the methods
return the index at which the character or substring was found, or 1 – on failure.Chapter 15:
String Handling
To search for the first occurrence of a character, use
int indexOf(int ch)
To search for the last occurrence of a character, use
int lastIndexOf(int ch)
Here, ch is the character being sought.
To search for the first or last occurrence of a substring, use
int indexOf(String str)
int lastIndexOf(String str)
Here, str specifies the substring.
You can specify a starting point for the search using these forms:
int indexOf(int ch, int startIndex)
int lastIndexOf(int ch, int startIndex)
int indexOf(String str, int startIndex)
int lastIndexOf(String str, int startIndex)
Here, startIndex specifies the index at which point the search begins. For indexOf( ), the
search runs from startIndex to the end of the string. For lastIndexOf( ), the search runs from
startIndex to zero.
The following example shows how to use the various index methods to search inside
of Strings:
// Demonstrate indexOf() and lastIndexOf().
class indexOfDemo 
369370
Part II:
The Java Library
Here is the output of this program:
Now is the time for all good men to come to the aid of their country.
indexOf(t) = 7
lastIndexOf(t) = 65
indexOf(the) = 7
lastIndexOf(the) = 55
indexOf(t, 10) = 11
lastIndexOf(t, 60) = 55
indexOf(the, 10) = 44
lastIndexOf(the, 60) = 55
Modifying a String
Because String objects are immutable, whenever you want to modify a String, you must
either copy it into a StringBuffer or StringBuilder, or use one of the following String methods,
which will construct a new copy of the string with your modifications complete.
substring( )
You can extract a substring using substring( ). It has two forms. The first is
String substring(int startIndex)
Here, startIndex specifies the index at which the substring will begin. This form returns a copy
of the substring that begins at startIndex and runs to the end of the invoking string.
The second form of substring( ) allows you to specify both the beginning and ending
index of the substring:
String substring(int startIndex, int endIndex)
Here, startIndex specifies the beginning index, and endIndex specifies the stopping point.
The string returned contains all the characters from the beginning index, up to, but not
including, the ending index.
The following program uses substring( ) to replace all instances of one substring with
another within a string:
// Substring replacement.
class StringReplace 
The output from this program is shown here:
This is a test. This is, too.
Thwas is a test. This is, too.
Thwas was a test. This is, too.
Thwas was a test. Thwas is, too.
Thwas was a test. Thwas was, too.
concat( )
You can concatenate two strings using concat( ), shown here:
String concat(String str)
This method creates a new object that contains the invoking string with the contents
of str appended to the end. concat( ) performs the same function as +. For example,
String s1 = "one";
String s2 = s1.concat("two");
puts the string “onetwo” into s2. It generates the same result as the following sequence:
String s1 = "one";
String s2 = s1 + "two";
replace( )
The replace( ) method has two forms. The first replaces all occurrences of one character in
the invoking string with another character. It has the following general form:
String replace(char original, char replacement)
Here, original specifies the character to be replaced by the character specified by replacement.
The resulting string is returned. For example,
String s = "Hello".replace('l', 'w');
puts the string “Hewwo” into s.
The second form of replace( ) replaces one character sequence with another. It has this
general form:
String replace(CharSequence original, CharSequence replacement)
This form was added by J2SE 5.
371372
Part II:
The Java Library
trim( )
The trim( ) method returns a copy of the invoking string from which any leading and trailing
whitespace has been removed. It has this general form:
String trim( )
Here is an example:
String s = "
Hello World
".trim();
This puts the string “Hello World” into s.
The trim( ) method is quite useful when you process user commands. For example, the
following program prompts the user for the name of a state and then displays that state’s
capital. It uses trim( ) to remove any leading or trailing whitespace that may have inadvertently
been entered by the user.
// Using trim() to process commands.
import java.io.*;
class UseTrim 
Data Conversion Using valueOf( )
The valueOf( ) method converts data from its internal format into a human-readable form.
It is a static method that is overloaded within String for all of Java’s built-in types so that eachChapter 15:
String Handling
type can be converted properly into a string. valueOf( ) is also overloaded for type Object,
so an object of any class type you create can also be used as an argument. (Recall that Object
is a superclass for all classes.) Here are a few of its forms:
static String valueOf(double num)
static String valueOf(long num)
static String valueOf(Object ob)
static String valueOf(char chars[ ])
As we discussed earlier, valueOf( ) is called when a string representation of some other
type of data is needed—for example, during concatenation operations. You can call this method
directly with any data type and get a reasonable String representation. All of the simple types
are converted to their common String representation. Any object that you pass to valueOf( )
will return the result of a call to the object’s toString( ) method. In fact, you could just call
toString( ) directly and get the same result.
For most arrays, valueOf( ) returns a rather cryptic string, which indicates that it is an
array of some type. For arrays of char, however, a String object is created that contains the
characters in the char array. There is a special version of valueOf( ) that allows you to specify
a subset of a char array. It has this general form:
static String valueOf(char chars[ ], int startIndex, int numChars)
Here, chars is the array that holds the characters, startIndex is the index into the array of
characters at which the desired substring begins, and numChars specifies the length of the
substring.
Changing the Case of Characters Within a String
The method toLowerCase( ) converts all the characters in a string from uppercase to
lowercase. The toUpperCase( ) method converts all the characters in a string from lowercase
to uppercase. Nonalphabetical characters, such as digits, are unaffected. Here are the general
forms of these methods:
String toLowerCase( )
String toUpperCase( )
Both methods return a String object that contains the uppercase or lowercase equivalent
of the invoking String.
Here is an example that uses toLowerCase( ) and toUpperCase( ):
// Demonstrate toUpperCase() and toLowerCase().
class ChangeCase 
The output produced by the program is shown here:
Original: This is a test.
Uppercase: THIS IS A TEST.
Lowercase: this is a test.
Additional String Methods
In addition to those methods discussed earlier, String includes several other methods. These
are summarized in the following table. Notice that many were added by J2SE 5.
Method Description
int codePointAt(int i) Returns the Unicode code point at the location specified by i.
Added by J2SE 5.
int codePointBefore(int i) Returns the Unicode code point at the location that precedes
that specified by i. Added by J2SE 5.
int codePointCount(int start, int end) Returns the number of code points in the portion of the invoking
String that are between start and end–1. Added by J2SE 5.
boolean contains(CharSequence str) Returns true if the invoking object contains the string specified
by str. Returns false, otherwise. Added by J2SE 5.
boolean contentEquals(CharSequence str) Returns true if the invoking string contains the same string as
str. Otherwise, returns false. Added by J2SE 5.
boolean contentEquals(StringBuffer str) Returns true if the invoking string contains the same string as
str. Otherwise, returns false.
static String format(String fmtstr,
Object ... args) Returns a string formatted as specified by fmtstr. (See Chapter 18
for details on formatting.) Added by J2SE 5.
static String format(Locale loc,
String fmtstr,
Object ... args) Returns a string formatted as specified by fmtstr. Formatting
is governed by the locale specified by loc. (See Chapter 18 for
details on formatting.) Added by J2SE 5.
boolean matches(string regExp) Returns true if the invoking string matches the regular expression
passed in regExp. Otherwise, returns false.
int offsetByCodePoints(int start, int num) Returns the index with the invoking string that is num code points
beyond the starting index specified by start. Added by J2SE 5.
String
replaceFirst(String regExp,
String newStr) Returns a string in which the first substring that matches the
regular expression specified by regExp is replaced by newStr.
String
replaceAll(String regExp,
String newStr) Returns a string in which all substrings that match the regular
expression specified by regExp are replaced by newStr.Chapter 15:
String Handling
Method Description
String[ ] split(String regExp) Decomposes the invoking string into parts and returns an array
that contains the result. Each part is delimited by the regular
expression passed in regExp.
String[ ] split(String regExp, int max) Decomposes the invoking string into parts and returns an array
that contains the result. Each part is delimited by the regular
expression passed in regExp. The number of pieces is specified
by max. If max is negative, then the invoking string is fully
decomposed. Otherwise, if max contains a nonzero value,
the last entry in the returned array contains the remainder
of the invoking string. If max is zero, the invoking string is
fully decomposed.
CharSequence
subSequence(int startIndex,
int stopIndex) Returns a substring of the invoking string, beginning at startIndex
and stopping at stopIndex. This method is required by the
CharSequence interface, which is now implemented by String.
Notice that several of these methods work with regular expressions. Regular expressions
are described in Chapter 27.
StringBuffer
StringBuffer is a peer class of String that provides much of the functionality of strings.
As you know, String represents fixed-length, immutable character sequences. In contrast,
StringBuffer represents growable and writeable character sequences. StringBuffer may have
characters and substrings inserted in the middle or appended to the end. StringBuffer will
automatically grow to make room for such additions and often has more characters preallocated
than are actually needed, to allow room for growth. Java uses both classes heavily, but many
programmers deal only with String and let Java manipulate StringBuffers behind the scenes
by using the overloaded + operator.
StringBuffer Constructors
StringBuffer defines these four constructors:
StringBuffer( )
StringBuffer(int size)
StringBuffer(String str)
StringBuffer(CharSequence chars)
The default constructor (the one with no parameters) reserves room for 16 characters
without reallocation. The second version accepts an integer argument that explicitly sets the
size of the buffer. The third version accepts a String argument that sets the initial contents
of the StringBuffer object and reserves room for 16 more characters without reallocation.
StringBuffer allocates room for 16 additional characters when no specific buffer length is
requested, because reallocation is a costly process in terms of time. Also, frequent reallocations
can fragment memory. By allocating room for a few extra characters, StringBuffer reduces the
number of reallocations that take place. The fourth constructor creates an object that contains
the character sequence contained in chars.
375376
Part II:
The Java Library
length( ) and capacity( )
The current length of a StringBuffer can be found via the length( ) method, while the total
allocated capacity can be found through the capacity( ) method. They have the following
general forms:
int length( )
int capacity( )
Here is an example:
// StringBuffer length vs. capacity.
class StringBufferDemo 
Here is the output of this program, which shows how StringBuffer reserves extra space
for additional manipulations:
buffer = Hello
length = 5
capacity = 21
Since sb is initialized with the string “Hello” when it is created, its length is 5. Its capacity is 21
because room for 16 additional characters is automatically added.
ensureCapacity( )
If you want to preallocate room for a certain number of characters after a StringBuffer has
been constructed, you can use ensureCapacity( ) to set the size of the buffer. This is useful
if you know in advance that you will be appending a large number of small strings to a
StringBuffer. ensureCapacity( ) has this general form:
void ensureCapacity(int capacity)
Here, capacity specifies the size of the buffer.
setLength( )
To set the length of the buffer within a StringBuffer object, use setLength( ). Its general form
is shown here:
void setLength(int len)
Here, len specifies the length of the buffer. This value must be nonnegative.Chapter 15:
String Handling
When you increase the size of the buffer, null characters are added to the end of the
existing buffer. If you call setLength( ) with a value less than the current value returned by
length( ), then the characters stored beyond the new length will be lost. The setCharAtDemo
sample program in the following section uses setLength( ) to shorten a StringBuffer.
charAt( ) and setCharAt( )
The value of a single character can be obtained from a StringBuffer via the charAt( ) method.
You can set the value of a character within a StringBuffer using setCharAt( ). Their general
forms are shown here:
char charAt(int where)
void setCharAt(int where, char ch)
For charAt( ), where specifies the index of the character being obtained. For setCharAt( ),
where specifies the index of the character being set, and ch specifies the new value of that
character. For both methods, where must be nonnegative and must not specify a location
beyond the end of the buffer.
The following example demonstrates charAt( ) and setCharAt( ):
// Demonstrate charAt() and setCharAt().
class setCharAtDemo 
Here is the output generated by this program:
buffer before = Hello
charAt(1) before = e
buffer after = Hi
charAt(1) after = i
getChars( )
To copy a substring of a StringBuffer into an array, use the getChars( ) method. It has this
general form:
void getChars(int sourceStart, int sourceEnd, char target[ ],
int targetStart)
Here, sourceStart specifies the index of the beginning of the substring, and sourceEnd specifies
an index that is one past the end of the desired substring. This means that the substring
377378
Part II:
The Java Library
contains the characters from sourceStart through sourceEnd–1. The array that will receive the
characters is specified by target. The index within target at which the substring will be copied
is passed in targetStart. Care must be taken to assure that the target array is large enough to
hold the number of characters in the specified substring.
append( )
The append( ) method concatenates the string representation of any other type of data to the
end of the invoking StringBuffer object. It has several overloaded versions. Here are a few
of its forms:
StringBuffer append(String str)
StringBuffer append(int num)
StringBuffer append(Object obj)
String.valueOf( ) is called for each parameter to obtain its string representation. The
result is appended to the current StringBuffer object. The buffer itself is returned by each
version of append( ). This allows subsequent calls to be chained together, as shown in the
following example:
// Demonstrate append().
class appendDemo 
The output of this example is shown here:
a = 42!
The append( ) method is most often called when the + operator is used on String objects.
Java automatically changes modifications to a String instance into similar operations on a
StringBuffer instance. Thus, a concatenation invokes append( ) on a StringBuffer object.
After the concatenation has been performed, the compiler inserts a call to toString( ) to turn
the modifiable StringBuffer back into a constant String. All of this may seem unreasonably
complicated. Why not just have one string class and have it behave more or less like
StringBuffer? The answer is performance. There are many optimizations that the Java run
time can make knowing that String objects are immutable. Thankfully, Java hides most of the
complexity of conversion between Strings and StringBuffers. Actually, many programmers
will never feel the need to use StringBuffer directly and will be able to express most operations
in terms of the + operator on String variables.Chapter 15:
String Handling
insert( )
The insert( ) method inserts one string into another. It is overloaded to accept values of all the
simple types, plus Strings, Objects, and CharSequences. Like append( ), it calls String.valueOf( )
to obtain the string representation of the value it is called with. This string is then inserted
into the invoking StringBuffer object. These are a few of its forms:
StringBuffer insert(int index, String str)
StringBuffer insert(int index, char ch)
StringBuffer insert(int index, Object obj)
Here, index specifies the index at which point the string will be inserted into the invoking
StringBuffer object.
The following sample program inserts “like” between “I” and “Java”:
// Demonstrate insert().
class insertDemo 
The output of this example is shown here:
I like Java!
reverse( )
You can reverse the characters within a StringBuffer object using reverse( ), shown here:
StringBuffer reverse( )
This method returns the reversed object on which it was called. The following program
demonstrates reverse( ):
// Using reverse() to reverse a StringBuffer.
class ReverseDemo 
Here is the output produced by the program:
abcdef
fedcba
379380
Part II:
The Java Library
delete( ) and deleteCharAt( )
You can delete characters within a StringBuffer by using the methods delete( ) and
deleteCharAt( ). These methods are shown here:
StringBuffer delete(int startIndex, int endIndex)
StringBuffer deleteCharAt(int loc)
The delete( ) method deletes a sequence of characters from the invoking object. Here,
startIndex specifies the index of the first character to remove, and endIndex specifies an index
one past the last character to remove. Thus, the substring deleted runs from startIndex to
endIndex–1. The resulting StringBuffer object is returned.
The deleteCharAt( ) method deletes the character at the index specified by loc. It returns
the resulting StringBuffer object.
Here is a program that demonstrates the delete( ) and deleteCharAt( ) methods:
// Demonstrate delete() and deleteCharAt()
class deleteDemo 
The following output is produced:
After delete: This a test.
After deleteCharAt: his a test.
replace( )
You can replace one set of characters with another set inside a StringBuffer object by calling
replace( ). Its signature is shown here:
StringBuffer replace(int startIndex, int endIndex, String str)
The substring being replaced is specified by the indexes startIndex and endIndex. Thus, the
substring at startIndex through endIndex–
1 is replaced. The replacement string is passed in str.
The resulting StringBuffer object is returned.
The following program demonstrates replace( ):
// Demonstrate replace()
class replaceDemo 
Here is the output:
After replace: This was a test.
substring( )
You can obtain a portion of a StringBuffer by calling substring( ). It has the following two
forms:
String substring(int startIndex)
String substring(int startIndex, int endIndex)
The first form returns the substring that starts at startIndex and runs to the end of the
invoking StringBuffer object. The second form returns the substring that starts at startIndex
and runs through endIndex–1. These methods work just like those defined for String that
were described earlier.
Additional StringBuffer Methods
In addition to those methods just described, StringBuffer includes several others. They are
summarized in the following table. Notice that several were added by J2SE 5.
Method Description
StringBuffer appendCodePoint(int ch) Appends a Unicode code point to the end of the invoking object.
A reference to the object is returned. Added by J2SE 5.
int codePointAt(int i) Returns the Unicode code point at the location specified by i.
Added by J2SE 5.
int codePointBefore(int i) Returns the Unicode code point at the location that precedes
that specified by i. Added by J2SE 5.
int codePointCount(int start, int end) Returns the number of code points in the portion of the invoking
String that are between start and end–1. Added by J2SE 5.
int indexOf(String str) Searches the invoking StringBuffer for the first occurrence of str.
Returns the index of the match, or –1 if no match is found.
int indexOf(String str, int startIndex) Searches the invoking StringBuffer for the first occurrence of str,
beginning at startIndex. Returns the index of the match, or –1
if no match is found.
int lastIndexOf(String str) Searches the invoking StringBuffer for the last occurrence of str.
Returns the index of the match, or –1 if no match is found.
int lastIndexOf(String str, int startIndex) Searches the invoking StringBuffer for the last occurrence of str,
beginning at startIndex. Returns the index of the match, or –1
if no match is found.
381382
Part II:
The Java Library
Method Description
int offsetByCodePoints(int start, int num) Returns the index with the invoking string that is num code
points beyond the starting index specified by start. Added by
J2SE 5.
CharSequence
subSequence(int startIndex,
int stopIndex) Returns a substring of the invoking string, beginning at
startIndex and stopping at stopIndex. This method is required
by the CharSequence interface, which is now implemented by
StringBuffer.
void trimToSize( ) Reduces the size of the character buffer for the invoking object
to exactly fit the current contents. Added by J2SE 5.
Aside from subSequence( ), which implements a method required by the CharSequence
interface, the other methods allow a StringBuffer to be searched for an occurrence of a String.
The following program demonstrates indexOf( ) and lastIndexOf( ):
class IndexOfDemo 
The output is shown here:
First index: 0
Last index: 8
StringBuilder
J2SE 5 adds a new string class to Java’s already powerful string handling capabilities. This
new class is called StringBuilder. It is identical to StringBuffer except for one important
difference: it is not synchronized, which means that it is not thread-safe. The advantage of
StringBuilder is faster performance. However, in cases in which you are using multithreading,
you must use StringBuffer rather than StringBuilder.16
Exploring java.lang
T
his chapter discusses thos e classes and interfaces defined by java.lang. As you know,
java.lang is automatically imported into all programs. It contains classes and interfaces
that are fundamental to virtually all of Java programming. It is Java’s most widely
used package.
java.lang includes the following classes:
Boolean InheritableThreadLocal Runtime System
Byte Integer RuntimePermission Thread
Character Long SecurityManager ThreadGroup
Class Math Short ThreadLocal
ClassLoader Number StackTraceElement Throwable
Compiler Object StrictMath Void
Double Package String Enum Process StringBuffer Float ProcessBuilder StringBuilder
There are also two classes defined by the Character class: Character.Subset and
Character.UnicodeBlock.
java.lang defines the following interfaces:
Appendable Comparable
CharSequence Iterable
Cloneable Readable
Runnable
Several of the classes contained in java.lang contain deprecated methods, most dating
back to Java 1.0. These deprecated methods are still provided by Java to support an ever-
shrinking pool of legacy code and are not recommended for new code. Most of the deprecations
took place prior to Java SE 6, and these deprecated methods are not discussed here.
385386
Part II:
The Java Library
Primitive Type Wrappers
As mentioned in Part I of this book, Java uses primitive types, such as int and char, for
performance reasons. These data types are not part of the object hierarchy. They are passed
by value to methods and cannot be directly passed by reference. Also, there is no way for
two methods to refer to the same instance of an int. At times, you will need to create an
object representation for one of these primitive types. For example, there are collection
classes discussed in Chapter 17 that deal only with objects; to store a primitive type in one
of these classes, you need to wrap the primitive type in a class. To address this need, Java
provides classes that correspond to each of the primitive types. In essence, these classes
encapsulate, or wrap, the primitive types within a class. Thus, they are commonly referred
to as type wrappers. The type wrappers were introduced in Chapter 12. They are examined
in detail here.
Number
The abstract class Number defines a superclass that is implemented by the classes that wrap
the numeric types byte, short, int, long, float, and double. Number has abstract methods
that return the value of the object in each of the different number formats. For example,
doubleValue( ) returns the value as a double, floatValue( ) returns the value as a float, and
so on. These methods are shown here:
byte byteValue( )
double doubleValue( )
float floatValue( )
int intValue( )
long longValue( )
short shortValue( )
The values returned by these methods can be rounded.
Number has six concrete subclasses that hold explicit values of each numeric type: Double,
Float, Byte, Short, Integer, and Long.
Double and Float
Double and Float are wrappers for floating-point values of type double and float, respectively.
The constructors for Float are shown here:
Float(double num)
Float(float num)
Float(String str) throws NumberFormatException
As you can see, Float objects can be constructed with values of type float or double. They
can also be constructed from the string representation of a floating-point number.
The constructors for Double are shown here:
Double(double num)
Double(String str) throws NumberFormatException
Double objects can be constructed with a double value or a string containing a floating-
point value.Chapter 16:
Exploring java.lang
The methods defined by Float are shown in Table 16-1. The methods defined by Double
are shown in Table 16-2. Both Float and Double define the following constants:
MAX_EXPONENT Maximum exponent (Added by Java SE 6.)
MAX_VALUE Maximum positive value
MIN_EXPONENT Minimum exponent (Added by Java SE 6.)
MIN_NORMAL Minimum positive normal value (Added by Java SE 6.)
MIN_VALUE Minimum positive value
NaN Not a number
POSITIVE_INFINITY Positive infinity
NEGATIVE_INFINITY Negative infinity
SIZE The bit width of the wrapped value
TYPE The Class object for float or double
Method Description
byte byteValue( ) Returns the value of the invoking object as a byte.
static int compare(float num1,
float num2) Compares the values of num1 and num2. Returns 0 if
the values are equal. Returns a negative value if num1
is less than num2. Returns a positive value if num1 is
greater than num2.
int compareTo(Float f) Compares the numerical value of the invoking object with that
of f. Returns 0 if the values are equal. Returns a negative
value if the invoking object has a lower value. Returns a
positive value if the invoking object has a greater value.
double doubleValue( ) Returns the value of the invoking object as a double.
boolean equals(Object FloatObj) Returns true if the invoking Float object is equivalent to
FloatObj. Otherwise, it returns false.
static int floatToIntBits(float num) Returns the IEEE-compatible, single-precision bit pattern
that corresponds to num.
static int floatToRawIntBits(float num) Returns the IEEE-compatible single-precision bit pattern
that corresponds to num. A NaN value is preserved.
float floatValue( ) Returns the value of the invoking object as a float.
int hashCode( ) Returns the hash code for the invoking object.
static float intBitsToFloat(int num) Returns float equivalent of the IEEE-compatible,
single-precision bit pattern specified by num.
int intValue( ) Returns the value of the invoking object as an int.
boolean isInfinite( ) Returns true if the invoking object contains an infinite value.
Otherwise, it returns false.
static boolean isInfinite(float num) Returns true if num specifies an infinite value. Other wise,
it returns false.
T ABLE 16-1
The Methods Defined by Float
387388
Part II:
The Java Library
Method Description
boolean isNaN( ) Returns true if the invoking object contains a value that is
not a number. Otherwise, it returns false.
static boolean isNaN(float num) Returns true if num specifies a value that is not a number.
Otherwise, it returns false.
long longValue( ) Returns the value of the invoking object as a long.
static float parseFloat(String str)
throws NumberFormatException Returns the float equivalent of the number contained in the
string specified by str using radix 10.
short shortValue( ) Returns the value of the invoking object as a short.
static String toHexString(float num) Returns a string containing the value of num in
hexadecimal format.
String toString( ) Returns the string equivalent of the invoking object.
static String toString(float num) Returns the string equivalent of the value specified by num.
static Float valueOf(float num) Returns a Float object containing the value passed in num.
static Float valueOf(String str)
throws NumberFormatException Returns the Float object that contains the value specified
by the string in str.
T ABLE 16-1
The Methods Defined by Float (continued)
Method
Description
byte byteValue( ) Returns the value of the invoking object as a byte.
static int compare(double num1,
double num2) Compares the values of num1 and num2. Returns 0
if the values are equal. Returns a negative value if
num1 is less than num2. Returns a positive value if
num1 is greater than num2.
int compareTo(Double d) Compares the numerical value of the invoking object
with that of d. Returns 0 if the values are equal.
Returns a negative value if the invoking object has a
lower value. Returns a positive value if the invoking
object has a greater value.
static long doubleToLongBits(double num) Returns the IEEE-compatible, double-precision bit
pattern that corresponds to num.
static long doubleToRawLongBits(double num) Retuns the IEEE-compatible double-precision bit
pattern that corresponds to num. A NaN value is
preserved.
double doubleValue( ) Returns the value of the invoking object as a double.
boolean equals(Object DoubleObj) Returns true if the invoking Double object is equivalent
to DoubleObj. Otherwise, it returns false.
float floatValue( ) Returns the value of the invoking object as a float.
int hashcode( ) Returns the hash code for the invoking object.
int intValue( ) Returns the value of the invoking object as an int.
T ABLE 16-2
The Methods Defined by DoubleChapter 16:
Exploring java.lang
Method Description
boolean isInfinite( ) Returns true if the invoking object contains an infinite
value. Otherwise, it returns false.
static boolean isInfinite(double num) Returns true if num specifies an infinite value.
Otherwise, it returns false.
boolean isNaN( ) Returns true if the invoking object contains a value
that is not a number. Otherwise, it returns false.
static boolean isNaN(double num) Returns true if num specifies a value that is not a
number. Otherwise, it returns false.
static double longBitsToDouble(long num) Returns double equivalent of the IEEE-compatible,
double-precision bit pattern specified by num.
long longValue( ) Returns the value of the invoking object as a long.
static double parseDouble(String str)
throws NumberFormatException Returns the double equivalent of the number contained
in the string specified by str using radix 10.
short shortValue( ) Returns the value of the invoking object as a short.
static String toHexString(double num) Returns a string containing the value of num in
hexadecimal format.
String toString( ) Returns the string equivalent of the invoking object.
static String toString(double num) Returns the string equivalent of the value specified
by num.
static Double valueOf(double num) Returns a Double object containing the value passed
in num.
static Double valueOf(String str)
throws NumberFormatException Returns a Double object that contains the value
specified by the string in str.
T ABLE 16-2
The Methods Defined by Double (continued)
The following example creates two Double objects—one by using a double value and
the other by passing a string that can be parsed as a double:
class DoubleDemo 
As you can see from the following output, both constructors created identical Double instances,
as shown by the equals( ) method returning true:
3.14159 = 3.14159 –> true
389390
Part II:
The Java Library
Understanding isInfinite( ) and isNaN( )
Float and Double provide the methods isInfinite( ) and isNaN( ), which help when
manipulating two special double and float values. These methods test for two unique
values defined by the IEEE floating-point specification: infinity and NaN (not a number).
isInfinite( ) returns true if the value being tested is infinitely large or small in magnitude.
isNaN( ) returns true if the value being tested is not a number.
The following example creates two Double objects; one is infinite, and the other is not
a number:
// Demonstrate isInfinite() and isNaN()
class InfNaN 
This program generates the following output:
Infinity: true, false
NaN: false, true
Byte, Short, Integer, and Long
The Byte, Short, Integer, and Long classes are wrappers for byte, short, int, and long integer
types, respectively. Their constructors are shown here:
Byte(byte num)
Byte(String str) throws NumberFormatException
Short(short num)
Short(String str) throws NumberFormatException
Integer(int num)
Integer(String str) throws NumberFormatException
Long(long num)
Long(String str) throws NumberFormatException
As you can see, these objects can be constructed from numeric values or from strings that
contain valid whole number values.
The methods defined by these classes are shown in Tables 16-3 through 16-6. As you
can see, they define methods for parsing integers from strings and converting strings back
into integers. Variants of these methods allow you to specify the radix, or numeric base, for
conversion. Common radixes are 2 for binary, 8 for octal, 10 for decimal, and 16 for hexadecimal.Chapter 16:
Exploring java.lang
The following constants are defined:
MIN_VALUE Minimum value
MAX_VALUE Maximum value
SIZE The bit width of the wrapped value
TYPE The Class object for byte, short, int, or long
Method Description
byte byteValue( ) Returns the value of the invoking object as a byte.
int compareTo(Byte b) Compares the numerical value of the invoking object
with that of b. Returns 0 if the values are equal.
Returns a negative value if the invoking object has a
lower value. Returns a positive value if the invoking
object has a greater value.
static Byte decode(String str)
throws NumberFormatException Returns a Byte object that contains the value
specified by the string in str.
double doubleValue( ) Returns the value of the invoking object as a double.
boolean equals(Object ByteObj) Returns true if the invoking Byte object is
equivalent to ByteObj. Otherwise, it returns false.
float floatValue( ) Returns the value of the invoking object as a float.
int hashCode( ) Returns the hash code for the invoking object.
int intValue( ) Returns the value of the invoking object as an int.
long longValue( ) Returns the value of the invoking object as a long.
static byte parseByte(String str)
throws NumberFormatException Returns the byte equivalent of the number contained
in the string specified by str using radix 10.
static byte parseByte(String str, int radix)
throws NumberFormatException Returns the byte equivalent of the number contained
in the string specified by str using the specified radix.
short shortValue( ) Returns the value of the invoking object as a short.
String toString( ) Returns a string that contains the decimal equivalent
of the invoking object.
static String toString(byte num) Returns a string that contains the decimal equivalent
of num.
static Byte valueOf(byte num) Returns a Byte object containing the value passed
in num.
static Byte valueOf(String str)
throws NumberFormatException Returns a Byte object that contains the value
specified by the string in str.
static Byte valueOf(String str, int radix)
throws NumberFormatException Returns a Byte object that contains the value
specified by the string in str using the specified radix.
T ABLE 16-3
The Methods Defined by Byte
391392
Part II:
The Java Library
Method Description
byte byteValue( ) Returns the value of the invoking object as a byte.
int compareTo(Short s) Compares the numerical value of the invoking object
with that of s. Returns 0 if the values are equal.
Returns a negative value if the invoking object has a
lower value. Returns a positive value if the invoking
object has a greater value.
static Short decode(String str)
throws NumberFormatException Returns a Short object that contains the value
specified by the string in str.
double doubleValue( ) Returns the value of the invoking object as a double.
boolean equals(Object ShortObj) Returns true if the invoking Short object is equivalent
to ShortObj. Otherwise, it returns false.
float floatValue( ) Returns the value of the invoking object as a float.
int hashCode( ) Returns the hash code for the invoking object.
int intValue( ) Returns the value of the invoking object as an int.
long longValue( ) Returns the value of the invoking object as a long.
static short parseShort(String str)
throws NumberFormatException Returns the short equivalent of the number contained
in the string specified by str using radix 10.
static short parseShort(String str, int radix) Returns the short equivalent of the number contained
throws NumberFormatException
in the string specified by str using the specified radix.
static short reverseBytes(short num) Exchanges the high- and low-order bytes of num
and returns the result.
short shortValue( ) Returns the value of the invoking object as a short.
String toString( ) Returns a string that contains the decimal
equivalent of the invoking object.
static String toString(short num) Returns a string that contains the decimal
equivalent of num.
static Short valueOf(short num) Returns a Short object containing the value passed
in num.
static Short valueOf(String str)
throws NumberFormatException Returns a Short object that contains the value
specified by the string in str using radix 10.
static Short valueOf(String str, int radix)
throws NumberFormatException Returns a Short object that contains the value
specified by the string in str using the specified radix.
T ABLE 16-4
The Methods Defined by ShortChapter 16:
Exploring java.lang
Method Description
static int bitCount(int num) Returns the number of set bits in num.
byte byteValue( ) Returns the value of the invoking object as a byte.
int compareTo(Integer i) Compares the numerical value of the invoking object
with that of i. Returns 0 if the values are equal.
Returns a negative value if the invoking object has a
lower value. Returns a positive value if the invoking
object has a greater value.
static Integer decode(String str)
throws NumberFormatException Returns an Integer object that contains the value
specified by the string in str.
double doubleValue( ) Returns the value of the invoking object as a double.
boolean equals(Object IntegerObj) Returns true if the invoking Integer object is
equivalent to IntegerObj. Otherwise, it returns false.
float floatValue( ) Returns the value of the invoking object as a float.
static Integer
getInteger(String propertyName) Returns the value associated with the environmental
property specified by propertyName. A null is
returned on failure.
static Integer
getInteger(String propertyName,
int default) Returns the value associated with the environmental
property specified by propertyName. The value of
default is returned on failure.
static Integer
getInteger(String propertyName,
Integer default) Returns the value associated with the environmental
property specified by propertyName. The value of
default is returned on failure.
int hashCode( ) Returns the hash code for the invoking object.
static int highestOneBit(int num) Determines the position of the highest order set bit
in num. It returns a value in which only this bit is set.
If no bit is set to one, then zero is returned.
int intValue( ) Returns the value of the invoking object as an int.
long longValue( ) Returns the value of the invoking object as a long.
static int lowestOneBit(int num) Determines the position of the lowest order set bit in
num. It returns a value in which only this bit is set. If
no bit is set to one, then zero is returned.
static int numberOfLeadingZeros(int num) Returns the number of high-order zero bits that precede
the first high-order set bit in num. If num is zero, 32 is
returned.
T ABLE 16-5
The Methods Defined by Integer
393394
Part II:
The Java Library
Method Description
static int numberOfTrailingZeros(int num) Returns the number of low-order zero bits that
precede the first low-order set bit in num. If num is
zero, 32 is returned.
static int parseInt(String str)
throws NumberFormatException Returns the integer equivalent of the number contained
in the string specified by str using radix 10.
static int parseInt(String str, int radix)
throws NumberFormatException Returns the integer equivalent of the number
contained in the string specified by str using the
specified radix.
static int reverse(int num) Reverses the order of the bits in num and returns
the result.
static int reverseBytes(int num) Reverses the order of the bytes in num and returns
the result.
static int rotateLeft(int num, int n) Returns the result of rotating num left n positions.
static int rotateRight(int num, int n) Returns the result of rotating num right n positions.
static int signum(int num) Returns –1 if num is negative, 0 if it is zero, and 1
if it is positive.
short shortValue( ) Returns the value of the invoking object as a short.
static String toBinaryString(int num) Returns a string that contains the binary equivalent
of num.
static String toHexString(int num) Returns a string that contains the hexadecimal
equivalent of num.
static String toOctalString(int num) Returns a string that contains the octal equivalent
of num.
String toString( ) Returns a string that contains the decimal equivalent
of the invoking object.
static String toString(int num) Returns a string that contains the decimal equivalent
of num.
static String toString(int num, int radix) Returns a string that contains the decimal equivalent
of num using the specified radix.
static Integer valueOf(int num) Returns an Integer object containing the value passed
in num.
static Integer valueOf(String str)
throws NumberFormatException Returns an Integer object that contains the value
specified by the string in str.
static Integer valueOf(String str, int radix)
throws NumberFormatException Returns an Integer object that contains the value
specified by the string in str using the specified radix.
T ABLE 16-5
The Methods Defined by Integer (continued)Chapter 16:
Exploring java.lang
Method Description
static int bitCount(long num) Returns the number of set bits in num.
byte byteValue( ) Returns the value of the invoking object as a byte.
int compareTo(Long l) Compares the numerical value of the invoking object
with that of l. Returns 0 if the values are equal.
Returns a negative value if the invoking object has a
lower value. Returns a positive value if the invoking
object has a greater value.
static Long decode(String str)
throws NumberFormatException Returns a Long object that contains the value
specified by the string in str.
double doubleValue( ) Returns the value of the invoking object as a double.
boolean equals(Object LongObj) Returns true if the invoking Long object is equivalent
to LongObj. Otherwise, it returns false.
float floatValue( ) Returns the value of the invoking object as a float.
static Long getLong(String propertyName) Returns the value associated with the environmental
property specified by propertyName. A null is returned
on failure.
static Long getLong(String propertyName,
long default) Returns the value associated with the environmental
property specified by propertyName. The value of
default is returned on failure.
static Long getLong(String propertyName,
Long default) Returns the value associated with the environmental
property specified by propertyName. The value of
default is returned on failure.
int hashCode( ) Returns the hash code for the invoking object.
static long highestOneBit(long num) Determines the position of the highest-order set bit
in num. It returns a value in which only this bit is
set. If no bit is set to one, then zero is returned.
int intValue( ) Returns the value of the invoking object as an int.
long longValue( ) Returns the value of the invoking object as a long.
static long lowestOneBit(long num) Determines the position of the lowest-order set bit
in num. It returns a value in which only this bit is
set. If no bit is set to one, then zero is returned.
static int numberOfLeadingZeros(long num) Returns the number of high-order zero bits that
precede the first high-order set bit in num. If num
is zero, 64 is returned.
static int numberOfTrailingZeros(long num) Returns the number of low-order zero bits that
precede the first low-order set bit in num. If num
is zero, 64 is returned.
T ABLE 16-6
The Methods Defined by Long
395396
Part II:
The Java Library
Method Description
static long parseLong(String str)
throws NumberFormatException Returns the long equivalent of the number
contained in the string specified by str in radix 10.
static long parseLong(String str, int radix)
throws NumberFormatException Returns the long equivalent of the number contained
in the string specified by str using the specified radix.
static long reverse(long num) Reverses the order of the bits in num and returns
the result.
static long reverseBytes(long num) Reverses the order of the bytes in num and returns
the result.
static long rotateLeft(long num, int n) Returns the result of rotating num left n positions.
static long rotateRight(long num, int n) Returns the result of rotating num right n positions.
static int signum(long num) Returns –1 if num is negative, 0 if it is zero, and 1 if
it is positive.
short shortValue( ) Returns the value of the invoking object as a short.
static String toBinaryString(long num) Returns a string that contains the binary equivalent
of num.
static String toHexString(long num) Returns a string that contains the hexadecimal
equivalent of num.
static String toOctalString(long num) Returns a string that contains the octal equivalent
of num.
String toString( ) Returns a string that contains the decimal equivalent
of the invoking object.
static String toString(long num) Returns a string that contains the decimal equivalent
of num.
static String toString(long num, int radix) Returns a string that contains the decimal equivalent
of num using the specified radix.
static Long valueOf(long num) Returns a Long object containing the value passed
in num.
static Long valueOf(String str)
throws NumberFormatException Returns a Long object that contains the value
specified by the string in str.
static Long valueOf(String str, int radix)
throws NumberFormatException Returns a Long object that contains the value
specified by the string in str using the specified radix.
T ABLE 16-6
The Methods Defined by Long (continued)
Converting Numbers to and from Strings
One of the most common programming chores is converting the string representation of a
number into its internal, binary format. Fortunately, Java provides an easy way to accomplish
this. The Byte, Short, Integer, and Long classes provide the parseByte( ), parseShort( ),
parseInt( ), and parseLong( ) methods, respectively. These methods return the byte, short,Chapter 16:
Exploring java.lang
int, or long equivalent of the numeric string with which they are called. (Similar methods
also exist for the Float and Double classes.)
The following program demonstrates parseInt( ). It sums a list of integers entered by the
user. It reads the integers using readLine( ) and uses parseInt( ) to convert these strings into
their int equivalents.
/* This program sums a list of numbers entered
by the user. It converts the string representation
of each number into an int using parseInt().
*/
import java.io.*;
class ParseDemo 
To convert a whole number into a decimal string, use the versions of toString( ) defined
in the Byte, Short, Integer, or Long classes. The Integer and Long classes also provide the
methods toBinaryString( ), toHexString( ), and toOctalString( ), which convert a value into
a binary, hexadecimal, or octal string, respectively.
The following program demonstrates binary, hexadecimal, and octal conversion:
/* Convert an integer into binary, hexadecimal,
and octal.
*/
class StringConversions 
The output of this program is shown here:
19648 in binary: 100110011000000
19648 in octal: 46300
19648 in hexadecimal: 4cc0
Character
Character is a simple wrapper around a char. The constructor for Character is
Character(char ch)
Here, ch specifies the character that will be wrapped by the Character object being created.
To obtain the char value contained in a Character object, call charValue( ), shown here:
char charValue( )
It returns the character.
The Character class defines several constants, including the following:
MAX_RADIX The largest radix
MIN_RADIX The smallest radix
MAX_VALUE The largest character value
MIN_VALUE The smallest character value
TYPE The Class object for char
Character includes several static methods that categorize characters and alter their case. They
are shown in Table 16-7. The following example demonstrates several of these methods:
// Demonstrate several Is... methods.
class IsDemo 
The output from this program is shown here:
a
a
b
b
5
A
A
is
is
is
is
is
is
is
is
a letter.
lowercase.
a letter.
lowercase.
a digit.
a letter.
uppercase.
whitespace.
Method Description
static boolean isDefined(char ch) Returns true if ch is defined by Unicode.
Otherwise, it returns false.
static boolean isDigit(char ch) Returns true if ch is a digit. Otherwise, it returns
false.
static boolean isIdentifierIgnorable(char ch) Returns true if ch should be ignored in an
identifier. Otherwise, it returns false.
static boolean isISOControl(char ch) Returns true if ch is an ISO control character.
Otherwise, it returns false.
static boolean isJavaIdentifierPart(char ch) Returns true if ch is allowed as part of a Java
identifier (other than the first character).
Otherwise, it returns false.
static boolean isJavaIdentifierStart(char ch) Returns true if ch is allowed as the first character
of a Java identifier. Otherwise, it returns false.
static boolean isLetter(char ch) Returns true if ch is a letter. Otherwise, it returns
false.
static boolean isLetterOrDigit(char ch) Returns true if ch is a letter or a digit. Otherwise,
it returns false.
static boolean isLowerCase(char ch) Returns true if ch is a lowercase letter. Otherwise,
it returns false.
T ABLE 16-7
Various Character Methods
399400
Part II:
The Java Library
Method Description
static boolean isMirrored(char ch) Returns true if ch is a mirrored Unicode character.
A mirrored character is one that is reversed for text
that is displayed right-to-left.
static boolean isSpaceChar(char ch) Returns true if ch is a Unicode space character.
Otherwise, it returns false.
static boolean isTitleCase(char ch) Returns true if ch is a Unicode titlecase character.
Otherwise, it returns false.
static boolean
isUnicodeIdentifierPart(char ch) Returns true if ch is allowed as part of a Unicode
identifier (other than the first character).
Otherwise, it returns false.
static boolean
isUnicodeIdentifierStart(char ch) Returns true if ch is allowed as the first character
of a Unicode identifier. Otherwise, it returns false.
static boolean isUpperCase(char ch) Returns true if ch is an uppercase letter.
Otherwise, it returns false.
static boolean isWhitespace(char ch) Returns true if ch is whitespace. Otherwise, it
returns false.
static char toLowerCase(char ch) Returns lowercase equivalent of ch.
static char toTitleCase(char ch) Returns titlecase equivalent of ch.
static char toUpperCase(char ch) Returns uppercase equivalent of ch.
T ABLE 16-7
Various Character Methods (continued)
Character defines two methods, forDigit( ) and digit( ), that enable you to convert
between integer values and the digits they represent. They are shown here:
static char forDigit(int num, int radix)
static int digit(char digit, int radix)
forDigit( ) returns the digit character associated with the value of num. The radix of the
conversion is specified by radix. digit( ) returns the integer value associated with the specified
character (which is presumably a digit) according to the specified radix.
Another method defined by Character is compareTo( ), which has the following form:
int compareTo(Character c)
It returns zero if the invoking object and c have the same value. It returns a negative value
if the invoking object has a lower value. Otherwise, it returns a positive value.
Character includes a method called getDirectionality( ) which can be used to determine
the direction of a character. Several constants are defined that describe directionality. Most programs
will not need to use character directionality.
Character also overrides the equals( ) and hashCode( ) methods.
Two other character-related classes are Character.Subset, used to describe a subset of
Unicode, and Character.UnicodeBlock, which contains Unicode character blocks.Chapter 16:
Exploring java.lang
Recent Additions to Character for Unicode Code Point Support
Recently, major additions have been made to Character. Beginning with JDK 5, the Character
class has included support for 32-bit Unicode characters. In the past, all Unicode characters
could be held by 16 bits, which is the size of a char (and the size of the value encapsulated
within a Character), because those values ranged from 0 to FFFF. However, the Unicode
character set has been expanded, and more than 16 bits are required. Characters can now range
from 0 to 10FFFF.
Here are two important terms: code point and supplemental character. A code point is a
character in the range 0 to 10FFFF. Characters that have values greater than FFFF are
called supplemental characters.
The expansion of the Unicode character set caused a fundamental problem for Java. Because
a supplemental character has a value greater than a char can hold, some means of handling
the supplemental characters was needed. Java addressed this problem two ways. First,
Java uses two chars to represent a supplemental character. The first char is called the high
surrogate, and the second is called the low surrogate. New methods, such as codePointAt( ),
were provided to translate between code points and supplemental characters.
Secondly, Java overloaded several preexisting methods in the Character class. The
overloaded forms use int rather than char data. Because an int is large enough to hold any
character as a single value, it can be used to store any character. For example, all of the methods
in Table 16-7 have overloaded forms that operate on int. Here is a sampling:
static boolean isDigit(int cp)
static boolean isLetter(int cp)
static int toLowerCase(int cp)
In addition to the methods overloaded to accept code points, Character adds methods
that provide additional support for code points. A sampling is shown in Table 16-8.
Method Description
static int charCount(int cp) Returns 1 if cp can be represented by a single
char. It returns 2 if two chars are needed.
static int
codePointAt(CharSequence chars, int loc) Returns the code point at the location specified
by loc.
static int codePointAt(char chars[ ], int loc) Returns the code point at the location specified
by loc.
static int
Returns the code point at the location that
codePointBefore(CharSequence chars, int loc) precedes that specified by loc.
static int
codePointBefore(char chars[ ], int loc) Returns the code point at the location that
precedes that specified by loc.
static boolean isHighSurrogate(char ch) Returns true if ch contains a valid high surrogate
character.
T ABLE 16-8
A Sampling of Methods That Provide Support for 32-Bit Unicode Code Points
401402
Part II:
The Java Library
Method Description
static boolean isLowSurrogate(char ch) Returns true if ch contains a valid low
surrogate character.
static boolean
isSupplementaryCodePoint(int cp) Returns true if cp contains a supplemental
character.
static boolean
isSurrogatePair(char highCh, char lowCh) Returns true if highCh and lowCh form a valid
surrogate pair.
static boolean isValidCodePoint(int cp) Returns true if cp contains a valid code point.
static char[ ] toChars(int cp) Converts the code point in cp into its char
equivalent, which might require two chars.
An array holding the result is returned.
static int
toChars(int cp, char target[ ], int loc) Converts the code point in cp into its char
equivalent, storing the result in target, beginning
at loc. Returns 1 if cp can be represented by a
single char. It returns 2 otherwise.
static int
toCodePoint(char highCh, char lowCh) Converts highCh and lowCh into their equivalent
code point.
T ABLE 16-8
A Sampling of Methods That Provide Support for 32-Bit Unicode Code Points (continued)
Boolean
Boolean is a very thin wrapper around boolean values, which is useful mostly when you
want to pass a boolean variable by reference. It contains the constants TRUE and FALSE,
which define true and false Boolean objects. Boolean also defines the TYPE field, which is
the Class object for boolean. Boolean defines these constructors:
Boolean(boolean boolValue)
Boolean(String boolString)
In the first version, boolValue must be either true or false. In the second version, if boolString
contains the string “true” (in uppercase or lowercase), then the new Boolean object will be
true. Otherwise, it will be false.
Boolean defines the methods shown in Table 16-9.
Method Description
boolean booleanValue( ) Returns boolean equivalent.
int compareTo(Boolean b) Returns zero if the invoking object and b contain the
same value. Returns a positive value if the invoking
object is true and b is false. Otherwise, returns a
negative value.
boolean equals(Object boolObj) Returns true if the invoking object is equivalent to
boolObj. Otherwise, it returns false.
T ABLE 16-9
The Methods Defined by BooleanChapter 16:
Exploring java.lang
Method Description
static boolean
getBoolean(String propertyName) Returns true if the system property specified by
propertyName is true. Otherwise, it returns false.
int hashCode( ) Returns the hash code for the invoking object.
static boolean parseBoolean(String str) Returns true if str contains the string “true”. Case is
not significant. Otherwise, returns false.
String toString( ) Returns the string equivalent of the invoking object.
static String toString(boolean boolVal) Returns the string equivalent of boolVal.
static Boolean valueOf(boolean boolVal) Returns the Boolean equivalent of boolVal.
static Boolean valueOf(String boolString) Returns true if boolString contains the string “true” (in
uppercase or lowercase). Otherwise, it returns false.
T ABLE 16-9
The Methods Defined by Boolean (continued)
Void
The Void class has one field, TYPE, which holds a reference to the Class object for type void.
You do not create instances of this class.
Process
The abstract Process class encapsulates a process—that is, an executing program. It is used
primarily as a superclass for the type of objects created by exec( ) in the Runtime class, or
by start( ) in the ProcessBuilder class. Process contains the abstract methods shown in
Table 16-10.
Method
Description
void destroy( ) Terminates the process.
int exitValue( ) Returns an exit code obtained from a subprocess.
InputStream getErrorStream( ) Returns an input stream that reads input from the process’
err output stream.
InputStream getInputStream( ) Returns an input stream that reads input from the process’
out output stream.
OutputStream getOutputStream( ) Returns an output stream that writes output to the process’
in input stream.
int waitFor( )
throws InterruptedException Returns the exit code returned by the process. This method
does not return until the process on which it is called
terminates.
T ABLE 16-10
The Methods Defined by Process
403404
Part II:
The Java Library
Runtime
The Runtime class encapsulates the run-time environment. You cannot instantiate a Runtime
object. However, you can get a reference to the current Runtime object by calling the static
method Runtime.getRuntime( ). Once you obtain a reference to the current Runtime object,
you can call several methods that control the state and behavior of the Java Virtual Machine.
Applets and other untrusted code typically cannot call any of the Runtime methods without
raising a SecurityException. Commonly used methods defined by Runtime are shown in
Table 16-11.
Method Description
void addShutdownHook(Thread thrd) Registers thrd as a thread to be run when the Java
Virtual Machine terminates.
Process exec(String progName)
throws IOException Executes the program specified by progName as a
separate process. An object of type Process is
returned that describes the new process.
Process exec(String progName,
String environment[ ])
throws IOException Executes the program specified by progName as a
separate process with the environment specified by
environment. An object of type Process is returned
that describes the new process.
Process exec(String comLineArray[ ])
throws IOException Executes the command line specified by the strings in
comLineArray as a separate process. An object of type
Process is returned that describes the new process.
Process exec(String comLineArray[ ],
String environment[ ])
throws IOException Executes the command line specified by the strings
in comLineArray as a separate process with the
environment specified by environment. An object of type
Process is returned that describes the new process.
void exit(int exitCode) Halts execution and returns the value of exitCode to
the parent process. By convention, 0 indicates normal
termination. All other values indicate some form of error.
long freeMemory( ) Returns the approximate number of bytes of free
memory available to the Java run-time system.
void gc( ) Initiates garbage collection.
static Runtime getRuntime( ) Returns the current Runtime object.
void halt(int code) Immediately terminates the Java Virtual Machine. No
termination threads or finalizers are run. The value of
code is returned to the invoking process.
void load(String libraryFileName) Loads the dynamic library whose file is specified by
libraryFileName, which must specify its complete path.
void loadLibrary(String libraryName) Loads the dynamic library whose name is associated
with libraryName.
T ABLE 16-11
A Sampling of Methods Defined by RuntimeChapter 16:
Exploring java.lang
Method Description
boolean
removeShutdownHook(Thread thrd) Removes thrd from the list of threads to run when
the Java Virtual Machine terminates. It returns true if
successful—that is, if the thread was removed.
void runFinalization( ) Initiates calls to the finalize( ) methods of unused but
not yet recycled objects.
long totalMemory( ) Returns the total number of bytes of memory available
to the program.
void traceInstructions(boolean traceOn) Turns on or off instruction tracing, depending upon
the value of traceOn. If traceOn is true, the trace is
displayed. If it is false, tracing is turned off.
void traceMethodCalls(boolean traceOn) Turns on or off method call tracing, depending upon
the value of traceOn. If traceOn is true, the trace is
displayed. If it is false, tracing is turned off.
T ABLE 16-11
A Sampling of Methods Defined by Runtime (continued)
Let’s look at two of the most common uses of the Runtime class: memory management
and executing additional processes.
Memory Management
Although Java provides automatic garbage collection, sometimes you will want to know
how large the object heap is and how much of it is left. You can use this information, for
example, to check your code for efficiency or to approximate how many more objects
of a certain type can be instantiated. To obtain these values, use the totalMemory( ) and
freeMemory( ) methods.
As mentioned in Part I, Java’s garbage collector runs periodically to recycle unused objects.
However, sometimes you will want to collect discarded objects prior to the collector’s next
appointed rounds. You can run the garbage collector on demand by calling the gc( ) method.
A good thing to try is to call gc( ) and then call freeMemory( ) to get a baseline memory usage.
Next, execute your code and call freeMemory( ) again to see how much memory it is allocating.
The following program illustrates this idea:
// Demonstrate totalMemory(), freeMemory() and gc().
class MemoryDemo 
Sample output from this program is shown here (of course, your actual results may vary):
Total memory is: 1048568
Initial free memory: 751392
Free memory after garbage collection: 841424
Free memory after allocation: 824000
Memory used by allocation: 17424
Free memory after collecting discarded Integers: 842640
Executing Other Programs
In safe environments, you can use Java to execute other heavyweight processes (that is,
programs) on your multitasking operating system. Several forms of the exec( ) method
allow you to name the program you want to run as well as its input parameters. The exec( )
method returns a Process object, which can then be used to control how your Java program
interacts with this new running process. Because Java can run on a variety of platforms and
under a variety of operating systems, exec( ) is inherently environment-dependent.
The following example uses exec( ) to launch notepad, Windows’ simple text editor.
Obviously, this example must be run under the Windows operating system.
// Demonstrate exec().
class ExecDemo 
There are several alternative forms of exec( ), but the one shown in the example is the most
common. The Process object returned by exec( ) can be manipulated by Process’ methods after
the new program starts running. You can kill the subprocess with the destroy( ) method. The
waitFor( ) method causes your program to wait until the subprocess finishes. The exitValue( )
method returns the value returned by the subprocess when it is finished. This is typically 0
if no problems occur. Here is the preceding exec( ) example modified to wait for the running
process to exit:
// Wait until notepad is terminated.
class ExecDemoFini 
While a subprocess is running, you can write to and read from its standard input and
output. The getOutputStream( ) and getInputStream( ) methods return the handles to
standard in and out of the subprocess. (I/O is examined in detail in Chapter 19.)
ProcessBuilder
ProcessBuilder provides another way to start and manage processes (that is, programs). As
explained earlier, all processes are represented by the Process class, and a process can be
started by Runtime.exec( ). ProcessBuilder offers more control over the processes. For
example, you can set the current working directory and change environmental parameters.
ProcessBuilder defines these constructors:
ProcessBuilder(List<String> args)
ProccessBuilder(String ... args)
Here, args is a list of arguments that specify the name of the program to be executed along
with any required command-line arguments. In the first constructor, the arguments are
passed in a List. In the second, they are specified through a varargs parameter. Table 16-12
describes the methods defined by ProcessBuilder.
407408
Part II:
The Java Library
To create a process using ProcessBuilder, simply create an instance of ProcessBuilder,
specifying the name of the program and any needed arguments. To begin execution of the
program, call start( ) on that instance. Here is an example that executes the Windows text
editor notepad. Notice that it specifies the name of the file to edit as an argument.
class PBDemo 
Method Description
List<String> command( ) Returns a reference to a List that contains the
name of the program and its arguments. Changes
to this list affect the invoking process.
ProcessBuilder command(List<String> args) Sets the name of the program and its arguments
to those specified by args. Changes to this list
affect the invoking process. Returns a reference to
the invoking object.
ProcessBuilder command(String ... args) Sets the name of the program and its arguments
to those specified by args. Returns a reference to
the invoking object.
File directory( ) Returns the current working directory of the invoking
object. This value will be null if the directory is the
same as that of the Java program that started the
process.
ProcessBuilder directory(File dir) Sets the current working directory of the invoking
object. Returns a reference to the invoking object.
Map<String, String> environment( ) Returns the environmental variables associated
with the invoking object as key/value pairs.
boolean redirectErrorStream( ) Returns true if the standard error stream has been
redirected to the standard output stream. Returns
false if the streams are separate.
ProcessBuilder
redirectErrorStream(boolean merge) If merge is true, then the standard error stream is
redirected to standard output. If merge is false,
the streams are separated, which is the default
state. Returns a reference to the invoking object.
Process start( )
throws IOException Begins the process specified by the invoking object.
In other words, it runs the specified program.
T ABLE 16-12
The Methods Defined by ProcessBuilderChapter 16:
Exploring java.lang
System
The System class holds a collection of static methods and variables. The standard input,
output, and error output of the Java run time are stored in the in, out, and err variables.
The methods defined by System are shown in Table 16-13. Many of the methods throw
a SecurityException if the operation is not permitted by the security manager.
Let’s look at some common uses of System.
Method Description
static void arraycopy(Object source,
int sourceStart,
Object target,
int targetStart,
int size) Copies an array. The array to be copied is passed
in source, and the index at which point the copy will
begin within source is passed in sourceStart. The
array that will receive the copy is passed in target,
and the index at which point the copy will begin
within target is passed in targetStart. size is the
number of elements that are copied.
static String clearProperty(String which) Deletes the environmental variable specified by
which. The previous value associated with which
is returned.
static Console console ( ) Returns the console associated with the JVM. null is
returned if the JVM currently has no console. (Added
by Java SE 6.)
static long currentTimeMillis( ) Returns the current time in terms of milliseconds
since midnight, January 1, 1970.
static void exit(int exitCode) Halts execution and returns the value of exitCode to
the parent process (usually the operating system).
By convention, 0 indicates normal termination. All
other values indicate some form of error.
static void gc( ) Initiates garbage collection.
static Map<String, String> getenv( ) Returns a Map that contains the current environmental
variables and their values.
static String getenv(String which) Returns the value associated with the environmental
variable passed in which.
static Properties getProperties( ) Returns the properties associated with the Java
run-time system. (The Properties class is described
in Chapter 17.)
static String getProperty(String which) Returns the property associated with which. A null
object is returned if the desired property is not found.
static String getProperty(String which,
String default) Returns the property associated with which. If the
desired property is not found, default is returned.
static SecurityManager
getSecurityManager( ) Returns the current security manager or a null
object if no security manager is installed.
static int identityHashCode(Object obj) Returns the identity hash code for obj.
T ABLE 16-13
The Methods Defined by System
409410
Part II:
The Java Library
Method Description
static Channel inheritedChannel( )
throws IOException Returns the channel inherited by the Java Virtual
Machine. Returns null if no channel is inherited.
static void load(String libraryFileName) Loads the dynamic library whose file is specified by
libraryFileName, which must specify its complete path.
static void loadLibrary(String libraryName) Loads the dynamic library whose name is
associated with libraryName.
static String mapLibraryName(String lib) Returns a platform-specific name for the library
named lib.
static long nanoTime( ) Obtains the most precise timer in the system and
returns its value in terms of nanoseconds since
some arbitrary starting point. The accuracy of the
timer is unknowable.
static void runFinalization( ) Initiates calls to the finalize( ) methods of unused
but not yet recycled objects.
static void setErr(PrintStream eStream) Sets the standard err stream to eStream.
static void setIn(InputStream iStream) Sets the standard in stream to iStream.
static void setOut(PrintStream oStream) Sets the standard out stream to oStream.
static void
Sets the current system properties as specified by
setProperties(Properties sysProperties) sysProperties.
static String setProperty(String which,
String v) Assigns the value v to the property named which.
static void setSecurityManager(
SecurityManager secMan) Sets the security manager to that specified by
secMan.
T ABLE 16-13
The Methods Defined by System (continued)
Using currentTimeMillis( ) to Time Program Execution
One use of the System class that you might find particularly interesting is to use the
currentTimeMillis( ) method to time how long various parts of your program take to execute.
The currentTimeMillis( ) method returns the current time in terms of milliseconds since
midnight, January 1, 1970. To time a section of your program, store this value just before
beginning the section in question. Immediately upon completion, call currentTimeMillis( )
again. The elapsed time will be the ending time minus the starting time. The following
program demonstrates this:
// Timing program execution.
class Elapsed 
Here is a sample run (remember that your results probably will differ):
Timing a for loop from 0 to 1,000,000
Elapsed time: 10
If your system has a timer that offers nanosecond precision, then you could rewrite the
preceding program to use nanoTime( ) rather than currentTimeMillis( ). For example, here
is the key portion of the program rewritten to use nanoTime( ):
start = System.nanoTime(); // get starting time
for(int i=0; i < 1000000; i++) ;
end = System.nanoTime(); // get ending time
Using arraycopy( )
The arraycopy( ) method can be used to copy quickly an array of any type from one place to
another. This is much faster than the equivalent loop written out longhand in Java. Here is
an example of two arrays being copied by the arraycopy( ) method. First, a is copied to b.
Next, all of a’s elements are shifted down by one. Then, b is shifted up by one.
// Using arraycopy().
class ACDemo 
As you can see from the following output, you can copy using the same source and destination
in either direction:
a = ABCDEFGHIJ
b = MMMMMMMMMM
411412
Part II:
a
b
a
b
=
=
=
=
The Java Library
ABCDEFGHIJ
ABCDEFGHIJ
AABCDEFGHI
BCDEFGHIJJ
Environment Properties
The following properties are available:
file.separator java.specification.version java.vm.version
java.class.path java.vendor line.separator
java.class.version java.vendor.url os.arch
java.compiler java.version os.name
java.ext.dirs java.vm.name os.version
java.home java.vm.specification.name path.separator
java.io.tmpdir java.vm.specification.vendor user.dir
java.library.path java.vm.specification.version user.home
java.specification.name java.vm.vendor user.name
java.specification.vendor
You can obtain the values of various environment variables by calling the
System.getProperty( ) method. For example, the following program displays the
path to the current user directory:
class ShowUserDir 
Object
As mentioned in Part I, Object is a superclass of all other classes. Object defines the
methods shown in Table 16-14, which are available to every object.
Method Description
Object clone( )
throws
CloneNotSupportedException Creates a new object that is the same as the
invoking object.
boolean equals(Object object) Returns true if the invoking object is equivalent to
object.
void finalize( )
throws Throwable Default finalize( ) method. This is usually overridden
by subclasses.
T ABLE 16-14
The Methods Defined by ObjectChapter 16:
Exploring java.lang
Method Description
final Class<?> getClass( ) Obtains a Class object that describes the invoking
object.
int hashCode( ) Returns the hash code associated with the invoking
object.
final void notify( ) Resumes execution of a thread waiting on the
invoking object.
final void notifyAll( ) Resumes execution of all threads waiting on the
invoking object.
String toString( ) Returns a string that describes the object.
final void wait( )
throws InterruptedException Waits on another thread of execution.
final void wait(long milliseconds)
throws InterruptedException Waits up to the specified number of milliseconds on
another thread of execution.
final void wait(long milliseconds,
int nanoseconds)
throws InterruptedException Waits up to the specified number of milliseconds
plus nanoseconds on another thread of execution.
T ABLE 16-14
The Methods Defined by Object (continued)
Using clone( ) and the Cloneable Interface
Most of the methods defined by Object are discussed elsewhere in this book. However, one
deserves special attention: clone( ). The clone( ) method generates a duplicate copy of the
object on which it is called. Only classes that implement the Cloneable interface can be cloned.
The Cloneable interface defines no members. It is used to indicate that a class allows a
bitwise copy of an object (that is, a clone) to be made. If you try to call clone( ) on a class that
does not implement Cloneable, a CloneNotSupportedException is thrown. When a clone
is made, the constructor for the object being cloned is not called. A clone is simply an exact
copy of the original.
Cloning is a potentially dangerous action, because it can cause unintended side effects.
For example, if the object being cloned contains a reference variable called obRef, then when
the clone is made, obRef in the clone will refer to the same object as does obRef in the original.
If the clone makes a change to the contents of the object referred to by obRef, then it will be
changed for the original object, too. Here is another example: If an object opens an I/O stream
and is then cloned, two objects will be capable of operating on the same stream. Further, if
one of these objects closes the stream, the other object might still attempt to write to it, causing
an error. In some cases, you will need to override the clone( ) method defined by Object to
handle these types of problems.
Because cloning can cause problems, clone( ) is declared as protected inside Object.
This means that it must either be called from within a method defined by the class that
implements Cloneable, or it must be explicitly overridden by that class so that it is public.
Let’s look at an example of each approach.
413414
Part II:
The Java Library
The following program implements Cloneable and defines the method cloneTest( ),
which calls clone( ) in Object:
// Demonstrate the clone() method.
class TestClone implements Cloneable 
class CloneDemo 
Here, the method cloneTest( ) calls clone( ) in Object and returns the result. Notice that the
object returned by clone( ) must be cast into its appropriate type (TestClone).
The following example overrides clone( ) so that it can be called from code outside of its
class. To do this, its access specifier must be public, as shown here:
// Override the clone() method.
class TestClone implements Cloneable 
class CloneDemo2 
The side effects caused by cloning are sometimes difficult to see at first. It is easy to
think that a class is safe for cloning when it actually is not. In general, you should not
implement Cloneable for any class without good reason.
Class
Class encapsulates the run-time state of an object or interface. Objects of type Class are
created automatically, when classes are loaded. You cannot explicitly declare a Class object.
Generally, you obtain a Class object by calling the getClass( ) method defined by Object.
Class is a generic type that is declared as shown here:
class Class<T>
Here, T is the type of the class or interface represented. A sampling of commonly used methods
defined by Class is shown in Table 16-15.
Method Description
static Class<?> forName(String name)
throws ClassNotFoundException Returns a Class object given its complete name.
static Class<?> forName(String name,
boolean how,
ClassLoader ldr)
throws ClassNotFoundException Returns a Class object given its complete name.
The object is loaded using the loader specified by
ldr. If how is true, the object is initialized;
otherwise, it is not.
<A extends Annotation> A
getAnnotation(Class<A> annoType) Returns an Annotation object that contains the
annotation associated with annoType for the
invoking object.
T ABLE 16-15
A Sampling of Methods Defined by Class
415416
Part II:
The Java Library
Method Description
Annotation[ ] getAnnotations( ) Obtains all annotations associated with the invoking
object and stores them in an array of Annotation
objects. Returns a reference to this array.
Class<?>[ ] getClasses( ) Returns a Class object for each of the public classes
and inter faces that are members of the invoking
object.
ClassLoader getClassLoader( ) Returns the ClassLoader object that loaded the class
or interface used to instantiate the invoking object.
Constructor<T>
Returns a Constructor object that represents the
getConstructor(Class<?> ... paramTypes) constructor for the invoking object that has the
throws NoSuchMethodException,
parameter types specified by paramTypes.
SecurityException
Constructor<?>[ ] getConstructors( )
throws SecurityException Obtains a Constructor object for each public
constructor of the invoking object and stores them
in an array. Returns a reference to this array.
Annotation[ ] getDeclaredAnnotations( ) Obtains an Annotation object for all the annotations
that are declared by the invoking object and stores
them in an array. Returns a reference to this array.
(Inherited annotations are ignored.)
Constructor<?>[ ] getDeclaredConstructors( ) Obtains a Constructor object for each constructor
throws SecurityException
declared by the invoking object and stores them in
an array. Returns a reference to this array.
(Superclass constructors are ignored.)
Field[ ] getDeclaredFields( )
throws SecurityException Obtains a Field object for each field declared by
this class and stores them in an array. Returns a
reference to this array. (Inherited fields are ignored.)
Method[ ] getDeclaredMethods( )
throws SecurityException Obtains a Method object for each method declared
by this class or interface and stores them in an
array. Returns a reference to this array. (Inherited
methods are ignored.)
Field getField(String fieldName)
throws NoSuchMethodException,
SecurityException Returns a Field object that represents the field
specified by fieldName for the invoking object.
Field[ ] getFields( )
throws SecurityException Obtains a Field object for each public field of the
invoking object and stores them in an array. Returns
a reference to this array.
Class<?>[ ] getInterfaces( ) When invoked on an object, this method returns
an array of the interfaces implemented by the class
type of the object. When invoked on an interface,
this method returns an array of interfaces extended
by the interface.
T ABLE 16-15
A Sampling of Methods Defined by Class (continued)Chapter 16:
Method
Exploring java.lang
Description
Method getMethod(String methName,
Returns a Method object that represents the
Class<?> ... paramTypes) method specified by methName and having the
throws NoSuchMethodException,
parameter types specified by paramTypes.
SecurityException
Method[ ] getMethods( )
throws SecurityException Obtains a Method object for each public method
of the invoking object and stores them in an array.
Returns a reference to this array.
String getName( ) Returns the complete name of the class or
interface of the invoking object.
ProtectionDomain getProtectionDomain( ) Returns the protection domain associated with the
invoking object.
Class<? super T> getSuperclass( ) Returns the superclass of the invoking object. The
return value is null if the invoking object is of type
Object.
boolean isInterface( ) Returns true if the invoking object is an interface.
Otherwise, it returns false.
T newInstance( )
throws IllegalAccessException,
InstantiationException Creates a new instance (i.e., a new object) that is
of the same type as the invoking object. This is
equivalent to using new with the class’ default
constructor. The new object is returned.
String toString( ) Returns the string representation of the invoking
object or interface.
T ABLE 16-15
A Sampling of Methods Defined by Class (continued)
The methods defined by Class are often useful in situations where run-time type
information about an object is required. As Table 16-15 shows, methods are provided that
allow you to determine additional information about a particular class, such as its public
constructors, fields, and methods. Among other things, this is important for the Java Beans
functionality, which is discussed later in this book.
The following program demonstrates getClass( ) (inherited from Object) and
getSuperclass( ) (from Class):
// Demonstrate Run-Time Type Information.
class X 
class Y extends X 
class RTTI 
The output from this program is shown here:
x is object of type: X
y is object of type: Y
y’s superclass is X
ClassLoader
The abstract class ClassLoader defines how classes are loaded. Your application can create
subclasses that extend ClassLoader, implementing its methods. Doing so allows you to load
classes in some way other than the way they are normally loaded by the Java run-time system.
However, this is not something that you will normally need to do.
Math
The Math class contains all the floating-point functions that are used for geometry and
trigonometry, as well as several general-purpose methods. Math defines two double
constants: E (approximately 2.72) and PI (approximately 3.14).
Transcendental Functions
The following methods accept a double parameter for an angle in radians and return the
result of their respective transcendental function:
Method Description
static double sin(double arg) Returns the sine of the angle specified by arg in radians.
static double cos(double arg) Returns the cosine of the angle specified by arg in radians.
static double tan(double arg) Returns the tangent of the angle specified by arg in radians.Chapter 16:
Exploring java.lang
The next methods take as a parameter the result of a transcendental function and return,
in radians, the angle that would produce that result. They are the inverse of their non-arc
companions.
Method Description
static double asin(double arg) Returns the angle whose sine is specified by arg.
static double acos(double arg) Returns the angle whose cosine is specified by arg.
static double atan(double arg) Returns the angle whose tangent is specified by arg.
static double atan2(double x, double y) Returns the angle whose tangent is x/y.
The next methods compute the hyperbolic sine, cosine, and tangent of an angle.
Method Description
static double sinh(double arg) Returns the hyperbolic sine of the angle specified by arg.
static double cosh(double arg) Returns the hyperbolic cosine of the angle specified by arg.
static double tanh(double arg) Returns the hyperbolic tangent of the angle specified by arg.
Exponential Functions
Math defines the following exponential methods:
Method Description
static double cbrt(double arg) Returns the cube root of arg.
static double exp(double arg) Returns e to the arg.
static double expm1(double arg) Returns e to the arg–1
static double log(double arg) Returns the natural logarithm of arg.
static double log10(double arg) Returns the base 10 logarithm for arg.
static double log1p(double arg) Returns the natural logarithm for arg + 1.
static double pow(double y, double x) Returns y raised to the x; for example, pow(2.0, 3.0)
returns 8.0.
factor
static double scalb(double arg, int factor) Returns val × 2 . (Added by Java SE 6.)
factor
static float scalb(float arg, int factor) Returns val × 2
static double sqrt(double arg) Returns the square root of arg.
. (Added by Java SE 6.)
Rounding Functions
The Math class defines several methods that provide various types of rounding operations.
They are shown in Table 16-16. Notice the two ulp( ) methods at the end of the table. In this
context, ulp stands for units in the last place. It indicates the number of units between a value
and the next higher value. It can be used to help assess the accuracy of a result.
419420
Part II:
The Java Library
Method Description
static int abs(int arg) Returns the absolute value of arg.
static long abs(long arg) Returns the absolute value of arg.
static float abs(float arg) Returns the absolute value of arg.
static double abs(double arg) Returns the absolute value of arg.
static double ceil(double arg) Returns the smallest whole number greater than or
equal to arg.
static double floor(double arg) Returns the largest whole number less than or equal to arg.
static int max(int x, int y) Returns the maximum of x and y.
static long max(long x, long y) Returns the maximum of x and y.
static float max(float x, float y) Returns the maximum of x and y.
static double max(double x, double y) Returns the maximum of x and y.
static int min(int x, int y) Returns the minimum of x and y.
static long min(long x, long y) Returns the minimum of x and y.
static float min(float x, float y) Returns the minimum of x and y.
static double min(double x, double y) Returns the minimum of x and y.
static double nextAfter(double arg,
double toward) Beginning with the value of arg, returns the next value in
the direction of toward. If arg == toward, then toward is
returned. (Added by Java SE 6.)
static float nextAfter(float arg,
double toward) Beginning with the value of arg, returns the next value in
the direction of toward. If arg == toward, then toward is
returned. (Added by Java SE 6.)
static double nextUp(double arg) Returns the next value in the positive direction from arg.
(Added by Java SE 6.)
static float nextUp(float arg) Returns the next value in the positive direction from arg.
(Added by Java SE 6.)
static double rint(double arg) Returns the integer nearest in value to arg.
static int round(float arg) Returns arg rounded up to the nearest int.
static long round(double arg) Returns arg rounded up to the nearest long.
static float ulp(float arg) Returns the ulp for arg.
static double ulp(double arg) Returns the ulp for arg.
T ABLE 16-16
The Rounding Methods Defined by Math
Miscellaneous Math Methods
In addition to the methods just shown, Math defines several other methods, which are
shown here:Chapter 16:
Exploring java.lang
Method Description
static double copySign(double arg,
double signarg) Returns arg with same sign as that of signarg.
(Added by Java SE 6.)
static float copySign(float arg,
float signarg) Returns arg with same sign as that of signarg.
(Added by Java SE 6.)
static int getExponent(double arg) Returns the base-2 exponent used by the binary
representation of arg. (Added by Java SE 6.)
static int getExponent(float arg) Returns the base-2 exponent used by the binary
representation of arg. (Added by Java SE 6.)
static double
IEEEremainder(double dividend,
double divisor) Returns the remainder of dividend / divisor.
static hypot(double side1, double side2) Returns the length of the hypotenuse of a right
triangle given the length of the two opposing sides.
static double random( ) Returns a pseudorandom number between 0 and 1.
static float signum(double arg) Determines the sign of a value. It returns 0 if arg is 0,
1 if arg is greater than 0, and –1 if arg is less than 0.
static float signum(float arg) Determines the sign of a value. It returns 0 if arg is 0,
1 if arg is greater than 0, and –1 if arg is less than 0.
static double toDegrees(double angle) Converts radians to degrees. The angle passed to
angle must be specified in radians. The result in
degrees is returned.
static double toRadians(double angle) Converts degrees to radians. The angle passed to
angle must be specified in degrees. The result in
radians is returned.
The following program demonstrates toRadians( ) and toDegrees( ):
// Demonstrate toDegrees() and toRadians().
class Angles 
The output is shown here:
120.0 degrees is 2.0943951023931953 radians.
1.312 radians is 75.17206272116401 degrees.
421422
Part II:
The Java Library
StrictMath
The StrictMath class defines a complete set of mathematical methods that parallel those
in Math. The difference is that the StrictMath version is guaranteed to generate precisely
identical results across all Java implementations, whereas the methods in Math are given
more latitude in order to improve performance.
Compiler
The Compiler class supports the creation of Java environments in which Java bytecode is
compiled into executable code rather than interpreted. It is not for normal programming use.
Thread, ThreadGroup, and Runnable
The Runnable interface and the Thread and ThreadGroup classes support multithreaded
programming. Each is examined next.
N OTE An overview of the techniques used to manage threads, implement the Runnable interface,
and create multithreaded programs is presented in Chapter 11.
The Runnable Interface
The Runnable interface must be implemented by any class that will initiate a separate thread
of execution. Runnable only defines one abstract method, called run( ), which is the entry
point to the thread. It is defined like this:
void run( )
Threads that you create must implement this method.
Thread
Thread creates a new thread of execution. It defines the following commonly used constructors:
Thread( )
Thread(Runnable threadOb)
Thread(Runnable threadOb, String threadName)
Thread(String threadName)
Thread(ThreadGroup groupOb, Runnable threadOb)
Thread(ThreadGroup groupOb, Runnable threadOb, String threadName)
Thread(ThreadGroup groupOb, String threadName)
threadOb is an instance of a class that implements the Runnable interface and defines where
execution of the thread will begin. The name of the thread is specified by threadName. When a
name is not specified, one is created by the Java Virtual Machine. groupOb specifies the thread
group to which the new thread will belong. When no thread group is specified, the new thread
belongs to the same group as the parent thread.
The following constants are defined by Thread:
MAX_PRIORITY
MIN_PRIORITY
NORM_PRIORITYChapter 16:
Exploring java.lang
As expected, these constants specify the maximum, minimum, and default thread priorities.
The methods defined by Thread are shown in Table 16-17. In early versions of Java, Thread
also included the methods stop( ), suspend( ), and resume( ). However, as explained in
Chapter 11, these were deprecated because they were inherently unstable. Also deprecated
are countStackFrames( ), because it calls suspend( ), and destroy( ), because it can cause deadlock.
Method Description
static int activeCount( ) Returns the number of threads in the group to
which the thread belongs.
final void checkAccess( ) Causes the security manager to verify that the
current thread can access and/or change the
thread on which checkAccess( ) is called.
static Thread currentThread( ) Returns a Thread object that encapsulates the
thread that calls this method.
static void dumpStack( ) Displays the call stack for the thread.
static int enumerate(Thread threads[ ]) Puts copies of all Thread objects in the current
thread’s group into threads. The number of threads
is returned.
static Map<Thread, StackTraceElement[ ]>
getAllStackTraces( ) Returns a Map that contains the stack traces for
all active threads. In the map, each entry consists
of a key, which is the Thread object, and its value,
which is an array of StackTraceElement.
ClassLoader getContextClassLoader( ) Returns the class loader that is used to load
classes and resources for this thread.
static Thread.UncaughtExceptionHandler
getDefaultUncaughtExceptionHandler( ) Returns the default uncaught exception handler.
long getID( ) Returns the ID of the invoking thread.
final String getName( ) Returns the thread’s name.
final int getPriority( ) Returns the thread’s priority setting.
StackTraceElement[ ] getStackTrace( ) Returns an array containing the stack trace for the
invoking thread.
Thread.State getState( ) Returns the invoking thread’s state.
final ThreadGroup getThreadGroup( ) Returns the ThreadGroup object of which the
invoking thread is a member.
Thread.UncaughtExceptionHandler
getUncaughtExceptionHandler( ) Returns the invoking thread’s uncaught exception
handler.
static boolean holdsLock(Object ob) Returns true if the invoking thread owns the lock
on ob. Returns false otherwise.
void interrupt( ) Interrupts the thread.
static boolean interrupted( ) Returns true if the currently executing thread has
been scheduled for interruption. Otherwise, it
returns false.
T ABLE 16-17
The Methods Defined by Thread
423424
Part II:
The Java Library
Method Description
final boolean isAlive( ) Returns true if the thread is still active. Otherwise,
it returns false.
final boolean isDaemon( ) Returns true if the thread is a daemon thread.
Otherwise, it returns false.
boolean isInterrupted( ) Returns true if the thread is interrupted.
Otherwise, it returns false.
final void join( )
throws InterruptedException Waits until the thread terminates.
final void join(long milliseconds)
throws InterruptedException Waits up to the specified number of milliseconds
for the thread on which it is called to terminate.
final void join(long milliseconds,
int nanoseconds)
throws InterruptedException Waits up to the specified number of milliseconds
plus nanoseconds for the thread on which it is
called to terminate.
void run( ) Begins execution of a thread.
void setContextClassLoader(ClassLoader cl) Sets the class loader that will be used by the
invoking thread to cl.
final void setDaemon(boolean state) Flags the thread as a daemon thread.
static void
setDefaultUncaughtExceptionHandler(
Thread.UncaughtExceptionHandler e) Sets the default uncaught exception handler to e.
final void setName(String threadName) Sets the name of the thread to that specified by
threadName.
final void setPriority(int priority) Sets the priority of the thread to that specified by
priority.
void
setUncaughtExceptionHandler(
Thread.UncaughtExceptionHandler e) Sets the invoking thread’s default uncaught
exception handler to e.
static void sleep(long milliseconds)
throws InterruptedException Suspends execution of the thread for the specified
number of milliseconds.
static void sleep(long milliseconds,
int nanoseconds)
throws InterruptedException Suspends execution of the thread for the specified
number of milliseconds plus nanoseconds.
void start( ) Starts execution of the thread.
String toString( ) Returns the string equivalent of a thread.
static void yield( ) The calling thread yields the CPU to another thread.
T ABLE 16-17
The Methods Defined by Thread (continued )
ThreadGroup
ThreadGroup creates a group of threads. It defines these two constructors:
ThreadGroup(String groupName)
ThreadGroup(ThreadGroup parentOb, String groupName)Chapter 16:
Exploring java.lang
For both forms, groupName specifies the name of the thread group. The first version creates
a new group that has the current thread as its parent. In the second form, the parent is
specified by parentOb. The non-deprecated methods defined by ThreadGroup are shown
in Table 16-18.
Thread groups offer a convenient way to manage groups of threads as a unit. This is
particularly valuable in situations in which you want to suspend and resume a number
of related threads. For example, imagine a program in which one set of threads is used for
printing a document, another set is used to display the document on the screen, and another
set saves the document to a disk file. If printing is aborted, you will want an easy way to
Method Description
int activeCount( ) Returns the number of threads in the group plus any
groups for which this thread is a parent.
int activeGroupCount( ) Returns the number of groups for which the invoking
thread is a parent.
final void checkAccess( ) Causes the security manager to verify that the
invoking thread may access and/or change the
group on which checkAccess( ) is called.
final void destroy( ) Destroys the thread group (and any child groups) on
which it is called.
int enumerate(Thread group[ ]) The threads that comprise the invoking thread group
are put into the group array.
int enumerate(Thread group[ ], boolean all) The threads that comprise the invoking thread group
are put into the group array. If all is true, then threads
in all subgroups of the thread are also put into group.
int enumerate(ThreadGroup group[ ]) The subgroups of the invoking thread group are put
into the group array.
int enumerate(ThreadGroup group[ ],
boolean all) The subgroups of the invoking thread group are put
into the group array. If all is true, then all subgroups
of the subgroups (and so on) are also put into group.
final int getMaxPriority( ) Returns the maximum priority setting for the group.
final String getName( ) Returns the name of the group.
final ThreadGroup getParent( ) Returns null if the invoking ThreadGroup object has
no parent. Otherwise, it returns the parent of the
invoking object.
final void interrupt( ) Invokes the interrupt( ) method of all threads in
the group.
T ABLE 16-18
The Methods Defined by ThreadGroup
425426
Part II:
The Java Library
Method Description
final boolean isDaemon( ) Returns true if the group is a daemon group.
Otherwise, it returns false.
boolean isDestroyed( ) Returns true if the group has been destroyed.
Otherwise, it returns false.
void list( ) Displays information about the group.
final boolean parentOf(ThreadGroup group) Returns true if the invoking thread is the parent of
group (or group, itself). Otherwise, it returns false.
final void setDaemon(boolean isDaemon) If isDaemon is true, then the invoking group is
flagged as a daemon group.
final void setMaxPriority(int priority) Sets the maximum priority of the invoking group
to priority.
String toString( ) Returns the string equivalent of the group.
void uncaughtException(Thread thread,
Throwable e) This method is called when an exception goes
uncaught.
T ABLE 16-18
The Methods Defined by ThreadGroup (continued)
stop all threads related to printing. Thread groups offer this convenience. The following
program, which creates two thread groups of two threads each, illustrates this usage:
// Demonstrate thread groups.
class NewThread extends Thread 
class ThreadGroupDemo 
Sample output from this program is shown here (the precise ouput you see may differ):
New thread: Thread[One,5,Group A]
New thread: Thread[Two,5,Group A]
New thread: Thread[Three,5,Group B]
New thread: Thread[Four,5,Group B]
Here is output from list():
java.lang.ThreadGroup[name=Group A,maxpri=10]
Thread[One,5,Group A]
Thread[Two,5,Group A]
java.lang.ThreadGroup[name=Group B,maxpri=10]
Thread[Three,5,Group B]
Thread[Four,5,Group B]
Suspending Group A
Three: 5
Four: 5
Three: 4
Four: 4
Three: 3
Four: 3
Three: 2
Four: 2
Resuming Group A
Waiting for threads to finish.
One: 5
Two: 5
Three: 1
Four: 1
One: 4
Two: 4
Three exiting.
Four exiting.
One: 3
Two: 3
One: 2
Two: 2
One: 1
Two: 1
One exiting.Chapter 16:
Exploring java.lang
Two exiting.
Main thread exiting.
Inside the program, notice that thread group A is suspended for four seconds. As the
output confirms, this causes threads One and Two to pause, but threads Three and Four
continue running. After the four seconds, threads One and Two are resumed. Notice how
thread group A is suspended and resumed. First, the threads in group A are obtained by
calling enumerate( ) on group A. Then, each thread is suspended by iterating through the
resulting array. To resume the threads in A, the list is again traversed and each thread is
resumed. One last point: this example uses the recommended approach to suspending
and resuming threads. It does not rely upon the deprecated methods suspend( ) and
resume( ).
ThreadLocal and InheritableThreadLocal
Java defines two additional thread-related classes in java.lang:
• ThreadLocal Used to create thread local variables. Each thread will have its own
copy of a thread local variable.
• InheritableThreadLocal Creates thread local variables that may be inherited.
Package
Package encapsulates version data associated with a package. Package version information
is becoming more important because of the proliferation of packages and because a Java
program may need to know what version of a package is available. The methods defined by
Package are shown in Table 16-19. The following program demonstrates Package, displaying
the packages about which the program currently is aware:
// Demonstrate Package
class PkgTest 
429430
Part II:
The Java Library
Method Description
<A extends Annotation> A
getAnnotation(Class<A> annoType) Returns an Annotation object that contains the
annotation associated with annoType for the
invoking object.
Annotation[ ] getAnnotations( ) Returns all annotations associated with the invoking
object in an array of Annotation objects. Returns a
reference to this array.
Annotation[ ] getDeclaredAnnotations( ) Returns an Annotation object for all the annotations
that are declared by the invoking object. (Inherited
annotations are ignored.)
String getImplementationTitle( ) Returns the title of the invoking package.
String getImplementationVendor( ) Returns the name of the implementor of the
invoking package.
String getImplementationVersion( ) Returns the version number of the invoking package.
String getName( ) Returns the name of the invoking package.
static Package getPackage(String pkgName) Returns a Package object with the name specified
by pkgName.
static Package[ ] getPackages( ) Returns all packages about which the invoking
program is currently aware.
String getSpecificationTitle( ) Returns the title of the invoking package’s
specification.
String getSpecificationVendor( ) Returns the name of the owner of the specification
for the invoking package.
String getSpecificationVersion( ) Returns the invoking package’s specification
version number.
int hashCode( ) Returns the hash code for the invoking package.
boolean isAnnotationPresent(
Class<? extends Annotation> anno) Returns true if the annotation described by anno is
associated with the invoking object. Returns false,
otherwise.
boolean isCompatibleWith(String verNum)
throws NumberFormatException Returns true if verNum is less than or equal to the
invoking package’s version number.
boolean isSealed( ) Returns true if the invoking package is sealed.
Returns false otherwise.
boolean isSealed(URL url) Returns true if the invoking package is sealed
relative to url. Returns false otherwise.
String toString( ) Returns the string equivalent of the invoking
package.
T ABLE 16-19
The Methods Defined by PackageChapter 16:
Exploring java.lang
RuntimePermission
RuntimePermission relates to Java’s security mechanism and is not examined further here.
Throwable
The Throwable class supports Java’s exception-handling system and is the class from which
all exception classes are derived. It is discussed in Chapter 10.
SecurityManager
SecurityManager is a class that your classes can subclass to create a security manager.
Generally, you don’t need to implement your own security manager. If you do, you need
to consult the documentation that comes with your Java development system.
StackTraceElement
The StackTraceElement class describes a single stack frame, which is an individual element
of a stack trace when an exception occurs. Each stack frame represents an execution point,
which includes such things as the name of the class, the name of the method, the name of
the file, and the source-code line number. An array of StackTraceElements is returned by
the getStackTrace( ) method of the Throwable class.
StackTraceElement has one constructor:
StackTraceElement(String className, String methName, string fileName, int line)
Here, the name of the class is specified by className, the name of the method is specified in
methName, the name of the file is specified by fileName, and the line number is passed in line.
If there is no valid line number, use a negative value for line. Furthermore, a value of 2 – for
line indicates that this frame refers to a native method.
The methods supported by StackTraceElement are shown in Table 16-20. These
methods give you programmatic access to a stack trace.
Method Description
boolean equals(Object ob) Returns true if the invoking StackTraceElement is the same as the
one passed in ob. Otherwise, it returns false.
String getClassName( ) Returns the class name of the execution point described by the
invoking StackTraceElement.
String getFileName( ) Returns the filename of the execution point described by the
invoking StackTraceElement.
T ABLE 16-20
The Methods Defined by StackTraceElement
431432
Part II:
The Java Library
Method Description
int getLineNumber( ) Returns the source-code line number of the execution point described
by the invoking StackTraceElement. In some situations, the line
number will not be available, in which case a negative value is
returned.
String getMethodName( ) Returns the method name of the execution point described by the
invoking StackTraceElement.
int hashCode( ) Returns the hash code for the invoking StackTraceElement.
boolean isNativeMethod( ) Returns true if the invoking StackTraceElement describes a native
method. Otherwise, returns false.
String toString( ) Returns the String equivalent of the invoking sequence.
T ABLE 16-20
The Methods Defined by StackTraceElement (continued)
Enum
As described in Chapter 12, enumerations were recently added to the Java language. (Recall that
an enumeration is created by using the keyword enum.) All enumerations automatically inherit
Enum. Enum is a generic class that is declared as shown here:
class Enum<E extends Enum<E>>
Here, E stands for the enumeration type. Enum has no public constructors.
Enum defines several methods that are available for use by all enumerations, which are
shown in Table 16-21.
Method Description
protected final Object clone( )
throws CloneNotSupportedException Invoking this method causes a
CloneNotSupportedException to be thrown. This
prevents enumerations from being cloned.
final int compareTo(E e) Compares the ordinal value of two constants of the
same enumeration. Returns a negative value if the
invoking constant has an ordinal value less than e’s,
zero if the two ordinal values are the same, and a
positive value if the invoking constant has an ordinal
value greater than e’s.
final boolean equals(Object obj) Returns true if obj and the invoking object refer
to the same constant.
final Class<E> getDeclaringClass( ) Returns the type of enumeration of which the
invoking constant is a member.
final int hashCode( ) Returns the hash code for the invoking object.
T ABLE 16-21
The Methods Defined by EnumChapter 16:
Exploring java.lang
Method Description
final String name( ) Returns the unaltered name of the invoking constant.
final int ordinal( ) Returns a value that indicates an enumeration
constant’s position in the list of constants.
String toString( ) Returns the name of the invoking constant. This
name may differ from the one used in the
enumeration’s declaration.
static <T extends Enum<T>> T
valueOf(Class<T> e-type, String name) Returns the constant associated with name in the
enumeration type specified by e-type.
T ABLE 16-21
The Methods Defined by Enum (continued)
The CharSequence Interface
The CharSequence interface defines methods that grant read-only access to a sequence of
characters. These methods are shown in Table 16-22. This interface is implemented by String,
StringBuffer, and StringBuilder. It is also implemented by CharBuffer, which is in the
java.nio package (described later in this book).
The Comparable Interface
Objects of classes that implement Comparable can be ordered. In other words, classes that
implement Comparable contain objects that can be compared in some meaningful manner.
Comparable is generic and is declared like this:
interface Comparable<T>
Here, T represents the type of objects being compared.
The Comparable interface declares one method that is used to determine what Java
calls the natural ordering of instances of a class. The signature of the method is shown here:
int compareTo(T obj)
Method Description
char charAt(int idx) Returns the character at the index specified by idx.
int length( ) Returns the number of characters in the invoking
sequence.
CharSequence
Returns a subset of the invoking sequence beginning at
subSequence(int startIdx, int stopIdx) startIdx and ending at stopIdx–1.
String toString( )
T ABLE 16-22
Returns the String equivalent of the invoking sequence.
The Methods Defined by CharSequence
433434
Part II:
The Java Library
This method compares the invoking object with obj. It returns 0 if the values are equal. A
negative value is returned if the invoking object has a lower value. Otherwise, a positive
value is returned.
This interface is implemented by several of the classes already reviewed in this book.
Specifically, the Byte, Character, Double, Float, Long, Short, String, and Integer classes
define a compareTo( ) method. In addition, as the next chapter explains, objects that implement
this interface can be used in various collections.
The Appendable Interface
Objects of a class that implements Appendable can have a character or character sequences
appended to it. Appendable defines these three methods:
Appendable append(char ch) throws IOException
Appendable append(CharSequence chars) throws IOException
Appendable append(CharSequence chars, int begin, int end) throws IOException
In the first form, the character ch is appended to the invoking object. In the second form, the
character sequence chars is appended to the invoking object. The third form allows you to
indicate a portion (specified by begin and end) of the sequence specified by chars. In all cases,
a reference to the invoking object is returned.
The Iterable Interface
Iterable must be implemented by any class whose objects will be used by the for-each
version of the for loop. In other words, in order for an object to be used within a for-each
style for loop, its class must implement Iterable. Iterable is a generic interface that has this
declaration:
interface Iterable<T>
Here, T is the type of the object being iterated. It defines one method, iterator( ), which is
shown here:
Iterator<T> iterator( )
It returns an iterator to the elements contained in the invoking object.
N OTE Iterators are described in detail in Chapter 17.
The Readable Interface
The Readable interface indicates that an object can be used as a source for characters.
It defines one method called read( ), which is shown here:
int read(CharBuffer buf) throws IOExceptionChapter 16:
Exploring java.lang
This method reads characters into buf. It returns the number of characters read, or 1 – if an
EOF is encountered.
The java.lang Subpackages
Java defines several subpackages:
• java.lang.annotation
• java.lang.instrument
• java.lang.management
• java.lang.ref
• java.lang.reflect
Each is briefly described here.
java.lang.annotation
Java’s annotation facility is supported by java.lang.annotation. It defines the Annotation
interface, and the ElementType and RetentionPolicy enumerations. Annotations are described
in Chapter 12.
java.lang.instrument
java.lang.instrument defines features that can be used to add instrumentation to various aspects
of program execution. It defines the Instrumentation and ClassFileTransformer interfaces, and
the ClassDefinition class.
java.lang.management
The java.lang.management package provides management support for the JVM and the
execution environment. Using the features in java.lang.management, you can observe and
manage various aspects of program execution.
java.lang.ref
You learned earlier that the garbage collection facilities in Java automatically determine when
no references exist to an object. The object is then assumed to be no longer needed and its
memory is reclaimed. The classes in the java.lang.ref package provide more flexible control
over the garbage collection process. For example, assume that your program has created
numerous objects that you want to reuse at some later time. You can continue to hold references
to these objects, but that may require too much memory.
Instead, you can define “soft” references to these objects. An object that is “softly reachable”
can be reclaimed by the garbage collector, if available memory runs low. In that case, the
garbage collector sets the “soft” references to that object to null. Otherwise, the garbage
collector saves the object for possible future use.
A programmer has the ability to determine whether a “softly reachable” object has been
reclaimed. If it has been reclaimed, it can be re-created. Otherwise, the object is still available
for reuse. You may also create “weak” and “phantom” references to objects. Discussion of
these and other features of the java.lang.ref package is beyond the scope of this book.
435436
Part II:
The Java Library
java.lang.reflect
Reflection is the ability of a program to analyze itself. The java.lang.reflect package provides
the ability to obtain information about the fields, constructors, methods, and modifiers of a
class. Among other reasons, you need this information to build software tools that enable you
to work with Java Beans components. The tools use reflection to determine dynamically the
characteristics of a component. Reflection was introduced in Chapter 12 and is also examined
in Chapter 27.
java.lang.reflect defines several classes, including Method, Field, and Constructor. It also
defines several interfaces, including AnnotatedElement, Member, and Type. In addition, the
java.lang.reflect package includes the Array class that enables you to create and access arrays
dynamically.17
java.util Part 1:
The Collections Framework
T
his chapter begins our examination of java.util. This important package contains a large
assortment of classes and interfaces that support a broad range of functionality. For
example, java.util has classes that generate pseudorandom numbers, manage date and
time, observe events, manipulate sets of bits, tokenize strings, and handle formatted data.
The java.util package also contains one of Java’s most powerful subsystems: The Collections
Framework. The Collections Framework is a sophisticated hierarchy of interfaces and classes
that provide state-of-the-art technology for managing groups of objects. It merits close attention
by all programmers.
Because java.util contains a wide array of functionality, it is quite large. Here is a list of
its classes:
AbstractCollection EventObject Random
AbstractList FormattableFlags ResourceBundle
AbstractMap Formatter Scanner
AbstractQueue GregorianCalendar ServiceLoader (Added by Java SE 6.)
AbstractSequentialList HashMap SimpleTimeZone
AbstractSet HashSet Stack
ArrayDeque (Added by Java SE 6.) Hashtable StringTokenizer
ArrayList IdentityHashMap Timer
Arrays LinkedHashMap TimerTask
BitSet LinkedHashSet TimeZone
Calendar LinkedList TreeMap
Collections ListResourceBundle TreeSet
Currency Locale UUID
Date Observable Vector
Dictionary PriorityQueue WeakHashMap
EnumMap Properties EnumSet PropertyPermission EventListenerProxy PropertyResourceBundle
437438
Part II:
The Java Library
The interfaces defined by java.util are shown next:
Collection List Queue
Comparator ListIterator RandomAccess
Deque (Added by Java SE 6.) Map Set
Enumeration Map.Entry SortedMap
EventListener NavigableMap (Added by Java SE 6.) SortedSet
Formattable NavigableSet (Added by Java SE 6.) Iterator Observer
Because of its size, the description of java.util is broken into two chapters. This chapter
examines those members of java.util that are part of the Collections Framework. Chapter 18
discusses its other classes and interfaces.
Collections Overview
The Java Collections Framework standardizes the way in which groups of objects are handled
by your programs. Collections were not part of the original Java release, but were added by
J2SE 1.2. Prior to the Collections Framework, Java provided ad hoc classes such as Dictionary,
Vector, Stack, and Properties to store and manipulate groups of objects. Although these classes
were quite useful, they lacked a central, unifying theme. The way that you used Vector was
different from the way that you used Properties, for example. Also, this early, ad hoc approach
was not designed to be easily extended or adapted. Collections are an answer to these (and
other) problems.
The Collections Framework was designed to meet several goals. First, the framework had
to be high-performance. The implementations for the fundamental collections (dynamic arrays,
linked lists, trees, and hash tables) are highly efficient. You seldom, if ever, need to code one
of these “data engines” manually. Second, the framework had to allow different types of
collections to work in a similar manner and with a high degree of interoperability. Third,
extending and/or adapting a collection had to be easy. Toward this end, the entire Collections
Framework is built upon a set of standard interfaces. Several standard implementations
(such as LinkedList, HashSet, and TreeSet) of these interfaces are provided that you may
use as-is. You may also implement your own collection, if you choose. Various special-purpose
implementations are created for your convenience, and some partial implementations are
provided that make creating your own collection class easier. Finally, mechanisms were added
that allow the integration of standard arrays into the Collections Framework.
Algorithms are another important part of the collection mechanism. Algorithms operate
on collections and are defined as static methods within the Collections class. Thus, they are
available for all collections. Each collection class need not implement its own versions. The
algorithms provide a standard means of manipulating collections.
Another item closely associated with the Collections Framework is the Iterator interface.
An iterator offers a general-purpose, standardized way of accessing the elements within a
collection, one at a time. Thus, an iterator provides a means of enumerating the contents of
a collection. Because each collection implements Iterator, the elements of any collection class
can be accessed through the methods defined by Iterator. Thus, with only small changes,
the code that cycles through a set can also be used to cycle through a list, for example.Chapter 17:
java.util Part 1: The Collections Framework
In addition to collections, the framework defines several map interfaces and classes. Maps
store key/value pairs. Although maps are part of the Collections Framework, they are not
“collections” in the strict use of the term. You can, however, obtain a collection-view of a map.
Such a view contains the elements from the map stored in a collection. Thus, you can process
the contents of a map as a collection, if you choose.
The collection mechanism was retrofitted to some of the original classes defined by java.util
so that they too could be integrated into the new system. It is important to understand that
although the addition of collections altered the architecture of many of the original utility
classes, it did not cause the deprecation of any. Collections simply provide a better way of
doing several things.
N OTE If you are familiar with C++, then you will find it helpful to know that the Java collections
technology is similar in spirit to the Standard Template Library (STL) defined by C++. What
C++ calls a container, Java calls a collection. However, there are significant differences between
the Collections Framework and the STL. It is important to not jump to conclusions.
Recent Changes to Collections
Recently, the Collections Framework underwent a fundamental change that significantly
increased its power and streamlined its use. The changes were caused by the addition of
generics, autoboxing/unboxing, and the for-each style for loop, by JDK 5. Although we will be
revisiting these topics throughout the course of this chapter, a brief overview is warranted now.
Generics Fundamentally Change the Collections Framework
The addition of generics caused a significant change to the Collections Framework because the
entire Collections Framework has been reengineered for it. All collections are now generic,
and many of the methods that operate on collections take generic type parameters. Simply
put, the addition of generics has affected every part of the Collections Framework.
Generics add the one feature that collections had been missing: type safety. Prior to generics,
all collections stored Object references, which meant that any collection could store any type
of object. Thus, it was possible to accidentally store incompatible types in a collection. Doing
so could result in run-time type mismatch errors. With generics, it is possible to explicitly
state the type of data being stored, and run-time type mismatch errors can be avoided.
Although the addition of generics changed the declarations of most of its classes and
interfaces, and several of their methods, overall, the Collections Framework still works the
same as it did prior to generics. However, if you are familiar with the pre-generics version
of the Collections Framework, you might find the new syntax a bit intimidating. Don’t worry;
over time, the generic syntax will become second nature.
One other point: to gain the advantages that generics bring collections, older code will
need to be rewritten. This is also important because pre-generics code will generate warning
messages when compiled by a modern Java compiler. To eliminate these warnings, you will
need to add type information to all your collections code.
Autoboxing Facilitates the Use of Primitive Types
Autoboxing/unboxing facilitates the storing of primitive types in collections. As you will see,
a collection can store only references, not primitive values. In the past, if you wanted to store
a primitive value, such as an int, in a collection, you had to manually box it into its type
439440
Part II:
The Java Library
wrapper. When the value was retrieved, it needed to be manually unboxed (by using an
explicit cast) into its proper primitive type. Because of autoboxing/unboxing, Java can
automatically perform the proper boxing and unboxing needed when storing or retrieving
primitive types. There is no need to manually perform these operations.
The For-Each Style for Loop
All collection classes in the Collections Framework have been retrofitted to implement the
Iterable interface, which means that a collection can be cycled through by use of the for-each
style for loop. In the past, cycling through a collection required the use of an iterator (described
later in this chapter), with the programmer manually constructing the loop. Although iterators
are still needed for some uses, in many cases, iterator-based loops can be replaced by for loops.
The Collection Interfaces
The Collections Framework defines several interfaces. This section provides an overview of
each interface. Beginning with the collection interfaces is necessary because they determine
the fundamental nature of the collection classes. Put differently, the concrete classes simply
provide different implementations of the standard interfaces. The interfaces that underpin
collections are summarized in the following table:
Interface Description
Collection Enables you to work with groups of objects; it is at the top of the collections
hierarchy.
Deque Extends Queue to handle a double-ended queue. (Added by Java SE 6.)
List Extends Collection to handle sequences (lists of objects).
NavigableSet Extends SortedSet to handle retrieval of elements based on closest-match
searches. (Added by Java SE 6.)
Queue Extends Collection to handle special types of lists in which elements are
removed only from the head.
Set Extends Collection to handle sets, which must contain unique elements.
SortedSet Extends Set to handle sorted sets.
In addition to the collection interfaces, collections also use the Comparator, RandomAccess,
Iterator, and ListIterator interfaces, which are described in depth later in this chapter. Briefly,
Comparator defines how two objects are compared; Iterator and ListIterator enumerate the
objects within a collection. By implementing RandomAccess, a list indicates that it supports
efficient, random access to its elements.
To provide the greatest flexibility in their use, the collection interfaces allow some methods
to be optional. The optional methods enable you to modify the contents of a collection.
Collections that support these methods are called modifiable. Collections that do not allow
their contents to be changed are called unmodifiable. If an attempt is made to use one of these
methods on an unmodifiable collection, an UnsupportedOperationException is thrown. All
the built-in collections are modifiable.
The following sections examine the collection interfaces.Chapter 17:
java.util Part 1: The Collections Framework
The Collection Interface
The Collection interface is the foundation upon which the Collections Framework is built
because it must be implemented by any class that defines a collection. Collection is a generic
interface that has this declaration:
interface Collection<E>
Here, E specifies the type of objects that the collection will hold. Collection extends the
Iterable interface. This means that all collections can be cycled through by use of the for-each
style for loop. (Recall that only classes that implement Iterable can be cycled through by the for.)
Collection declares the core methods that all collections will have. These methods are
summarized in Table 17-1. Because all collections implement Collection, familiarity with its
methods is necessary for a clear understanding of the framework. Several of these methods
can throw an UnsupportedOperationException. As explained, this occurs if a collection
cannot be modified. A ClassCastException is generated when one object is incompatible with
another, such as when an attempt is made to add an incompatible object to a collection. A
NullPointerException is thrown if an attempt is made to store a null object and null elements
are not allowed in the collection. An IllegalArgumentException is thrown if an invalid
argument is used. An IllegalStateException is thrown if an attempt is made to add an
element to a fixed-length collection that is full.
Objects are added to a collection by calling add( ). Notice that add( ) takes an argument
of type E, which means that objects added to a collection must be compatible with the type of
data expected by the collection. You can add the entire contents of one collection to another
by calling addAll( ).
You can remove an object by using remove( ). To remove a group of objects, call
removeAll( ). You can remove all elements except those of a specified group by calling
retainAll( ). To empty a collection, call clear( ).
You can determine whether a collection contains a specific object by calling contains( ).
To determine whether one collection contains all the members of another, call containsAll( ).
You can determine when a collection is empty by calling isEmpty( ). The number of elements
currently held in a collection can be determined by calling size( ).
The toArray( ) methods return an array that contains the elements stored in the invoking
collection. The first returns an array of Object. The second returns an array of elements that
have the same type as the array specified as a parameter. Normally, the second form is more
convenient because it returns the desired array type. These methods are more important than
it might at first seem. Often, processing the contents of a collection by using array-like syntax
is advantageous. By providing a pathway between collections and arrays, you can have the
best of both worlds.
Two collections can be compared for equality by calling equals( ). The precise meaning of
“equality” may differ from collection to collection. For example, you can implement equals( )
so that it compares the values of elements stored in the collection. Alternatively, equals( ) can
compare references to those elements.
One more very important method is iterator( ), which returns an iterator to a collection.
Iterators are frequently used when working with collections.
The List Interface
The List interface extends Collection and declares the behavior of a collection that stores a
sequence of elements. Elements can be inserted or accessed by their position in the list, using
441442
Part II:
The Java Library
Method Description
boolean add(E obj) Adds obj to the invoking collection. Returns true if obj was added
to the collection. Returns false if obj is already a member of the
collection and the collection does not allow duplicates.
boolean addAll(Collection<? extends E> c) Adds all the elements of c to the invoking collection. Returns true
if the operation succeeded (i.e., the elements were added).
Otherwise, returns false.
void clear( ) Removes all elements from the invoking collection.
boolean contains(Object obj) Returns true if obj is an element of the invoking collection.
Otherwise, returns false.
boolean containsAll(Collection<?> c) Returns true if the invoking collection contains all elements
of c. Otherwise, returns false.
boolean equals(Object obj) Returns true if the invoking collection and obj are equal.
Otherwise, returns false.
int hashCode( ) Returns the hash code for the invoking collection.
boolean isEmpty( ) Returns true if the invoking collection is empty. Otherwise,
returns false.
Iterator<E> iterator( ) Returns an iterator for the invoking collection.
boolean remove(Object obj) Removes one instance of obj from the invoking collection. Returns
true if the element was removed. Otherwise, returns false.
boolean removeAll(Collection<?> c) Removes all elements of c from the invoking collection. Returns
true if the collection changed (i.e., elements were removed).
Otherwise, returns false.
boolean retainAll(Collection<?> c) Removes all elements from the invoking collection except those
in c. Returns true if the collection changed (i.e., elements were
removed). Otherwise, returns false.
int size( ) Returns the number of elements held in the invoking collection.
Object[ ] toArray( ) Returns an array that contains all the elements stored in the
invoking collection. The array elements are copies of the
collection elements.
<T> T[ ] toArray(T array[ ]) Returns an array that contains the elements of the invoking
collection. The array elements are copies of the collection
elements. If the size of array equals the number of elements,
these are returned in array. If the size of array is less than the
number of elements, a new array of the necessary size is allocated
and returned. If the size of array is greater than the number of
elements, the array element following the last collection element
is set to null. An ArrayStoreException is thrown if any collection
element has a type that is not a subtype of array.
T ABLE 17-1
The Methods Defined by Collection
a zero-based index. A list may contain duplicate elements. List is a generic interface that has
this declaration:
interface List<E>
Here, E specifies the type of objects that the list will hold.
In addition to the methods defined by Collection, List defines some of its own, which
are summarized in Table 17-2. Note again that several of these methods will throw an
UnsupportedOperationException if the list cannot be modified, and a ClassCastException isChapter 17:
java.util Part 1: The Collections Framework
Method Description
void add(int index, E obj) Inserts obj into the invoking list at the index passed in index.
Any preexisting elements at or beyond the point of insertion
are shifted up. Thus, no elements are overwritten.
boolean addAll(int index,
Collection<? extends E> c) Inserts all elements of c into the invoking list at the index
passed in index. Any preexisting elements at or beyond the
point of insertion are shifted up. Thus, no elements are
overwritten. Returns true if the invoking list changes and
returns false otherwise.
E get(int index) Returns the object stored at the specified index within the
invoking collection.
int indexOf(Object obj) Returns the index of the first instance of obj in the invoking
list. If obj is not an element of the list, –1 is returned.
int lastIndexOf(Object obj) Returns the index of the last instance of obj in the invoking
list. If obj is not an element of the list, –1 is returned.
ListIterator<E> listIterator( ) Returns an iterator to the start of the invoking list.
ListIterator<E> listIterator(int index) Returns an iterator to the invoking list that begins at the
specified index.
E remove(int index) Removes the element at position index from the invoking list
and returns the deleted element. The resulting list is compacted.
That is, the indexes of subsequent elements are decremented
by one.
E set(int index, E obj) Assigns obj to the location specified by index within the
invoking list.
List<E> subList(int start, int end) Returns a list that includes elements from start to end–1 in the
invoking list. Elements in the returned list are also referenced
by the invoking object.
T ABLE 17-2
The Methods Defined by List
generated when one object is incompatible with another, such as when an attempt is made to add
an incompatible object to a list. Also, several methods will throw an IndexOutOfBoundsException
if an invalid index is used. A NullPointerException is thrown if an attempt is made to store
a null object and null elements are not allowed in the list. An IllegalArgumentException is
thrown if an invalid argument is used.
To the versions of add( ) and addAll( ) defined by Collection, List adds the methods
add(int, E) and addAll(int, Collection). These methods insert elements at the specified index.
Also, the semantics of add(E) and addAll(Collection) defined by Collection are changed by
List so that they add elements to the end of the list.
To obtain the object stored at a specific location, call get( ) with the index of the object.
To assign a value to an element in the list, call set( ), specifying the index of the object to be
changed. To find the index of an object, use indexOf( ) or lastIndexOf( ).
You can obtain a sublist of a list by calling subList( ), specifying the beginning and ending
indexes of the sublist. As you can imagine, subList( ) makes list processing quite convenient.
The Set Interface
The Set interface defines a set. It extends Collection and declares the behavior of a collection
that does not allow duplicate elements. Therefore, the add( ) method returns false if an attempt
443444
Part II:
The Java Library
is made to add duplicate elements to a set. It does not define any additional methods of its
own. Set is a generic interface that has this declaration:
interface Set<E>
Here, E specifies the type of objects that the set will hold.
The SortedSet Interface
The SortedSet interface extends Set and declares the behavior of a set sorted in ascending
order. SortedSet is a generic interface that has this declaration:
interface SortedSet<E>
Here, E specifies the type of objects that the set will hold.
In addition to those methods defined by Set, the SortedSet interface declares the methods
summarized in Table 17-3. Several methods throw a NoSuchElementException when no
items are contained in the invoking set. A ClassCastException is thrown when an object
is incompatible with the elements in a set. A NullPointerException is thrown if an attempt is
made to use a null object and null is not allowed in the set. An IllegalArgumentException
is thrown if an invalid argument is used.
SortedSet defines several methods that make set processing more convenient. To obtain
the first object in the set, call first( ). To get the last element, use last( ). You can obtain a subset
of a sorted set by calling subSet( ), specifying the first and last object in the set. If you need
the subset that starts with the first element in the set, use headSet( ). If you want the subset
that ends the set, use tailSet( ).
The NavigableSet Interface
The NavigableSet interface was added by Java SE 6. It extends SortedSet and declares the
behavior of a collection that supports the retrieval of elements based on the closest match to
a given value or values. NavigableSet is a generic interface that has this declaration:
interface NavigableSet<E>
Here, E specifies the type of objects that the set will hold. In addition to the methods
that it inherits from SortedSet, NavigableSet adds those summarized in Table 17-4. A
Method Description
Comparator<? super E> comparator( ) Returns the invoking sorted set’s comparator. If the natural ordering
is used for this set, null is returned.
E first( ) Returns the first element in the invoking sorted set.
SortedSet<E> headSet(E end) Returns a SortedSet containing those elements less than end that
are contained in the invoking sorted set. Elements in the returned
sorted set are also referenced by the invoking sorted set.
E last( ) Returns the last element in the invoking sorted set.
SortedSet<E> subSet(E start, E end) Returns a SortedSet that includes those elements between start
and end–1. Elements in the returned collection are also referenced
by the invoking object.
SortedSet<E> tailSet(E start) Returns a SortedSet that contains those elements greater than or
equal to start that are contained in the sorted set. Elements in the
returned set are also referenced by the invoking object.
T ABLE 17-3
The Methods Defined by SortedSetChapter 17:
java.util Part 1: The Collections Framework
Method Description
E ceiling(E obj) Searches the set for the smallest element e such that e >= obj. If
such an element is found, it is returned. Otherwise, null is returned.
Iterator<E> descendingIterator( ) Returns an iterator that moves from the greatest to least. In
other words, it returns a reverse iterator.
NavigableSet<E> descendingSet( ) Returns a NavigableSet that is the reverse of the invoking set.
The resulting set is backed by the invoking set.
E floor(E obj) Searches the set for the largest element e such that e <= obj. If
such an element is found, it is returned. Otherwise, null is
returned.
NavigableSet<E>
headSet(E upperBound, boolean incl) Returns a NavigableSet that includes all elements from the
invoking set that are less than upperBound. If incl is true, then
an element equal to upperBound is included. The resulting set is
backed by the invoking set.
E higher(E obj) Searches the set for the largest element e such that e > obj. If such
an element is found, it is returned. Otherwise, null is returned.
E lower(E obj) Searches the set for the largest element e such that e < obj. If
such an element is found, it is returned. Otherwise, null is
returned.
E pollFirst( ) Returns the first element, removing the element in the process.
Because the set is sorted, this is the element with the least
value. null is returned if the set is empty.
E pollLast( ) Returns the last element, removing the element in the process.
Because the set is sorted, this is the element with the greatest
value. null is returned if the set is empty.
NavigableSet<E>
subSet(E lowerBound,
boolean lowIncl,
E upperBound,
boolean highIncl) Returns a NavigableSet that includes all elements from the
invoking set that are greater than lowerBound and less than
upperBound. If lowIncl is true, then an element equal to
lowerBound is included. If highIncl is true, then an element
equal to upperBound is included. The resulting set is backed
by the invoking set.
NavigableSet<E>
tailSet(E lowerBound, boolean incl) Returns a NavigableSet that includes all elements from the
invoking set that are greater than lowerBound. If incl is true, then
an element equal to lowerBound is included. The resulting set is
backed by the invoking set.
T ABLE 17-4
The Methods Defined by NavigableSet
ClassCastException is thrown when an object is incompatible with the elements in the set.
A NullPointerException is thrown if an attempt is made to use a null object and null is not
allowed in the set. An IllegalArgumentException is thrown if an invalid argument is used.
The Queue Interface
The Queue interface extends Collection and declares the behavior of a queue, which is often a
first-in, first-out list. However, there are types of queues in which the ordering is based upon
other criteria. Queue is a generic interface that has this declaration:
interface Queue<E>
445446
Part II:
The Java Library
Method Description
E element( ) Returns the element at the head of the queue. The element is not removed. It throws
NoSuchElementException if the queue is empty.
boolean offer(E obj) Attempts to add obj to the queue. Returns true if obj was added and false otherwise.
E peek( ) Returns the element at the head of the queue. It returns null if the queue is empty.
The element is not removed.
E poll( ) Returns the element at the head of the queue, removing the element in the process. It
returns null if the queue is empty.
E remove( ) Removes the element at the head of the queue, returning the element in the process.
It throws NoSuchElementException if the queue is empty.
T ABLE 17-5
The Methods Defined by Queue
Here, E specifies the type of objects that the queue will hold. The methods defined by Queue
are shown in Table 17-5.
Several methods throw a ClassCastException when an object is incompatible with the
elements in the queue. A NullPointerException is thrown if an attempt is made to store a
null object and null elements are not allowed in the queue. An IllegalArgumentException
is thrown if an invalid argument is used. An IllegalStateException is thrown if an attempt is
made to add an element to a fixed-length queue that is full. A NoSuchElementException
is thrown if an attempt is made to remove an element from an empty queue.
Despite its simplicity, Queue offers several points of interest. First, elements can only be
removed from the head of the queue. Second, there are two methods that obtain and remove
elements: poll( ) and remove( ). The difference between them is that poll( ) returns null if the
queue is empty, but remove( ) throws an exception. Third, there are two methods, element( )
and peek( ), that obtain but don’t remove the element at the head of the queue. They differ
only in that element( ) throws an exception if the queue is empty, but peek( ) returns null.
Finally, notice that offer( ) only attempts to add an element to a queue. Because some queues
have a fixed length and might be full, offer( ) can fail.
The Deque Interface
The Deque interface was added by Java SE 6. It extends Queue and declares the behavior of
a double-ended queue. Double-ended queues can function as standard, first-in, first-out
queues or as last-in, first-out stacks. Deque is a generic interface that has this declaration:
interface Deque<E>
Here, E specifies the type of objects that the deque will hold. In addition to the methods that
it inherits from Queue, Deque adds those methods summarized in Table 17-6. Several
methods throw a ClassCastException when an object is incompatible with the elements in
the deque. A NullPointerException is thrown if an attempt is made to store a null object
and null elements are not allowed in the deque. An IllegalArgumentException is thrown if
an invalid argument is used. An IllegalStateException is thrown if an attempt is made to
add an element to a fixed-length deque that is full. A NoSuchElementException is thrown
if an attempt is made to remove an element from an empty deque.
Notice that Deque includes the methods push( ) and pop( ). These methods enable a Deque
to function as a stack. Also, notice the descendingIterator( ) method. It returns an iterator that
returns elements in reverse order. In other words, it returns an iterator that moves from the end
of the collection to the start. A Deque implementation can be capacity-restricted, which meansChapter 17:
java.util Part 1: The Collections Framework
that only a limited number of elements can be added to the deque. When this is the case, an
attempt to add an element to the deque can fail. Deque allows you to handle such a failure in
two ways. First, methods such as addFirst( ) and addLast( ) throw an IllegalStateException if a
Method Description
void addFirst(E obj) Adds obj to the head of the deque. Throws an IllegalStateException
if a capacity-restricted deque is out of space.
void addLast(E obj) Adds obj to the tail of the deque. Throws an IllegalStateException
if a capacity-restricted deque is out of space.
Iterator<E> descendingIterator( ) Returns an iterator that moves from the tail to the head of the
deque. In other words, it returns a reverse iterator.
E getFirst( ) Returns the first element in the deque. The object is not removed
from the deque. It throws NoSuchElementException if the deque
is empty.
E getLast( ) Returns the last element in the deque. The object is not removed
from the deque. It throws NoSuchElementException if the deque is
empty.
boolean offerFirst(E obj) Attempts to add obj to the head of the deque. Returns true if
obj was added and false otherwise. Therefore, this method
returns false when an attempt is made to add obj to a full,
capacity-restricted deque.
boolean offerLast(E obj) Attempts to add obj to the tail of the deque. Returns true if obj
was added and false otherwise.
E peekFirst( ) Returns the element at the head of the deque. It returns null if
the deque is empty. The object is not removed.
E peekLast( ) Returns the element at the tail of the deque. It returns null if the
deque is empty. The object is not removed.
E pollFirst( ) Returns the element at the head of the deque, removing the
element in the process. It returns null if the deque is empty.
E pollLast( ) Returns the element at the tail of the deque, removing the
element in the process. It returns null if the deque is empty.
E pop( ) Returns the element at the head of the deque, removing it in the
process. It throws NoSuchElementException if the deque is empty.
void push(E obj ) Adds obj to the head of the deque. Throws an IllegalStateException
if a capacity-restricted deque is out of space.
E removeFirst( ) Returns the element at the head of the deque, removing the
element in the process. It throws NoSuchElementException if
the deque is empty.
boolean
removeFirstOccurrence(Object obj) Removes the first occurrence of obj from the deque. Returns true
if successful and false if the deque did not contain obj.
E removeLast( ) Returns the element at the tail of the deque, removing the element
in the process. It throws NoSuchElementException if the deque
is empty.
boolean
removeLastOccurrence(Object obj) Removes the last occurrence of obj from the deque. Returns true
if successful and false if the deque did not contain obj.
T ABLE 17-6
The Methods Defined by Deque
447448
Part II:
The Java Library
capacity-restricted deque is full. Second, methods such as offerFirst( ) and offerLast( ) return
false if the element can not be added.
The Collection Classes
Now that you are familiar with the collection interfaces, you are ready to examine the standard
classes that implement them. Some of the classes provide full implementations that can be
used as-is. Others are abstract, providing skeletal implementations that are used as starting
points for creating concrete collections. None of the collection classes are synchronized, but
as you will see later in this chapter, it is possible to obtain synchronized versions.
The standard collection classes are summarized in the following table:
Class Description
AbstractCollection Implements most of the Collection interface.
AbstractList Extends AbstractCollection and implements most of the List interface.
AbstractQueue Extends AbstractCollection and implements parts of the Queue interface.
AbstractSequentialList Extends AbstractList for use by a collection that uses sequential rather than random
access of its elements.
LinkedList Implements a linked list by extending AbstractSequentialList.
ArrayList Implements a dynamic array by extending AbstractList.
ArrayDeque Implements a dynamic double-ended queue by extending AbstractCollection and
implementing the Deque interface. (Added by Java SE 6.)
AbstractSet Extends AbstractCollection and implements most of the Set interface.
EnumSet Extends AbstractSet for use with enum elements.
HashSet Extends AbstractSet for use with a hash table.
LinkedHashSet Extends HashSet to allow insertion-order iterations.
PriorityQueue Extends AbstractQueue to support a priority-based queue.
TreeSet Implements a set stored in a tree. Extends AbstractSet.
The following sections examine the concrete collection classes and illustrate their use.
N OTE In addition to the collection classes, several legacy classes, such as Vector, Stack, and
Hashtable, have been reengineered to support collections. These are examined later in this chapter.
The ArrayList Class
The ArrayList class extends AbstractList and implements the List interface. ArrayList is a
generic class that has this declaration:
class ArrayList<E>
Here, E specifies the type of objects that the list will hold.
ArrayList supports dynamic arrays that can grow as needed. In Java, standard arrays are
of a fixed length. After arrays are created, they cannot grow or shrink, which means that you
must know in advance how many elements an array will hold. But, sometimes, you may not
know until run time precisely how large an array you need. To handle this situation, the
Collections Framework defines ArrayList. In essence, an ArrayList is a variable-length array
of object references. That is, an ArrayList can dynamically increase or decrease in size. ArrayChapter 17:
java.util Part 1: The Collections Framework
lists are created with an initial size. When this size is exceeded, the collection is automatically
enlarged. When objects are removed, the array can be shrunk.
N OTE Dynamic arrays are also supported by the legacy class Vector, which is described later
in this chapter.
ArrayList has the constructors shown here:
ArrayList( )
ArrayList(Collection<? extends E> c)
ArrayList(int capacity)
The first constructor builds an empty array list. The second constructor builds an array list
that is initialized with the elements of the collection c. The third constructor builds an array
list that has the specified initial capacity. The capacity is the size of the underlying array that
is used to store the elements. The capacity grows automatically as elements are added to an
array list.
The following program shows a simple use of ArrayList. An array list is created for objects
of type String, and then several strings are added to it. (Recall that a quoted string is translated
into a String object.) The list is then displayed. Some of the elements are removed and the
list is displayed again.
// Demonstrate ArrayList.
import java.util.*;
class ArrayListDemo 
The output from this program is shown here:
Initial size of al: 0
Size of al after additions: 7
Contents of al: [C, A2, A, E, B, D, F]
Size of al after deletions: 5
Contents of al: [C, A2, E, B, D]
Notice that a1 starts out empty and grows as elements are added to it. When elements are
removed, its size is reduced.
In the preceding example, the contents of a collection are displayed using the default
conversion provided by toString( ), which was inherited from AbstractCollection. Although
it is sufficient for short, sample programs, you seldom use this method to display the contents
of a real-world collection. Usually, you provide your own output routines. But, for the next
few examples, the default output created by toString( ) is sufficient.
Although the capacity of an ArrayList object increases automatically as objects are stored
in it, you can increase the capacity of an ArrayList object manually by calling ensureCapacity( ).
You might want to do this if you know in advance that you will be storing many more items
in the collection than it can currently hold. By increasing its capacity once, at the start, you can
prevent several reallocations later. Because reallocations are costly in terms of time, preventing
unnecessary ones improves performance. The signature for ensureCapacity( ) is shown here:
void ensureCapacity(int cap)
Here, cap is the new capacity.
Conversely, if you want to reduce the size of the array that underlies an ArrayList object so
that it is precisely as large as the number of items that it is currently holding, call trimToSize( ),
shown here:
void trimToSize( )
Obtaining an Array from an ArrayList
When working with ArrayList, you will sometimes want to obtain an actual array that contains
the contents of the list. You can do this by calling toArray( ), which is defined by Collection.
Several reasons exist why you might want to convert a collection into an array, such as:
• To obtain faster processing times for certain operations
• To pass an array to a method that is not overloaded to accept a collection
• To integrate collection-based code with legacy code that does not understand collections
Whatever the reason, converting an ArrayList to an array is a trivial matter.
As explained earlier, there are two versions of toArray( ), which are shown again here
for your convenience:
Object[ ] toArray( )
<T> T[ ] toArray(T array[ ])Chapter 17:
java.util Part 1: The Collections Framework
The first returns an array of Object. The second returns an array of elements that have the
same type as T. Normally, the second form is more convenient because it returns the proper
type of array. The following program demonstrates its use:
// Convert an ArrayList into an array.
import java.util.*;
class ArrayListToArray 
The output from the program is shown here:
Contents of al: [1, 2, 3, 4]
Sum is: 10
The program begins by creating a collection of integers. Next, toArray( ) is called and it
obtains an array of Integers. Then, the contents of that array are summed by use of a for-each
style for loop.
There is something else of interest in this program. As you know, collections can store only
references to, not values of, primitive types. However, autoboxing makes it possible to pass
values of type int to add( ) without having to manually wrap them within an Integer, as the
program shows. Autoboxing causes them to be automatically wrapped. In this way, autoboxing
significantly improves the ease with which collections can be used to store primitive values.
The LinkedList Class
The LinkedList class extends AbstractSequentialList and implements the List, Deque, and
Queue interfaces. It provides a linked-list data structure. LinkedList is a generic class that
has this declaration:
class LinkedList<E>
451452
Part II:
The Java Library
Here, E specifies the type of objects that the list will hold. LinkedList has the two constructors
shown here:
LinkedList( )
LinkedList(Collection<? extends E> c)
The first constructor builds an empty linked list. The second constructor builds a linked list
that is initialized with the elements of the collection c.
Because LinkedList implements the Deque interface, you have access to the methods
defined by Deque. For example, to add elements to the start of a list you can use addFirst( )
or offerFirst( ). To add elements to the end of the list, use addLast( ) or offerLast( ). To
obtain the first element, you can use getFirst( ) or peekFirst( ). To obtain the last element,
use getLast( ) or peekLast( ). To remove the first element, use removeFirst( ) or pollFirst( ).
To remove the last element, use removeLast( ) or pollLast( ).
The following program illustrates LinkedList:
// Demonstrate LinkedList.
import java.util.*;
class LinkedListDemo 
The output from this program is shown here:
Original
Contents
ll after
ll after
contents of ll: [A, A2, F, B, D, E, C, Z]
of ll after deletion: [A, A2, D, E, C, Z]
deleting first and last: [A2, D, E, C]
change: [A2, D, E Changed, C]
Because LinkedList implements the List interface, calls to add(E) append items to the end
of the list, as do calls to addLast( ). To insert items at a specific location, use the add(int, E)
form of add( ), as illustrated by the call to add(1, “A2”) in the example.
Notice how the third element in ll is changed by employing calls to get( ) and set( ). To
obtain the current value of an element, pass get( ) the index at which the element is stored.
To assign a new value to that index, pass set( ) the index and its new value.
The HashSet Class
HashSet extends AbstractSet and implements the Set interface. It creates a collection that
uses a hash table for storage. HashSet is a generic class that has this declaration:
class HashSet<E>
Here, E specifies the type of objects that the set will hold.
As most readers likely know, a hash table stores information by using a mechanism called
hashing. In hashing, the informational content of a key is used to determine a unique value,
called its hash code. The hash code is then used as the index at which the data associated with
the key is stored. The transformation of the key into its hash code is performed automatically—
you never see the hash code itself. Also, your code can’t directly index the hash table. The
advantage of hashing is that it allows the execution time of add( ), contains( ), remove( ), and
size( ) to remain constant even for large sets.
The following constructors are defined:
HashSet( )
HashSet(Collection<? extends E> c)
HashSet(int capacity)
HashSet(int capacity, float fillRatio)
The first form constructs a default hash set. The second form initializes the hash set by using
the elements of c. The third form initializes the capacity of the hash set to capacity. (The default
capacity is 16.) The fourth form initializes both the capacity and the fill ratio (also called load
capacity) of the hash set from its arguments. The fill ratio must be between 0.0 and 1.0, and it
determines how full the hash set can be before it is resized upward. Specifically, when the
number of elements is greater than the capacity of the hash set multiplied by its fill ratio,
the hash set is expanded. For constructors that do not take a fill ratio, 0.75 is used.
HashSet does not define any additional methods beyond those provided by its superclasses
and interfaces.
453454
Part II:
The Java Library
It is important to note that HashSet does not guarantee the order of its elements, because
the process of hashing doesn’t usually lend itself to the creation of sorted sets. If you need
sorted storage, then another collection, such as TreeSet, is a better choice.
Here is an example that demonstrates HashSet:
// Demonstrate HashSet.
import java.util.*;
class HashSetDemo 
The following is the output from this program:
[D, A, F, C, B, E]
As explained, the elements are not stored in sorted order, and the precise output may vary.
The LinkedHashSet Class
The LinkedHashSet class extends HashSet and adds no members of its own. It is a generic
class that has this declaration:
class LinkedHashSet<E>
Here, E specifies the type of objects that the set will hold. Its constructors parallel those in
HashSet.
LinkedHashSet maintains a linked list of the entries in the set, in the order in which they
were inserted. This allows insertion-order iteration over the set. That is, when cycling through
a LinkedHashSet using an iterator, the elements will be returned in the order in which they
were inserted. This is also the order in which they are contained in the string returned by
toString( ) when called on a LinkedHashSet object. To see the effect of LinkedHashSet, try
substituting LinkedHashSet for HashSet in the preceding program. The output will be
[B, A, D, E, C, F]
which is the order in which the elements were inserted.Chapter 17:
java.util Part 1: The Collections Framework
The TreeSet Class
TreeSet extends AbstractSet and implements the NavigableSet interface. It creates a
collection that uses a tree for storage. Objects are stored in sorted, ascending order. Access
and retrieval times are quite fast, which makes TreeSet an excellent choice when storing large
amounts of sorted information that must be found quickly.
TreeSet is a generic class that has this declaration:
class TreeSet<E>
Here, E specifies the type of objects that the set will hold.
TreeSet has the following constructors:
TreeSet( )
TreeSet(Collection<? extends E> c)
TreeSet(Comparator<? super E> comp)
TreeSet(SortedSet<E> ss)
The first form constructs an empty tree set that will be sorted in ascending order according
to the natural order of its elements. The second form builds a tree set that contains the elements
of c. The third form constructs an empty tree set that will be sorted according to the comparator
specified by comp. (Comparators are described later in this chapter.) The fourth form builds
a tree set that contains the elements of ss.
Here is an example that demonstrates a TreeSet:
// Demonstrate TreeSet.
import java.util.*;
class TreeSetDemo 
The output from this program is shown here:
[A, B, C, D, E, F]
As explained, because TreeSet stores its elements in a tree, they are automatically arranged
in sorted order, as the output confirms.
455456
Part II:
The Java Library
Because TreeSet implements the NavigableSet interface (which was added by Java SE 6),
you can use the methods defined by NavigableSet to retrieve elements of a TreeSet. For
example, assuming the preceding program, the following statement uses subSet( ) to obtain a
subset of ts that contains the elements between C (inclusive) and F (exclusive). It then displays
the resulting set.
System.out.println(ts.subSet()("C", "F"));
The output from this statement is shown here:
[C, D, E]
You might want to experiment with the other methods defined by NavigableSet.
The PriorityQueue Class
PriorityQueue extends AbstractQueue and implements the Queue interface. It creates a queue
that is prioritized based on the queue’s comparator. PriorityQueue is a generic class that has
this declaration:
class PriorityQueue<E>
Here, E specifies the type of objects stored in the queue. PriorityQueues are dynamic, growing
as necessary.
PriorityQueue defines the six constructors shown here:
PriorityQueue( )
PriorityQueue(int capacity)
PriorityQueue(int capacity, Comparator<? super E> comp)
PriorityQueue(Collection<? extends E> c)
PriorityQueue(PriorityQueue<? extends E> c)
PriorityQueue(SortedSet<? extends E> c)
The first constructor builds an empty queue. Its starting capacity is 11. The second constructor
builds a queue that has the specified initial capacity. The third constructor builds a queue
with the specified capacity and comparator. The last three constructors create queues that
are initialized with the elements of the collection passed in c. In all cases, the capacity grows
automatically as elements are added.
If no comparator is specified when a PriorityQueue is constructed, then the default
comparator for the type of data stored in the queue is used. The default comparator will order
the queue in ascending order. Thus, the head of the queue will be the smallest value. However,
by providing a custom comparator, you can specify a different ordering scheme. For example,
when storing items that include a time stamp, you could prioritize the queue such that the
oldest items are first in the queue.
You can obtain a reference to the comparator used by a PriorityQueue by calling its
comparator( ) method, shown here:
Comparator<? super E> comparator( )
It returns the comparator. If natural ordering is used for the invoking queue, null is returned.
One word of caution: although you can iterate through a PriorityQueue using an iterator,
the order of that iteration is undefined. To properly use a PriorityQueue, you must call methods
such as offer( ) and poll( ), which are defined by the Queue interface.Chapter 17:
java.util Part 1: The Collections Framework
The ArrayDeque Class
Java SE 6 added the ArrayDeque class, which extends AbstractCollection and implements
the Deque interface. It adds no methods of its own. ArrayDeque creates a dynamic array
and has no capacity restrictions. (The Deque interface supports implementations that
restrict capacity, but does not require such restrictions.) ArrayDeque is a generic class that
has this declaration:
class ArrayDeque<E>
Here, E specifies the type of objects stored in the collection.
ArrayDeque defines the following constructors:
ArrayDeque( )
ArrayDeque(int size)
ArrayDeque(Collection<? extends E> c)
The first constructor builds an empty deque. Its starting capacity is 16. The second
constructor builds a deque that has the specified initial capacity. The third constructor
creates a deque that is initialized with the elements of the collection passed in c. In all cases,
the capacity grows as needed to handle the elements added to the deque.
The following program demonstrates ArrayDeque by using it to create a stack:
// Demonstrate ArrayDeque.
import java.util.*;
class ArrayDequeDemo 
The output is shown here:
Popping the stack: F E D B A
457458
Part II:
The Java Library
The EnumSet Class
EnumSet extends AbstractSet and implements Set. It is specifically for use with keys of an
enum type. It is a generic class that has this declaration:
class EnumSet<E extends Enum<E>>
Here, E specifies the elements. Notice that E must extend Enum<E>, which enforces the
requirement that the elements must be of the specified enum type.
EnumSet defines no constructors. Instead, it uses the factory methods shown in Table 17-7
to create objects. All methods can throw NullPointerException. The copyOf( ) and range( )
methods can also throw IllegalArgumentException. Notice that the of( ) method is overloaded
a number of times. This is in the interest of efficiency. Passing a known number of arguments
can be faster than using a vararg parameter when the number of arguments is small.
Accessing a Collection via an Iterator
Often, you will want to cycle through the elements in a collection. For example, you might
want to display each element. One way to do this is to employ an iterator, which is an object
that implements either the Iterator or the ListIterator interface. Iterator enables you to cycle
through a collection, obtaining or removing elements. ListIterator extends Iterator to allow
Method Description
static <E extends Enum<E>>
EnumSet<E> allOf(Class<E> t) Creates an EnumSet that contains the elements in the
enumeration specified by t.
static <E extends Enum<E>> EnumSet<E>
complementOf(EnumSet<E> e) Creates an EnumSet that is comprised of those elements not
stored in e.
static <E extends Enum<E>>
EnumSet<E> copyOf(EnumSet<E> c) Creates an EnumSet from the elements stored in c.
static <E extends Enum<E>>
EnumSet<E> copyOf(Collection<E> c) Creates an EnumSet from the elements stored in c.
static <E extends Enum<E>>
EnumSet<E> noneOf(Class<E> t) Creates an EnumSet that contains the elements that are not in
the enumeration specified by t, which is an empty set by definition.
static <E extends Enum<E>>
EnumSet<E> of(E v, E ... varargs) Creates an EnumSet that contains v and zero or more
additional enumeration values.
static <E extends Enum<E>>
EnumSet<E> of(E v) Creates an EnumSet that contains v.
static <E extends Enum<E>>
EnumSet<E> of(E v1, E v2) Creates an EnumSet that contains v1 and v2.
static <E extends Enum<E>>
EnumSet<E> of(E v1, E v2, E v3) Creates an EnumSet that contains v1 through v3.
static <E extends Enum<E>>
EnumSet<E> of(E v1, E v2, E v3, E v4) Creates an EnumSet that contains v1 through v4.
static <E extends Enum<E>>
EnumSet<E> of(E v1, E v2, E v3, E v4,
E v5) Creates an EnumSet that contains v1 through v5.
static <E extends Enum<E>>
EnumSet<E> range(E start, E end) Creates an EnumSet that contains the elements in the range
specified by start and end.
T ABLE 17-7
The Methods Defined by EnumSetChapter 17:
java.util Part 1: The Collections Framework
Method Description
boolean hasNext( ) Returns true if there are more elements. Otherwise, returns false.
E next( ) Returns the next element. Throws NoSuchElementException if there is not
a next element.
void remove( ) Removes the current element. Throws IllegalStateException if an attempt
is made to call remove( ) that is not preceded by a call to next( ).
T ABLE 17-8
The Methods Defined by Iterator
bidirectional traversal of a list, and the modification of elements. Iterator and ListIterator
are generic interfaces which are declared as shown here:
interface Iterator<E>
interface ListIterator<E>
Here, E specifies the type of objects being iterated. The Iterator interface declares the methods
shown in Table 17-8. The methods declared by ListIterator are shown in Table 17-9. In both
cases, operations that modify the underlying collection are optional. For example, remove( )
will throw UnsupportedOperationException when used with a read-only collection. Various
other exceptions are possible.
Using an Iterator
Before you can access a collection through an iterator, you must obtain one. Each of the
collection classes provides an iterator( ) method that returns an iterator to the start of
the collection. By using this iterator object, you can access each element in the collection, one
Method Description
void add(E obj) Inserts obj into the list in front of the element that will be returned
by the next call to next( ).
boolean hasNext( ) Returns true if there is a next element. Otherwise, returns false.
boolean hasPrevious( ) Returns true if there is a previous element. Otherwise, returns false.
E next( ) Returns the next element. A NoSuchElementException is thrown
if there is not a next element.
int nextIndex( ) Returns the index of the next element. If there is not a next element,
returns the size of the list.
E previous( ) Returns the previous element. A NoSuchElementException is thrown
if there is not a previous element.
int previousIndex( ) Returns the index of the previous element. If there is not a previous
element, returns −1.
void remove( ) Removes the current element from the list. An IllegalStateException
is thrown if remove( ) is called before next( ) or previous( ) is invoked.
void set(E obj) Assigns obj to the current element. This is the element last returned
by a call to either next( ) or previous( ).
T ABLE 17-9
The Methods Defined by ListIterator
459460
Part II:
The Java Library
element at a time. In general, to use an iterator to cycle through the contents of a collection,
follow these steps:
1. Obtain an iterator to the start of the collection by calling the collection’s iterator( )
method.
2. Set up a loop that makes a call to hasNext( ). Have the loop iterate as long as hasNext( )
returns true.
3. Within the loop, obtain each element by calling next( ).
For collections that implement List, you can also obtain an iterator by calling listIterator( ).
As explained, a list iterator gives you the ability to access the collection in either the forward
or backward direction and lets you modify an element. Otherwise, ListIterator is used just
like Iterator.
The following example implements these steps, demonstrating both the Iterator and
ListIterator interfaces. It uses an ArrayList object, but the general principles apply to any
type of collection. Of course, ListIterator is available only to those collections that implement
the List interface.
// Demonstrate iterators.
import java.util.*;
class IteratorDemo 
The output is shown here:
Original contents of al: C A E B D F
Modified contents of al: C+ A+ E+ B+ D+ F+
Modified list backwards: F+ D+ B+ E+ A+ C+
Pay special attention to how the list is displayed in reverse. After the list is modified, litr
points to the end of the list. (Remember, litr.hasNext( ) returns false when the end of the list
has been reached.) To traverse the list in reverse, the program continues to use litr, but this
time it checks to see whether it has a previous element. As long as it does, that element is
obtained and displayed.
The For-Each Alternative to Iterators
If you won’t be modifying the contents of a collection or obtaining elements in reverse order,
then the for-each version of the for loop is often a more convenient alternative to cycling
through a collection than is using an iterator. Recall that the for can cycle through any collection
of objects that implement the Iterable interface. Because all of the collection classes implement
this interface, they can all be operated upon by the for.
The following example uses a for loop to sum the contents of a collection:
// Use the for-each for loop to cycle through a collection.
import java.util.*;
class ForEachDemo 
The output from the program is shown here:
Original contents of vals: 1 2 3 4 5
Sum of values: 15
As you can see, the for loop is substantially shorter and simpler to use than the iterator-
based approach. However, it can only be used to cycle through a collection in the forward
direction, and you can’t modify the contents of the collection.
Storing User-Defined Classes in Collections
For the sake of simplicity, the foregoing examples have stored built-in objects, such as String
or Integer, in a collection. Of course, collections are not limited to the storage of built-in
objects. Quite the contrary. The power of collections is that they can store any type of object,
including objects of classes that you create. For example, consider the following example that
uses a LinkedList to store mailing addresses:
// A simple mailing list example.
import java.util.*;
class Address Chapter 17:
java.util Part 1: The Collections Framework
class MailList 
The output from the program is shown here:
J.W. West
11 Oak Ave
Urbana IL 61801
Ralph Baker
1142 Maple Lane
Mahomet IL 61853
Tom Carlton
867 Elm St
Champaign IL 61820
Aside from storing a user-defined class in a collection, another important thing to notice
about the preceding program is that it is quite short. When you consider that it sets up a linked
list that can store, retrieve, and process mailing addresses in about 50 lines of code, the power
of the Collections Framework begins to become apparent. As most readers know, if all of this
functionality had to be coded manually, the program would be several times longer. Collections
offer off-the-shelf solutions to a wide variety of programming problems. You should use them
whenever the situation presents itself.
The RandomAccess Interface
The RandomAccess interface contains no members. However, by implementing this interface,
a collection signals that it supports efficient random access to its elements. Although a collection
might support random access, it might not do so efficiently. By checking for the RandomAccess
interface, client code can determine at run time whether a collection is suitable for certain
types of random access operations—especially as they apply to large collections. (You can use
instanceof to determine if a class implements an interface.) RandomAccess is implemented
by ArrayList and by the legacy Vector class, among others.
463464
Part II:
The Java Library
Working with Maps
A map is an object that stores associations between keys and values, or key/value pairs. Given
a key, you can find its value. Both keys and values are objects. The keys must be unique, but
the values may be duplicated. Some maps can accept a null key and null values, others cannot.
There is one key point about maps that is important to mention at the outset: they don’t
implement the Iterable interface. This means that you cannot cycle through a map using a
for-each style for loop. Furthermore, you can’t obtain an iterator to a map. However, as you
will soon see, you can obtain a collection-view of a map, which does allow the use of either
the for loop or an iterator.
The Map Interfaces
Because the map interfaces define the character and nature of maps, this discussion of maps
begins with them. The following interfaces support maps:
Interface Description
Map Maps unique keys to values.
Map.Entry Describes an element (a key/value pair) in a map. This is an inner class of Map.
NavigableMap Extends SortedMap to handle the retrieval of entries based on closest-match
searches. (Added by Java SE 6.)
SortedMap
Extends Map so that the keys are maintained in ascending order.
Each interface is examined next, in turn.
The Map Interface
The Map interface maps unique keys to values. A key is an object that you use to retrieve a
value at a later date. Given a key and a value, you can store the value in a Map object. After
the value is stored, you can retrieve it by using its key. Map is generic and is declared as
shown here:
interface Map<K, V>
Here, K specifies the type of keys, and V specifies the type of values.
The methods declared by Map are summarized in Table 17-10. Several methods
throw a ClassCastException when an object is incompatible with the elements in a map. A
NullPointerException is thrown if an attempt is made to use a null object and null is not
allowed in the map. An UnsupportedOperationException is thrown when an attempt is
made to change an unmodifiable map. An IllegalArgumentException is thrown if an
invalid argument is used.
Maps revolve around two basic operations: get( ) and put( ). To put a value into a map,
use put( ), specifying the key and the value. To obtain a value, call get( ), passing the key as
an argument. The value is returned.
As mentioned earlier, although part of the Collections Framework, maps are not,
themselves, collections because they do not implement the Collection interface. However,
you can obtain a collection-view of a map. To do this, you can use the entrySet( ) method. It
returns a Set that contains the elements in the map. To obtain a collection-view of the keys,Chapter 17:
java.util Part 1: The Collections Framework
Method Description
void clear( ) Removes all key/value pairs from the invoking map.
boolean containsKey(Object k) Returns true if the invoking map contains k as a key. Otherwise,
returns false.
boolean containsValue(Object v) Returns true if the map contains v as a value. Otherwise, returns false.
Set<Map.Entry<K, V>> entrySet( ) Returns a Set that contains the entries in the map. The set contains
objects of type Map.Entry. Thus, this method provides a set-view of the
invoking map.
boolean equals(Object obj) Returns true if obj is a Map and contains the same entries. Otherwise,
returns false.
V get(Object k) Returns the value associated with the key k. Returns null if the key is
not found.
int hashCode( ) Returns the hash code for the invoking map.
boolean isEmpty( ) Returns true if the invoking map is empty. Otherwise, returns false.
Set<K> keySet( ) Returns a Set that contains the keys in the invoking map. This method
provides a set-view of the keys in the invoking map.
V put(K k, V v) Puts an entry in the invoking map, overwriting any previous value
associated with the key. The key and value are k and v, respectively.
Returns null if the key did not already exist. Otherwise, the previous
value linked to the key is returned.
void putAll(Map<? extends K,
void putAll(Map<? extends V> m) Puts all the entries from m into this map.
V remove(Object k) Removes the entry whose key equals k.
int size( ) Returns the number of key/value pairs in the map.
Collection<V> values( ) Returns a collection containing the values in the map. This method
provides a collection-view of the values in the map.
T ABLE 17-10
The Methods Defined by Map
use keySet( ). To get a collection-view of the values, use values( ). Collection-views are the
means by which maps are integrated into the larger Collections Framework.
The SortedMap Interface
The SortedMap interface extends Map. It ensures that the entries are maintained in ascending
order based on the keys. SortedMap is generic and is declared as shown here:
interface SortedMap<K, V>
Here, K specifies the type of keys, and V specifies the type of values.
The methods declared by SortedMap are summarized in Table 17-11. Several methods throw
a NoSuchElementException when no items are in the invoking map. A ClassCastException
is thrown when an object is incompatible with the elements in a map. A NullPointerException
is thrown if an attempt is made to use a null object when null is not allowed in the map. An
IllegalArgumentException is thrown if an invalid argument is used.
Sorted maps allow very efficient manipulations of submaps (in other words, subsets of a
map). To obtain a submap, use headMap( ), tailMap( ), or subMap( ). To get the first key in
the set, call firstKey( ). To get the last key, use lastKey( ).
465466
Part II:
The Java Library
Method Description
Comparator<? super K> comparator( ) Returns the invoking sorted map’s comparator. If natural
ordering is used for the invoking map, null is returned.
K firstKey( ) Returns the first key in the invoking map.
SortedMap<K, V> headMap(K end) Returns a sorted map for those map entries with keys that are
less than end.
K lastKey( ) Returns the last key in the invoking map.
SortedMap<K, V> subMap(K start, K end) Returns a map containing those entries with keys that are
greater than or equal to start and less than end.
SortedMap<K, V> tailMap(K start) Returns a map containing those entries with keys that are
greater than or equal to start.
T ABLE 17-11
The Methods Defined by SortedMap
The NavigableMap Interface
The NavigableMap interface was added by Java SE 6. It extends SortedMap and declares
the behavior of a map that supports the retrieval of entries based on the closest match to a
given key or keys. NavigableMap is a generic interface that has this declaration:
interface NavigableMap<K,V>
Here, K specifies the type of the keys, and V specifies the type of the values associated with
the keys. In addition to the methods that it inherits from SortedMap, NavigableMap adds
those summarized in Table 17-12. Several methods throw a ClassCastException when
an object is incompatible with the keys in the map. A NullPointerException is thrown
if an attempt is made to use a null object and null keys are not allowed in the set. An
IllegalArgumentException is thrown if an invalid argument is used.
Method Description
Map.Entry<K,V> ceilingEntry(K obj) Searches the map for the smallest key k such that k >= obj. If such a key
is found, its entry is returned. Otherwise, null is returned.
K ceilingKey(K obj) Searches the map for the smallest key k such that k >= obj. If such a key
is found, it is returned. Otherwise, null is returned.
NavigableSet<K> descendingKeySet( ) Returns a NavigableSet that contains the keys in the invoking map in
reverse order. Thus, it returns a reverse set-view of the keys. The
resulting set is backed by the map.
NavigableMap<K,V> descendingMap( ) Returns a NavigableMap that is the reverse of the invoking map. The
resulting map is backed by the invoking map.
Map.Entry<K,V> firstEntry( ) Returns the first entry in the map. This is the entry with the least key.
Map.Entry<K,V> floorEntry(K obj) Searches the map for the largest key k such that k <= obj. If such a key
is found, its entry is returned. Otherwise, null is returned.
K floorKey(K obj) Searches the map for the largest key k such that k <= obj. If such a key
is found, it is returned. Otherwise, null is returned.
NavigableMap<K,V>
headMap(K upperBound, boolean incl) Returns a NavigableMap that includes all entries from the invoking map
that have keys that are less than upperBound. If incl is true, then an
element equal to upperBound is included. The resulting map is backed by
the invoking map.
Map.Entry<K,V> higherEntry(K obj) Searches the set for the largest key k such that k > obj. If such a key is
found, its entry is returned. Otherwise, null is returned.
T ABLE 17-12
The Methods defined by NavigableMapChapter 17:
java.util Part 1: The Collections Framework
Method Description
K higherKey(K obj) Searches the set for the largest key k such that k > obj. If such a key is
found, it is returned. Otherwise, null is returned.
Map.Entry<K,V> lastEntry( ) Returns the last entry in the map. This is the entry with the largest key.
Map.Entry<K,V> lowerEntry(K obj) Searches the set for the largest key k such that k < obj. If such a key is
found, its entry is returned. Otherwise, null is returned.
K lowerKey(K obj) Searches the set for the largest key k such that k < obj. If such a key is
found, it is returned. Otherwise, null is returned.
NavigableSet<K> navigableKeySet( ) Returns a NavigableSet that contains the keys in the invoking map. The
resulting set is backed by the invoking map.
Map.Entry<K,V> pollFirstEntry( ) Returns the first entry, removing the entry in the process. Because the
map is sorted, this is the entry with the least key value. null is returned if
the map is empty.
Map.Entry<K,V> pollLastEntry( ) Returns the last entry, removing the entry in the process. Because the
map is sorted, this is the entry with the greatest key value. null is
returned if the map is empty.
NavigableMap<K,V>
subMap(K lowerBound,
boolean lowIncl,
K upperBound
boolean highIncl) Returns a NavigableMap that includes all entries from the invoking map
that have keys that are greater than lowerBound and less than
upperBound. If lowIncl is true, then an element equal to lowerBound is
included. If highIncl is true, then an element equal to highIncl is included.
The resulting map is backed by the invoking map.
NavigableMap<K,V>
tailMap(K lowerBound, boolean incl) Returns a NavigableMap that includes all entries from the invoking map
that have keys that are greater than lowerBound. If incl is true, then an
element equal to lowerBound is included. The resulting map is backed by
the invoking map.
T ABLE 17-12
The Methods defined by NavigableMap (continued)
The Map.Entry Interface
The Map.Entry interface enables you to work with a map entry. Recall that the entrySet( )
method declared by the Map interface returns a Set containing the map entries. Each of these
set elements is a Map.Entry object. Map.Entry is generic and is declared like this:
interface Map.Entry<K, V>
Here, K specifies the type of keys, and V specifies the type of values. Table 17-13 summarizes
the methods declared by Map.Entry. Various exceptions are possible.
Method Description
boolean equals(Object obj) Returns true if obj is a Map.Entry whose key and value are equal to that of the
invoking object.
K getKey( ) Returns the key for this map entry.
V getValue( ) Returns the value for this map entry.
int hashCode( ) Returns the hash code for this map entry.
V setValue(V v) Sets the value for this map entry to v. A ClassCastException is thrown if v is not
the correct type for the map. An IllegalArgumentException is thrown if there is
a problem with v. A NullPointerException is thrown if v is null and the map does
not permit null keys. An UnsupportedOperationException is thrown if the map
cannot be changed.
T ABLE 17-13
The Methods Defined by Map.Entry
467468
Part II:
The Java Library
The Map Classes
Several classes provide implementations of the map interfaces. The classes that can be used
for maps are summarized here:
Class Description
AbstractMap Implements most of the Map interface.
EnumMap Extends AbstractMap for use with enum keys.
HashMap Extends AbstractMap to use a hash table.
TreeMap Extends AbstractMap to use a tree.
WeakHashMap Extends AbstractMap to use a hash table with weak keys.
LinkedHashMap Extends HashMap to allow insertion-order iterations.
IdentityHashMap Extends AbstractMap and uses reference equality when comparing documents.
Notice that AbstractMap is a superclass for all concrete map implementations.
WeakHashMap implements a map that uses “weak keys,” which allows an element in
a map to be garbage-collected when its key is otherwise unused. This class is not discussed
further here. The other map classes are described next.
The HashMap Class
The HashMap class extends AbstractMap and implements the Map interface. It uses a hash
table to store the map. This allows the execution time of get( ) and put( ) to remain constant
even for large sets. HashMap is a generic class that has this declaration:
class HashMap<K, V>
Here, K specifies the type of keys, and V specifies the type of values.
The following constructors are defined:
HashMap( )
HashMap(Map<? extends K, ? extends V> m)
HashMap(int capacity)
HashMap(int capacity, float fillRatio)
The first form constructs a default hash map. The second form initializes the hash map by
using the elements of m. The third form initializes the capacity of the hash map to capacity. The
fourth form initializes both the capacity and fill ratio of the hash map by using its arguments.
The meaning of capacity and fill ratio is the same as for HashSet, described earlier. The
default capacity is 16. The default fill ratio is 0.75.
HashMap implements Map and extends AbstractMap. It does not add any methods of
its own.
You should note that a hash map does not guarantee the order of its elements. Therefore,
the order in which elements are added to a hash map is not necessarily the order in which
they are read by an iterator.
The following program illustrates HashMap. It maps names to account balances. Notice
how a set-view is obtained and used.Chapter 17:
java.util Part 1: The Collections Framework
import java.util.*;
class HashMapDemo 
Output from this program is shown here (the precise order may vary):
Ralph Smith: -19.08
Tom Smith: 123.22
John Doe: 3434.34
Tod Hall: 99.22
Jane Baker: 1378.0
John Doe’s new balance: 4434.34
The program begins by creating a hash map and then adds the mapping of names to
balances. Next, the contents of the map are displayed by using a set-view, obtained by calling
entrySet( ). The keys and values are displayed by calling the getKey( ) and getValue( ) methods
that are defined by Map.Entry. Pay close attention to how the deposit is made into John Doe’s
account. The put( ) method automatically replaces any preexisting value that is associated
with the specified key with the new value. Thus, after John Doe’s account is updated, the
hash map will still contain just one “John Doe” account.
469470
Part II:
The Java Library
The TreeMap Class
The TreeMap class extends AbstractMap and implements the NavigableMap interface.
It creates maps stored in a tree structure. A TreeMap provides an efficient means of storing
key/value pairs in sorted order and allows rapid retrieval. You should note that, unlike a
hash map, a tree map guarantees that its elements will be sorted in ascending key order.
TreeMap is a generic class that has this declaration:
class TreeMap<K, V>
Here, K specifies the type of keys, and V specifies the type of values.
The following TreeMap constructors are defined:
TreeMap( )
TreeMap(Comparator<? super K> comp)
TreeMap(Map<? extends K, ? extends V> m)
TreeMap(SortedMap<K, ? extends V> sm)
The first form constructs an empty tree map that will be sorted by using the natural order of
its keys. The second form constructs an empty tree-based map that will be sorted by using the
Comparator comp. (Comparators are discussed later in this chapter.) The third form initializes
a tree map with the entries from m, which will be sorted by using the natural order of the
keys. The fourth form initializes a tree map with the entries from sm, which will be sorted in
the same order as sm.
TreeMap has no methods beyond those specified by the NavigableMap interface and
the AbstractMap class.
The following program reworks the preceding example so that it uses TreeMap:
import java.util.*;
class TreeMapDemo 
The following is the output from this program:
Jane Baker: 1378.0
John Doe: 3434.34
Ralph Smith: -19.08
Todd Hall: 99.22
Tom Smith: 123.22
John Doe’s current balance: 4434.34
Notice that TreeMap sorts the keys. However, in this case, they are sorted by first name
instead of last name. You can alter this behavior by specifying a comparator when the map
is created, as described shortly.
The LinkedHashMap Class
LinkedHashMap extends HashMap. It maintains a linked list of the entries in the map, in the
order in which they were inserted. This allows insertion-order iteration over the map. That is,
when iterating through a collection-view of a LinkedHashMap, the elements will be returned
in the order in which they were inserted. You can also create a LinkedHashMap that returns
its elements in the order in which they were last accessed. LinkedHashMap is a generic class
that has this declaration:
class LinkedHashMap<K, V>
Here, K specifies the type of keys, and V specifies the type of values.
LinkedHashMap defines the following constructors:
LinkedHashMap( )
LinkedHashMap(Map<? extends K, ? extends V> m)
LinkedHashMap(int capacity)
LinkedHashMap(int capacity, float fillRatio)
LinkedHashMap(int capacity, float fillRatio, boolean Order)
The first form constructs a default LinkedHashMap. The second form initializes the
LinkedHashMap with the elements from m. The third form initializes the capacity. The fourth
form initializes both capacity and fill ratio. The meaning of capacity and fill ratio are the same
as for HashMap. The default capactiy is 16. The default ratio is 0.75. The last form allows
you to specify whether the elements will be stored in the linked list by insertion order, or by
order of last access. If Order is true, then access order is used. If Order is false, then insertion
order is used.
471472
Part II:
The Java Library
LinkedHashMap adds only one method to those defined by HashMap. This method is
removeEldestEntry( ) and it is shown here:
protected boolean removeEldestEntry(Map.Entry<K, V> e)
This method is called by put( ) and putAll( ). The oldest entry is passed in e. By default, this
method returns false and does nothing. However, if you override this method, then you can
have the LinkedHashMap remove the oldest entry in the map. To do this, have your override
return true. To keep the oldest entry, return false.
The IdentityHashMap Class
IdentityHashMap extends AbstractMap and implements the Map interface. It is similar to
HashMap except that it uses reference equality when comparing elements. IdentityHashMap
is a generic class that has this declaration:
class IdentityHashMap<K, V>
Here, K specifies the type of key, and V specifies the type of value. The API documentation
explicitly states that IdentityHashMap is not for general use.
The EnumMap Class
EnumMap extends AbstractMap and implements Map. It is specifically for use with keys of
an enum type. It is a generic class that has this declaration:
class EnumMap<K extends Enum<K>, V>
Here, K specifies the type of key, and V specifies the type of value. Notice that K must extend
Enum<K>, which enforces the requirement that the keys must be of an enum type.
EnumMap defines the following constructors:
EnumMap(Class<K> kType)
EnumMap(Map<K, ? extends V> m)
EnumMap(EnumMap<K, ? extends V> em)
The first constructor creates an empty EnumMap of type kType. The second creates an
EnumMap map that contains the same entries as m. The third creates an EnumMap initialized
with the values in em.
EnumMap defines no methods of its own.
Comparators
Both TreeSet and TreeMap store elements in sorted order. However, it is the comparator that
defines precisely what “sorted order” means. By default, these classes store their elements
by using what Java refers to as “natural ordering,” which is usually the ordering that you
would expect (A before B, 1 before 2, and so forth). If you want to order elements a different
way, then specify a Comparator when you construct the set or map. Doing so gives you the
ability to govern precisely how elements are stored within sorted collections and maps.
Comparator is a generic interface that has this declaration:
interface Comparator<T>
Here, T specifies the type of objects being compared.Chapter 17:
java.util Part 1: The Collections Framework
The Comparator interface defines two methods: compare( ) and equals( ). The compare( )
method, shown here, compares two elements for order:
int compare(T obj1, T obj2)
obj1 and obj2 are the objects to be compared. This method returns zero if the objects are equal.
It returns a positive value if obj1 is greater than obj2. Otherwise, a negative value is returned.
The method can throw a ClassCastException if the types of the objects are not compatible
for comparison. By overriding compare( ), you can alter the way that objects are ordered. For
example, to sort in reverse order, you can create a comparator that reverses the outcome of
a comparison.
The equals( ) method, shown here, tests whether an object equals the invoking comparator:
boolean equals(Object obj)
Here, obj is the object to be tested for equality. The method returns true if obj and the invoking
object are both Comparator objects and use the same ordering. Otherwise, it returns false.
Overriding equals( ) is unnecessary, and most simple comparators will not do so.
Using a Comparator
The following is an example that demonstrates the power of a custom comparator. It
implements the compare( ) method for strings that operates in reverse of normal. Thus,
it causes a tree set to be stored in reverse order.
// Use a custom comparator.
import java.util.*;
// A reverse comparator for strings.
class MyComp implements Comparator<String> 
class CompDemo 
As the following output shows, the tree is now stored in reverse order:
F E D C B A
Look closely at the MyComp class, which implements Comparator and overrides
compare( ). (As explained earlier, overriding equals( ) is neither necessary nor common.)
Inside compare( ), the String method compareTo( ) compares the two strings. However, bStr—
not aStr—invokes compareTo( ). This causes the outcome of the comparison to be reversed.
For a more practical example, the following program is an updated version of the TreeMap
program shown earlier that stores account balances. In the previous version, the accounts
were sorted by name, but the sorting began with the first name. The following program sorts
the accounts by last name. To do so, it uses a comparator that compares the last name of each
account. This results in the map being sorted by last name.
// Use a comparator to sort accounts by last name.
import java.util.*;
// Compare last whole words in two strings.
class TComp implements Comparator<String> 
class TreeMapDemo2 
Here is the output; notice that the accounts are now sorted by last name:
Jane Baker: 1378.0
John Doe: 3434.34
Todd Hall: 99.22
Ralph Smith: -19.08
Tom Smith: 123.22
John Doe’s new balance: 4434.34
The comparator class TComp compares two strings that hold first and last names. It does
so by first comparing last names. To do this, it finds the index of the last space in each string
and then compares the substrings of each element that begin at that point. In cases where last
names are equivalent, the first names are then compared. This yields a tree map that is sorted
by last name, and within last name by first name. You can see this because Ralph Smith comes
before Tom Smith in the output.
The Collection Algorithms
The Collections Framework defines several algorithms that can be applied to collections and
maps. These algorithms are defined as static methods within the Collections class. They are
summarized in Table 17-14. As explained earlier, beginning with JDK 5 all of the algorithms
have been retrofitted for generics. Although the generic syntax might seem a bit intimidating
at first, the algorithms are as simple to use as they were before generics. It’s just that now,
they are type safe.
475476
Part II:
The Java Library
Method Description
static <T> boolean
addAll(Collection <? super T> c,
T ... elements) Inserts the elements specified by elements into the
collection specified by c. Returns true if the
elements were added and false otherwise.
static <T> Queue<T> asLifoQueue(Deque<T> c) Returns a last-in, first-out view of c. (Added by Java
SE 6.)
static <T>
int binarySearch(List<? extends T> list,
T value,
Comparator<? super T> c) Searches for value in list ordered according to c.
Returns the position of value in list, or a negative
value if value is not found.
static <T>
int binarySearch(List<? extends
Comparable<? super T>> list,
T value) Searches for value in list. The list must be sorted.
Returns the position of value in list, or a negative
value if value is not found.
static <E> Collection<E>
checkedCollection(Collection<E> c,
Class<E> t) Returns a run-time type-safe view of a collection.
An attempt to insert an incompatible element will
cause a ClassCastException.
static <E> List<E>
checkedList(List<E> c, Class<E> t) Returns a run-time type-safe view of a List. An
attempt to insert an incompatible element will
cause a ClassCastException.
static <K, V> Map<K, V>
checkedMap(Map<K, V> c,
Class<K> keyT,
Class<V> valueT) Returns a run-time type-safe view of a Map. An
attempt to insert an incompatible element will
cause a ClassCastException.
static <E> List<E>
checkedSet(Set<E> c, Class<E> t) Returns a run-time type-safe view of a Set. An
attempt to insert an incompatible element will
cause a ClassCastException.
static <K, V> SortedMap<K, V>
checkedSortedMap(SortedMap<K, V> c,
Class<K> keyT,
Class<V> valueT) Returns a run-time type-safe view of a SortedMap.
An attempt to insert an incompatible element will
cause a ClassCastException.
static <E> SortedSet<E>
checkedSortedSet(SortedSet<E> c, Class<E> t) Returns a run-time type-safe view of a SortedSet.
An attempt to insert an incompatible element will
cause a ClassCastException.
static <T> void copy(List<? super T> list1,
List<? extends T> list2) Copies the elements of list2 to list1.
static boolean disjoint(Collection<?> a,
Collection<?> b) Compares the elements in a to elements in b.
Returns true if the two collections contain no
common elements (i.e., the collections contain
disjoint sets of elements). Otherwise, returns true.
static <T> List<T> emptyList( ) Returns an immutable, empty List object of the
inferred type.
static <K, V> Map<K, V> emptyMap( ) Returns an immutable, empty Map object of the
inferred type.
static <T> Set<T> emptySet( ) Returns an immutable, empty Set object of the
inferred type.
static <T> Enumeration<T>
enumeration(Collection<T> c) Returns an enumeration over c. (See “The
Enumeration Interface,” later in this chapter.)
static <T> void fill(List<? super T> list, T obj) Assigns obj to each element of list.
T ABLE 17-14
The Algorithms Defined by CollectionsChapter 17:
java.util Part 1: The Collections Framework
Method Description
static int frequency(Collection<?> c, Object obj) Counts the number of occurrences of obj in c and
returns the result.
static int indexOfSubList(List<?> list,
List<?> subList) Searches list for the first occurrence of subList.
Returns the index of the first match, or –1 if no
match is found.
static int lastIndexOfSubList(List<?> list,
List<?> subList) Searches list for the last occurrence of subList.
Returns the index of the last match, or –1 if no
match is found.
static <T>
ArrayList<T> list(Enumeration<T> enum) Returns an ArrayList that contains the elements
of enum.
static <T> T max(Collection<? extends T> c,
Comparator<? super T> comp) Returns the maximum element in c as determined
by comp.
static <T extends Object &
Comparable<? super T>>
T max(Collection<? extends T> c) Returns the maximum element in c as determined
by natural ordering. The collection need not be
sorted.
static <T> T min(Collection<? extends T> c,
Comparator<? super T> comp) Returns the minimum element in c as determined
by comp. The collection need not be sorted.
static <T extends Object &
Comparable<? superT>>
T min(Collection<? extends T> c) Returns the minimum element in c as determined
by natural ordering.
static <T> List<T> nCopies(int num, T obj) Returns num copies of obj contained in an immutable
list. num must be greater than or equal to zero.
static <E> Set<E> newSetFromMap(Map<E, Boolean> m) Creates and returns a set backed by the map
specified by m, which must be empty at the time
this method is called. (Added by Java SE 6.)
static <T> boolean replaceAll(List<T> list,
T old, T new) Replaces all occurrences of old with new in list.
Returns true if at least one replacement occurred.
Returns false, otherwise.
static void reverse(List<T> list) Reverses the sequence in list.
static <T> Comparator<T>
reverseOrder(Comparator<T> comp) Returns a reverse comparator based on the one
passed in comp. That is, the returned comparator
reverses the outcome of a comparison that uses
comp.
static <T> Comparator<T> reverseOrder( ) Returns a reverse comparator, which is a
comparator that reverses the outcome of a
comparison between two elements.
static void rotate(List<T> list, int n) Rotates list by n places to the right. To rotate left,
use a negative value for n.
static void shuffle(List<T> list, Random r) Shuffles (i.e., randomizes) the elements in list by
using r as a source of random numbers.
static void shuffle(List<T> list) Shuffles (i.e., randomizes) the elements in list.
static <T> Set<T> singleton(T obj) Returns obj as an immutable set. This is an easy
way to convert a single object into a set.
static <T> List<T> singletonList(T obj) Returns obj as an immutable list. This is an easy
way to convert a single object into a list.
static <K, V> Map<K, V>
singletonMap(K k, V v) Returns the key/value pair k/v as an immutable
map. This is an easy way to convert a single key/
value pair into a map.
T ABLE 17-14
The Algorithms Defined by Collections (continued)
477478
Part II:
The Java Library
Method Description
static <T>
void sort(List<T> list,
Comparator<? super T> comp) Sorts the elements of list as determined by comp.
static <T extends Comparable<? super T>>
void sort(List<T> list) Sorts the elements of list as determined by their
natural ordering.
static void swap(List<?> list,
int idx1, int idx2) Exchanges the elements in list at the indices
specified by idx1 and idx2.
static <T> Collection<T>
synchronizedCollection(Collection<T> c) Returns a thread-safe collection backed by c.
static <T> List<T> synchronizedList(List<T> list) Returns a thread-safe list backed by list.
static <K, V> Map<K, V>
synchronizedMap(Map<K, V> m) Returns a thread-safe map backed by m.
static <T> Set<T> synchronizedSet(Set<T> s) Returns a thread-safe set backed by s.
static <K, V> SortedMap<K, V>
synchronizedSortedMap(SortedMap<K, V> sm) Returns a thread-safe sorted map backed by sm.
static <T> SortedSet<T>
synchronizedSortedSet(SortedSet<T> ss) Returns a thread-safe set backed by ss.
static <T> Collection<T>
unmodifiableCollection(
Collection<? extends T> c) Returns an unmodifiable collection backed by c.
static <T> List<T>
unmodifiableList(List<? extends T> list) Returns an unmodifiable list backed by list.
static <K, V> Map<K, V>
unmodifiableMap(Map<? extends K,
? extends V> m) Returns an unmodifiable map backed by m.
static <T> Set<T>
unmodifiableSet(Set<? extends T> s) Returns an unmodifiable set backed by s.
static <K, V> SortedMap<K, V>
unmodifiableSortedMap(SortedMap<K,
? extends V> sm) Returns an unmodifiable sorted map backed
by sm.
static <T> SortedSet<T>
unmodifiableSortedSet(SortedSet<T> ss) Returns an unmodifiable sorted set backed by ss.
T ABLE 17-14
The Algorithms Defined by Collections (continued)
Several of the methods can throw a ClassCastException, which occurs when an attempt
is made to compare incompatible types, or an UnsupportedOperationException, which occurs
when an attempt is made to modify an unmodifiable collection. Other exceptions are
possible, depending on the method.
One thing to pay special attention to is the set of checked methods, such as
checkedCollection( ), which returns what the API documentation refers to as a “dynamically
typesafe view” of a collection. This view is a reference to the collection that monitors insertions
into the collection for type compatibility at run time. An attempt to insert an incompatible
element will cause a ClassCastException. Using such a view is especially helpful during
debugging because it ensures that the collection always contains valid elements. Related
methods include checkedSet( ), checkedList( ), checkedMap( ), and so on. They obtain a
type-safe view for the indicated collection.Chapter 17:
java.util Part 1: The Collections Framework
Notice that several methods, such as synchronizedList( ) and synchronizedSet( ), are used
to obtain synchronized (thread-safe) copies of the various collections. As explained, none of
the standard collections implementations are synchronized. You must use the synchronization
algorithms to provide synchronization. One other point: iterators to synchronized collections
must be used within synchronized blocks.
The set of methods that begins with unmodifiable returns views of the various collections
that cannot be modified. These will be useful when you want to grant some process read—
but not write—capabilities on a collection.
Collections defines three static variables: EMPTY_SET, EMPTY_LIST, and EMPTY_MAP.
All are immutable.
The following program demonstrates some of the algorithms. It creates and initializes a
linked list. The reverseOrder( ) method returns a Comparator that reverses the comparison of
Integer objects. The list elements are sorted according to this comparator and then are displayed.
Next, the list is randomized by calling shuffle( ), and then its minimum and maximum values
are displayed.
// Demonstrate various algorithms.
import java.util.*;
class AlgorithmsDemo 
Output from this program is shown here:
List sorted in reverse: 20 8 -8 -20
List shuffled: 20 -20 8 -8
Minimum: -20
Maximum: 20
Notice that min( ) and max( ) operate on the list after it has been shuffled. Neither requires
a sorted list for its operation.
Arrays
The Arrays class provides various methods that are useful when working with arrays. These
methods help bridge the gap between collections and arrays. Each method defined by
Arrays is examined in this section.
The asList( ) method returns a List that is backed by a specified array. In other words,
both the list and the array refer to the same location. It has the following signature:
static <T> List asList(T ... array)
Here, array is the array that contains the data.
The binarySearch( ) method uses a binary search to find a specified value. This method
must be applied to sorted arrays. Here are some of its forms. (Java SE 6 adds several others.)
static int binarySearch(byte array[ ], byte value)
static int binarySearch(char array[ ], char value)
static int binarySearch(double array[ ], double value)
static int binarySearch(float array[ ], float value)
static int binarySearch(int array[ ], int value)
static int binarySearch(long array[ ], long value)
static int binarySearch(short array[ ], short value)
static int binarySearch(Object array[ ], Object value)
static <T> int binarySearch(T[ ] array, T value, Comparator<? super T> c)
Here, array is the array to be searched, and value is the value to be located. The last two forms
throw a ClassCastException if array contains elements that cannot be compared (for example,
Double and StringBuffer) or if value is not compatible with the types in array. In the last form,
the Comparator c is used to determine the order of the elements in array. In all cases, if value
exists in array, the index of the element is returned. Otherwise, a negative value is returned.
The copyOf( ) method was added by Java SE 6. It returns a copy of an array and has the
following forms:
static boolean[ ] copyOf(boolean[ ] source, int len)
static byte[ ] copyOf(byte[ ] source, int len)
static char[ ] copyOf(char[ ] source, int len)
static double[ ] copyOf(double[ ] source, int len)
static float[ ] copyOf(float[ ] source, int len)Chapter 17:
java.util Part 1: The Collections Framework
static int[ ] copyOf(int[ ] source, int len)
static long[ ] copyOf(long[ ] source, int len)
static short[ ] copyOf(short[ ] source, int len)
static <T> T[ ] copyOf(T[ ] source, int len)
static <T,U> T[ ] copyOf(U[ ] source, int len, Class<? extends T[ ]> resultT)
The original array is specified by source, and the length of the copy is specified by len. If the
copy is longer than source, then the copy is padded with zeros (for numeric arrays), nulls
(for object arrays), or false (for boolean arrays). If the copy is shorter than source, then the
copy is truncated. In the last form, the type of resultT becomes the type of the array
returned. If len is negative, a NegativeArraySizeException is thrown. If source is null,
a NullPointerException is thrown. If resultT is incompatible with the type of source, an
ArrayStoreException is thrown.
The copyOfRange( ) method was also added by Java SE 6. It returns a copy of a range
within an array and has the following forms:
static boolean[ ] copyOfRange(boolean[ ] source, int start, int end)
static byte[ ] copyOfRange(byte[ ] source, int start, int end)
static char[ ] copyOfRange(char[ ] source, int start, int end)
static double[ ] copyOfRange(double[ ] source, int start, int end)
static float[ ] copyOfRange(float[ ] source, int start, int end)
static int[ ] copyOfRange(int[ ] source, int start, int end)
static long[ ] copyOfRange(long[ ] source, int start, int end)
static short[ ] copyOfRange(short[ ] source, int start, int end)
static <T> T[ ] copyOfRange(T[ ] source, int start, int end)
static <T,U> T[ ] copyOfRange(U[ ] source, int start, int end,
Class<? extends T[ ]> resultT)
The original array is specified by source. The range to copy is specified by the indices
passed via start and end. The range runs from start to end –1. If the range is longer than source,
then the copy is padded with zeros (for numeric arrays), nulls (for object arrays), or false (for
boolean arrays). In the last form, the type of resultT becomes the type of the array returned. If
start is negative or greater than the length of source, an ArrayIndexOutOfBoundsException is
thrown. If start is greater than end, an IllegalArgumentException is thrown. If source is null, a
NullPointerException is thrown. If resultT is incompatible with the type of source, an
ArrayStoreException is thrown.
The equals( ) method returns true if two arrays are equivalent. Otherwise, it returns false.
The equals( ) method has the following forms:
static boolean equals(boolean array1[ ], boolean array2[ ])
static boolean equals(byte array1[ ], byte array2[ ])
static boolean equals(char array1[ ], char array2[ ])
static boolean equals(double array1[ ], double array2[ ])
static boolean equals(float array1[ ], float array2[ ])
static boolean equals(int array1[ ], int array2[ ])
static boolean equals(long array1[ ], long array2[ ])
static boolean equals(short array1[ ], short array2[ ])
static boolean equals(Object array1[ ], Object array2[ ])
Here, array1 and array2 are the two arrays that are compared for equality.
481482
Part II:
The Java Library
The deepEquals( ) method can be used to determine if two arrays, which might contain
nested arrays, are equal. It has this declaration:
static boolean deepEquals(Object[ ] a, Object[ ] b)
It returns true if the arrays passed in a and b contain the same elements. If a and b contain
nested arrays, then the contents of those nested arrays are also checked. It returns false if
the arrays, or any nested arrays, differ.
The fill( ) method assigns a value to all elements in an array. In other words, it fills an
array with a specified value. The fill( ) method has two versions. The first version, which
has the following forms, fills an entire array:
static void fill(boolean array[ ], boolean value)
static void fill(byte array[ ], byte value)
static void fill(char array[ ], char value)
static void fill(double array[ ], double value)
static void fill(float array[ ], float value)
static void fill(int array[ ], int value)
static void fill(long array[ ], long value)
static void fill(short array[ ], short value)
static void fill(Object array[ ], Object value)
Here, value is assigned to all elements in array.
The second version of the fill( ) method assigns a value to a subset of an array. Its forms
are shown here:
static void fill(boolean array[ ], int start, int end, boolean value)
static void fill(byte array[ ], int start, int end, byte value)
static void fill(char array[ ], int start, int end, char value)
static void fill(double array[ ], int start, int end, double value)
static void fill(float array[ ], int start, int end, float value)
static void fill(int array[ ], int start, int end, int value)
static void fill(long array[ ], int start, int end, long value)
static void fill(short array[ ], int start, int end, short value)
static void fill(Object array[ ], int start, int end, Object value)
Here, value is assigned to the elements in array from position start to position end–1. These
methods may all throw an IllegalArgumentException if start is greater than end, or an
ArrayIndexOutOfBoundsException if start or end is out of bounds.
The sort( ) method sorts an array so that it is arranged in ascending order. The sort( )
method has two versions. The first version, shown here, sorts the entire array:
static void sort(byte array[ ])
static void sort(char array[ ])
static void sort(double array[ ])
static void sort(float array[ ])
static void sort(int array[ ])
static void sort(long array[ ])
static void sort(short array[ ])
static void sort(Object array[ ])
static <T> void sort(T array[ ], Comparator<? super T> c)Chapter 17:
java.util Part 1: The Collections Framework
Here, array is the array to be sorted. In the last form, c is a Comparator that is used to order
the elements of array. The last two forms can throw a ClassCastException if elements of the
array being sorted are not comparable.
The second version of sort( ) enables you to specify a range within an array that you want
to sort. Its forms are shown here:
static void sort(byte array[ ], int start, int end)
static void sort(char array[ ], int start, int end)
static void sort(double array[ ], int start, int end)
static void sort(float array[ ], int start, int end)
static void sort(int array[ ], int start, int end)
static void sort(long array[ ], int start, int end)
static void sort(short array[ ], int start, int end)
static void sort(Object array[ ], int start, int end)
static <T> void sort(T array[ ], int start, int end, Comparator<? super T> c)
Here, the range beginning at start and running through end–1 within array will be sorted.
In the last form, c is a Comparator that is used to order the elements of array. All of these
methods can throw an IllegalArgumentException if start is greater than end, or an
ArrayIndexOutOfBoundsException if start or end is out of bounds. The last two forms can
also throw a ClassCastException if elements of the array being sorted are not comparable.
Arrays also overrides toString( ) and hashCode( ) for the various types of arrays. In
addition, deepToString( ) and deepHashCode( ) are provided, which operate effectively on
arrays that contain nested arrays.
The following program illustrates how to use some of the methods of the Arrays class:
// Demonstrate Arrays
import java.util.*;
class ArraysDemo 
The following is the output from this program:
Original contents: 0 -3 -6 -9 -12 -15 -18 -21 -24 -27
Sorted: -27 -24 -21 -18 -15 -12 -9 -6 -3 0
After fill(): -27 -24 -1 -1 -1 -1 -9 -6 -3 0
After sorting again: -27 -24 -9 -6 -3 -1 -1 -1 -1 0
The value -9 is at location 2
Why Generic Collections?
As mentioned at the start of this chapter, the entire Collections Framework was refitted for
generics when JDK 5 was released. Furthermore, the Collections Framework is arguably
the single most important use of generics in the Java API. The reason for this is that generics
add type safety to the Collections Framework. Before moving on, it is worth taking some
time to examine in detail the significance of this improvement.
Let’s begin with an example that uses pre-generics code. The following program stores
a list of strings in an ArrayList and then displays the contents of the list:
// Pre-generics example that uses a collection.
import java.util.*;
class OldStyle 
Prior to generics, all collections stored references of type Object. This allowed any type
of reference to be stored in the collection. The preceding program uses this feature to store
references to objects of type String in list, but any type of reference could have been stored.
Unfortunately, the fact that a pre-generics collection stored Object references could easily
lead to errors. First, it required that you, rather than the compiler, ensure that only objects of
the proper type be stored in a specific collection. For example, in the preceding example, list
is clearly intended to store Strings, but there is nothing that actually prevents another type
of reference from being added to the collection. For example, the compiler will find nothing
wrong with this line of code:
list.add(new Integer(100));
Because list stores Object references, it can store a reference to Integer as well as it can
store a reference to String. However, if you intended list to hold only strings, then the preceding
statement would corrupt the collection. Again, the compiler had no way to know that the
preceding statement is invalid.
The second problem with pre-generics collections is that when you retrieve a reference
from the collection, you must manually cast that reference into the proper type. This is why
the preceding program casts the reference returned by next( ) into String. Prior to generics,
collections simply stored Object references. Thus, the cast was necessary when retrieving
objects from a collection.
Aside from the inconvenience of always having to cast a retrieved reference into
its proper type, this lack of type safety often led to a rather serious, but surprisingly
easy-to-create, error. Because Object can be cast into any type of object, it was possible to
cast a reference obtained from a collection into the wrong type. For example, if the following
statement were added to the preceding example, it would still compile without error, but
generate a run-time exception when executed:
Integer i = (Integer) itr.next();
Recall that the preceding example stored only references to instances of type String in list.
Thus, when this statement attempts to cast a String into an Integer, an invalid cast exception
results! Because this happens at run time, this is a very serious error.
The addition of generics fundamentally improves the usability and safety of collections
because it
• Ensures that only references to objects of the proper type can actually be stored in
a collection. Thus, a collection will always contain references of a known type.
• Eliminates the need to cast a reference retrieved from a collection. Instead, a reference
retrieved from a collection is automatically cast into the proper type. This prevents
run-time errors due to invalid casts and avoids an entire category of errors.
485486
Part II:
The Java Library
These two improvements are made possible because each collection class has been given
a type parameter that specifies the type of the collection. For example, ArrayList is now
declared like this:
class ArrayList<E>
Here, E is the type of element stored in the collection. Therefore, the following declares an
ArrayList for objects of type String:
ArrayList<String> list = new ArrayList<String>();
Now, only references of type String can be added to list.
The Iterator and ListIterator interfaces are now also generic. This means that the type
parameter must agree with the type of the collection for which the iterator is obtained.
Furthermore, this type compatibility is enforced at compile time.
The following program shows the modern, generic form of the preceding program:
// Modern, generics version.
import java.util.*;
class NewStyle 
Now, list can hold only references to objects of type String. Furthermore, as the following
line shows, there is no need to cast the return value of next( ) into String:
String str = itr.next(); // no cast needed
The cast is performed automatically.Chapter 17:
java.util Part 1: The Collections Framework
Because of support for raw types, it is not necessary to immediately update older
collection code. However, all new code should use generics, and you should update older
code as soon as time permits. The addition of generics to the Collections Framework is a
fundamental improvement that should be utilized wherever possible.
The Legacy Classes and Interfaces
As explained at the start of this chapter, early versions of java.util did not include the
Collections Framework. Instead, it defined several classes and an interface that provided an
ad hoc method of storing objects. When collections were added (by J2SE 1.2), several of the
original classes were reengineered to support the collection interfaces. Thus, they are fully
compatible with the framework. While no classes have actually been deprecated, one has been
rendered obsolete. Of course, where a collection duplicates the functionality of a legacy class,
you will usually want to use the collection for new code. In general, the legacy classes are
supported because there is still code that uses them.
One other point: none of the collection classes are synchronized, but all the legacy classes
are synchronized. This distinction may be important in some situations. Of course, you can
easily synchronize collections, too, by using one of the algorithms provided by Collections.
The legacy classes defined by java.util are shown here:
Dictionary
Hashtable
Properties
Stack
Vector
There is one legacy interface called Enumeration. The following sections examine Enumeration
and each of the legacy classes, in turn.
The Enumeration Interface
The Enumeration interface defines the methods by which you can enumerate (obtain one at
a time) the elements in a collection of objects. This legacy interface has been superseded by
Iterator. Although not deprecated, Enumeration is considered obsolete for new code. However,
it is used by several methods defined by the legacy classes (such as Vector and Properties),
is used by several other API classes, and is currently in widespread use in application code.
Because it is still in use, it was retrofitted for generics by JDK 5. It has this declaration:
interface Enumeration<E>
where E specifies the type of element being enumerated.
Enumeration specifies the following two methods:
boolean hasMoreElements( )
E nextElement( )
When implemented, hasMoreElements( ) must return true while there are still more elements
to extract, and false when all the elements have been enumerated. nextElement( ) returns the
next object in the enumeration. That is, each call to nextElement( ) obtains the next object in
the enumeration. It throws NoSuchElementException when the enumeration is complete.
Vector
Vector implements a dynamic array. It is similar to ArrayList, but with two differences: Vector
is synchronized, and it contains many legacy methods that are not part of the Collections
487488
Part II:
The Java Library
Framework. With the advent of collections, Vector was reengineered to extend AbstractList and
to implement the List interface. With the release of JDK 5, it was retrofitted for generics and
reengineered to implement Iterable. This means that Vector is fully compatible with collections,
and a Vector can have its contents iterated by the enhanced for loop.
Vector is declared like this:
class Vector<E>
Here, E specifies the type of element that will be stored.
Here are the Vector constructors:
Vector( )
Vector(int size)
Vector(int size, int incr)
Vector(Collection<? extends E> c)
The first form creates a default vector, which has an initial size of 10. The second form creates
a vector whose initial capacity is specified by size. The third form creates a vector whose
initial capacity is specified by size and whose increment is specified by incr. The increment
specifies the number of elements to allocate each time that a vector is resized upward. The
fourth form creates a vector that contains the elements of collection c.
All vectors start with an initial capacity. After this initial capacity is reached, the next
time that you attempt to store an object in the vector, the vector automatically allocates
space for that object plus extra room for additional objects. By allocating more than just the
required memory, the vector reduces the number of allocations that must take place. This
reduction is important, because allocations are costly in terms of time. The amount of extra
space allocated during each reallocation is determined by the increment that you specify
when you create the vector. If you don’t specify an increment, the vector’s size is doubled
by each allocation cycle.
Vector defines these protected data members:
int capacityIncrement;
int elementCount;
Object[ ] elementData;
The increment value is stored in capacityIncrement. The number of elements currently in the
vector is stored in elementCount. The array that holds the vector is stored in elementData.
In addition to the collections methods defined by List, Vector defines several legacy
methods, which are summarized in Table 17-15.
Because Vector implements List, you can use a vector just like you use an ArrayList
instance. You can also manipulate one using its legacy methods. For example, after you
instantiate a Vector, you can add an element to it by calling addElement( ). To obtain the
element at a specific location, call elementAt( ). To obtain the first element in the vector, call
firstElement( ). To retrieve the last element, call lastElement( ). You can obtain the index of an
element by using indexOf( ) and lastIndexOf( ). To remove an element, call removeElement( )
or removeElementAt( ).Chapter 17:
Method
java.util Part 1: The Collections Framework
Description
void addElement(E element) The object specified by element is added to the vector.
int capacity( ) Returns the capacity of the vector.
Object clone( ) Returns a duplicate of the invoking vector.
boolean contains(Object element) Returns true if element is contained by the vector, and returns false if it is not.
void copyInto(Object array[ ]) The elements contained in the invoking vector are copied into the array
specified by array.
E elementAt(int index) Returns the element at the location specified by index.
Enumeration<E> elements( ) Returns an enumeration of the elements in the vector.
void ensureCapacity(int size) Sets the minimum capacity of the vector to size.
E firstElement( ) Returns the first element in the vector.
int indexOf(Object element) Returns the index of the first occurrence of element. If the object is not in the
vector, –1 is returned.
int indexOf(Object element, int start) Returns the index of the first occurrence of element at or after start. If the object
is not in that portion of the vector, –1 is returned.
void insertElementAt(E element,
int index) Adds element to the vector at the location specified by index.
boolean isEmpty( ) Returns true if the vector is empty, and returns false if it contains one or more
elements.
E lastElement( ) Returns the last element in the vector.
int lastIndexOf(Object element) Returns the index of the last occurrence of element. If the object is not in the
vector, –1 is returned.
int lastIndexOf(Object element,
int start) Returns the index of the last occurrence of element before start. If the object
is not in that portion of the vector, –1 is returned.
void removeAllElements( ) Empties the vector. After this method executes, the size of the vector is zero.
boolean removeElement(Object element) Removes element from the vector. If more than one instance of the specified
object exists in the vector, then it is the first one that is removed. Returns
true if successful and false if the object is not found.
void removeElementAt(int index) Removes the element at the location specified by index.
void setElementAt(E element,
int index) The location specified by index is assigned element.
void setSize(int size) Sets the number of elements in the vector to size. If the new size is less than
the old size, elements are lost. If the new size is larger than the old size, null
elements are added.
int size( ) Returns the number of elements currently in the vector.
String toString( ) Returns the string equivalent of the vector.
void trimToSize( ) Sets the vector’s capacity equal to the number of elements that
it currently holds.
T ABLE 17-15
The Legacy Methods Defined by Vector
The following program uses a vector to store various types of numeric objects. It
demonstrates several of the legacy methods defined by Vector. It also demonstrates the
Enumeration interface.
// Demonstrate various Vector operations.
import java.util.*;
class VectorDemo 
The output from this program is shown here:
Initial size: 0
Initial capacity: 3
Capacity after four additions: 5
Current capacity: 5
Current capacity: 7
Current capacity: 9Chapter 17:
java.util Part 1: The Collections Framework
First element: 1
Last element: 12
Vector contains 3.
Elements in vector:
1 2 3 4 5 6 7 9 10 11 12
Instead of relying on an enumeration to cycle through the objects (as the preceding
program does), you can use an iterator. For example, the following iterator-based code can
be substituted into the program:
// Use an iterator to display contents.
Iterator<Integer> vItr = v.iterator();
System.out.println("\nElements in vector:");
while(vItr.hasNext())
System.out.print(vItr.next() + " ");
System.out.println();
You can also use a for-each for loop to cycle through a Vector, as the following version
of the preceding code shows:
// Use an enhanced for loop to display contents.
System.out.println("\nElements in vector:");
for(int i : v)
System.out.print(i + " ");
System.out.println();
Because the Enumeration interface is not recommended for new code, you will usually use
an iterator or a for-each for loop to enumerate the contents of a vector. Of course, much
legacy code exists that employs Enumeration. Fortunately, enumerations and iterators
work in nearly the same manner.
Stack
Stack is a subclass of Vector that implements a standard last-in, first-out stack. Stack only
defines the default constructor, which creates an empty stack. With the release of JDK 5, Stack
was retrofitted for generics and is declared as shown here:
class Stack<E>
Here, E specifies the type of element stored in the stack.
Stack includes all the methods defined by Vector and adds several of its own, shown in
Table 17-16.
To put an object on the top of the stack, call push( ). To remove and return the top element,
call pop( ). An EmptyStackException is thrown if you call pop( ) when the invoking stack is
empty. You can use peek( ) to return, but not remove, the top object. The empty( ) method
returns true if nothing is on the stack. The search( ) method determines whether an object
exists on the stack and returns the number of pops that are required to bring it to the top of
491492
Part II:
The Java Library
Method Description
boolean empty( ) Returns true if the stack is empty, and returns false if the stack
contains elements.
E peek( ) Returns the element on the top of the stack, but does not remove it.
E pop( ) Returns the element on the top of the stack, removing it in the
process.
E push(E element) Pushes element onto the stack. element is also returned.
int search(Object element) Searches for element in the stack. If found, its offset from the top
of the stack is returned. Otherwise, –1 is returned.
T ABLE 17-16
The Methods Defined by Stack
the stack. Here is an example that creates a stack, pushes several Integer objects onto it, and
then pops them off again:
// Demonstrate the Stack class.
import java.util.*;
class StackDemo Chapter 17:
java.util Part 1: The Collections Framework
The following is the output produced by the program; notice how the exception handler for
EmptyStackException is caught so that you can gracefully handle a stack underflow:
stack: [ ]
push(42)
stack: [42]
push(66)
stack: [42, 66]
push(99)
stack: [42, 66, 99]
pop -> 99
stack: [42, 66]
pop -> 66
stack: [42]
pop -> 42
stack: [ ]
pop -> empty stack
One other point: Although Stack is not deprecated, with the release of Java SE 6,
ArrayDeque is a better choice.
Dictionary
Dictionary is an abstract class that represents a key/value storage repository and operates
much like Map. Given a key and value, you can store the value in a Dictionary object. Once
the value is stored, you can retrieve it by using its key. Thus, like a map, a dictionary can be
thought of as a list of key/value pairs. Although not currently deprecated, Dictionary is
classified as obsolete, because it is fully superseded by Map. However, Dictionary is still in
use and thus is fully discussed here.
With the advent of JDK 5, Dictionary was made generic. It is declared as shown here:
class Dictionary<K, V>
Here, K specifies the type of keys, and V specifies the type of values. The abstract methods
defined by Dictionary are listed in Table 17-17.
Method
Purpose
Enumeration<V> elements( ) Returns an enumeration of the values contained in the dictionary.
V get(Object key) Returns the object that contains the value associated with key. If
key is not in the dictionary, a null object is returned.
boolean isEmpty( ) Returns true if the dictionary is empty, and returns false if it
contains at least one key.
Enumeration<K> keys( ) Returns an enumeration of the keys contained in the dictionary.
V put(K key, V value) Inserts a key and its value into the dictionary. Returns null if key
is not already in the dictionary; returns the previous value
associated with key if key is already in the dictionary.
V remove(Object key) Removes key and its value. Returns the value associated with
key. If key is not in the dictionary, a null is returned.
int size( ) Returns the number of entries in the dictionary.
T ABLE 17-17
The Abstract Methods Defined by Dictionary
493494
Part II:
The Java Library
To add a key and a value, use the put( ) method. Use get( ) to retrieve the value of a given
key. The keys and values can each be returned as an Enumeration by the keys( ) and elements( )
methods, respectively. The size( ) method returns the number of key/value pairs stored in a
dictionary, and isEmpty( ) returns true when the dictionary is empty. You can use the remove( )
method to delete a key/value pair.
R EMEMBER The Dictionary class is obsolete. You should implement the Map interface to obtain
key/value storage functionality.
Hashtable
Hashtable was part of the original java.util and is a concrete implementation of a Dictionary.
However, with the advent of collections, Hashtable was reengineered to also implement the
Map interface. Thus, Hashtable is now integrated into the Collections Framework. It is similar
to HashMap, but is synchronized.
Like HashMap, Hashtable stores key/value pairs in a hash table. However, neither keys
nor values can be null. When using a Hashtable, you specify an object that is used as a key,
and the value that you want linked to that key. The key is then hashed, and the resulting
hash code is used as the index at which the value is stored within the table.
Hashtable was made generic by JDK 5. It is declared like this:
class Hashtable<K, V>
Here, K specifies the type of keys, and V specifies the type of values.
A hash table can only store objects that override the hashCode( ) and equals( ) methods
that are defined by Object. The hashCode( ) method must compute and return the hash code
for the object. Of course, equals( ) compares two objects. Fortunately, many of Java’s built-in
classes already implement the hashCode( ) method. For example, the most common type of
Hashtable uses a String object as the key. String implements both hashCode( ) and equals( ).
The Hashtable constructors are shown here:
Hashtable( )
Hashtable(int size)
Hashtable(int size, float fillRatio)
Hashtable(Map<? extends K, ? extends V> m)
The first version is the default constructor. The second version creates a hash table that has
an initial size specified by size. (The default size is 11.) The third version creates a hash table that
has an initial size specified by size and a fill ratio specified by fillRatio. This ratio must be
between 0.0 and 1.0, and it determines how full the hash table can be before it is resized
upward. Specifically, when the number of elements is greater than the capacity of the hash
table multiplied by its fill ratio, the hash table is expanded. If you do not specify a fill ratio,
then 0.75 is used. Finally, the fourth version creates a hash table that is initialized with the
elements in m. The capacity of the hash table is set to twice the number of elements in m.
The default load factor of 0.75 is used.
In addition to the methods defined by the Map interface, which Hashtable now
implements, Hashtable defines the legacy methods listed in Table 17-18. Several methods
throw NullPointerException if an attempt is made to use a null key or value.Chapter 17:
java.util Part 1: The Collections Framework
Method Description
void clear( ) Resets and empties the hash table.
Object clone( ) Returns a duplicate of the invoking object.
boolean contains(Object value) Returns true if some value equal to value exists within the hash table.
Returns false if the value isn’t found.
boolean containsKey(Object key) Returns true if some key equal to key exists within the hash table.
Returns false if the key isn’t found.
boolean containsValue(Object value) Returns true if some value equal to value exists within the hash table.
Returns false if the value isn’t found.
Enumeration<V> elements( ) Returns an enumeration of the values contained in the hash table.
V get(Object key) Returns the object that contains the value associated with key.
If key is not in the hash table, a null object is returned.
boolean isEmpty( ) Returns true if the hash table is empty; returns false if it contains
at least one key.
Enumeration<K> keys( ) Returns an enumeration of the keys contained in the hash table.
V put(K key, V value) Inserts a key and a value into the hash table. Returns null if key isn’t
already in the hash table; returns the previous value associated with
key if key is already in the hash table.
void rehash( ) Increases the size of the hash table and rehashes all of its keys.
V remove(Object key) Removes key and its value. Returns the value associated with key.
If key is not in the hash table, a null object is returned.
int size( ) Returns the number of entries in the hash table.
String toString( ) Returns the string equivalent of a hash table.
T ABLE 17-18
The Legacy Methods Defined by Hashtable
The following example reworks the bank account program, shown earlier, so that it uses
a Hashtable to store the names of bank depositors and their current balances:
// Demonstrate a Hashtable.
import java.util.*;
class HTDemo 
The output from this program is shown here:
Todd Hall: 99.22
Ralph Smith: -19.08
John Doe: 3434.34
Jane Baker: 1378.0
Tom Smith: 123.22
John Doe’s new balance: 4434.34
One important point: like the map classes, Hashtable does not directly support iterators.
Thus, the preceding program uses an enumeration to display the contents of balance. However,
you can obtain set-views of the hash table, which permits the use of iterators. To do so, you
simply use one of the collection-view methods defined by Map, such as entrySet( ) or keySet( ).
For example, you can obtain a set-view of the keys and cycle through them using either an
iterator or an enhanced for loop. Here is a reworked version of the program that shows this
technique:
// Use iterators with a Hashtable.
import java.util.*;
class HTDemo2 
Properties
Properties is a subclass of Hashtable. It is used to maintain lists of values in which the key
is a String and the value is also a String. The Properties class is used by many other Java
classes. For example, it is the type of object returned by System.getProperties( ) when
obtaining environmental values. Although the Properties class, itself, is not generic, several
of its methods are.
Properties defines the following instance variable:
Properties defaults;
This variable holds a default property list associated with a Properties object. Properties
defines these constructors:
Properties( )
Properties(Properties propDefault)
The first version creates a Properties object that has no default values. The second creates an
object that uses propDefault for its default values. In both cases, the property list is empty.
In addition to the methods that Properties inherits from Hashtable, Properties defines
the methods listed in Table 17-19. Properties also contains one deprecated method: save( ).
This was replaced by store( ) because save( ) did not handle errors correctly.
One useful capability of the Properties class is that you can specify a default property
that will be returned if no value is associated with a certain key. For example, a default value
can be specified along with the key in the getProperty( ) method—such as getProperty(“name”,
“default value”). If the “name” value is not found, then “default value” is returned. When
you construct a Properties object, you can pass another instance of Properties to be used as
the default properties for the new instance. In this case, if you call getProperty(“foo”) on a
given Properties object, and “foo” does not exist, Java looks for “foo” in the default Properties
object. This allows for arbitrary nesting of levels of default properties.
497498
Part II:
The Java Library
Method Description
String getProperty(String key) Returns the value associated with key. A null object is returned if key is
neither in the list nor in the default property list.
String getProperty(String key,
String defaultProperty) Returns the value associated with key. defaultProperty is returned if key is
neither in the list nor in the default property list.
void list(PrintStream streamOut) Sends the property list to the output stream linked to streamOut.
void list(PrintWriter streamOut) Sends the property list to the output stream linked to streamOut.
void load(InputStream streamIn)
throws IOException Inputs a property list from the input stream linked to streamIn.
void load(Reader streamIn)
throws IOException Inputs a property list from the input stream linked to streamIn. (Added by
Java SE 6.)
void loadFromXML(InputStream streamIn)
throws IOException,
InvalidPropertiesFormatException Inputs a property list from an XML document linked to streamIn.
Enumeration<?> propertyNames( ) Returns an enumeration of the keys. This includes those keys found in
the default property list, too.
Object setProperty(String key, String value) Associates value with key. Returns the previous value associated with key,
or returns null if no such association exists.
void store(OutputStream streamOut,
String description)
throws IOException After writing the string specified by description, the property list is written
to the output stream linked to streamOut.
void store(Writer streamOut,
String description)
throws IOException After writing the string specified by description, the property list is written
to the output stream linked to streamOut. (Added by Java SE 6.)
void storeToXML(OutputStream streamOut,
String description)
throws IOException After writing the string specified by description, the property list is written
to the XML document linked to streamOut.
void storeToXML(OutputStream streamOut,
String description,
String enc) The property list and the string specified by description is written to the
XML document linked to streamOut using the specified character
encoding.
Set<String> stringPropertyNames( ) Returns a set of keys. (Added by Java SE 6.)
T ABLE 17-19
The Methods Defined by Properties
The following example demonstrates Properties. It creates a property list in which the keys
are the names of states and the values are the names of their capitals. Notice that the attempt
to find the capital for Florida includes a default value.
// Demonstrate a Property list.
import java.util.*;
class PropDemo 
The output from this program is shown here:
The
The
The
The
The
capital
capital
capital
capital
capital
of
of
of
of
of
Missouri is Jefferson City.
Illinois is Springfield.
Indiana is Indianapolis.
California is Sacramento.
Washington is Olympia.
The capital of Florida is Not Found.
Since Florida is not in the list, the default value is used.
Although it is perfectly valid to use a default value when you call getProperty( ), as the
preceding example shows, there is a better way of handling default values for most applications
of property lists. For greater flexibility, specify a default property list when constructing
a Properties object. The default list will be searched if the desired key is not found in the
main list. For example, the following is a slightly reworked version of the preceding program,
with a default list of states specified. Now, when Florida is sought, it will be found in the
default list:
// Use a default property list.
import java.util.*;
class PropDemoDef 
Using store( ) and load( )
One of the most useful aspects of Properties is that the information contained in a Properties
object can be easily stored to or loaded from disk with the store( ) and load( ) methods. At
any time, you can write a Properties object to a stream or read it back. This makes property
lists especially convenient for implementing simple databases. For example, the following
program uses a property list to create a simple computerized telephone book that stores names
and phone numbers. To find a person’s number, you enter his or her name. The program uses
the store( ) and load( ) methods to store and retrieve the list. When the program executes, it
first tries to load the list from a file called phonebook.dat. If this file exists, the list is loaded.
You can then add to the list. If you do, the new list is saved when you terminate the
program. Notice how little code is required to implement a small, but functional, computerized
phone book.
/* A simple telephone number database that uses
a property list. */
import java.io.*;
import java.util.*;
class Phonebook 
Parting Thoughts on Collections
The Collections Framework gives you, the programmer, a powerful set of well-engineered
solutions to some of programming’s most common tasks. Now that the Collections Framework
is generic, it can be used with complete type safety, which further contributes to its value.
501502
Part II:
The Java Library
Consider using a collection the next time that you need to store and retrieve information.
Remember, collections need not be reserved for only the “large jobs,” such as corporate
databases, mailing lists, or inventory systems. They are also effective when applied to smaller
jobs. For example, a TreeMap would make an excellent collection to hold the directory
structure of a set of files. A TreeSet could be quite useful for storing project-management
information. Frankly, the types of problems that will benefit from a collections-based solution
are limited only by your imagination.18
java.util Part 2:
More Utility Classes
T
his chapter continues our discussion of java.util by examining those classes and
interfaces that are not part of the Collections Framework. These include classes that
tokenize strings, work with dates, compute random numbers, bundle resources, and
observe events. Also covered are the Formatter and Scanner classes which make it easy to
write and read formatted data. Finally, the subpackages of java.util are briefly mentioned
at the end of this chapter.
StringTokenizer
The processing of text often consists of parsing a formatted input string. Parsing is the division
of text into a set of discrete parts, or tokens, which in a certain sequence can convey a semantic
meaning. The StringTokenizer class provides the first step in this parsing process, often
called the lexer (lexical analyzer) or scanner. StringTokenizer implements the Enumeration
interface. Therefore, given an input string, you can enumerate the individual tokens contained
in it using StringTokenizer.
To use StringTokenizer, you specify an input string and a string that contains delimiters.
Delimiters are characters that separate tokens. Each character in the delimiters string is
considered a valid delimiter—for example, “,;:” sets the delimiters to a comma, semicolon,
and colon. The default set of delimiters consists of the whitespace characters: space, tab,
newline, and carriage return.
The StringTokenizer constructors are shown here:
StringTokenizer(String str)
StringTokenizer(String str, String delimiters)
StringTokenizer(String str, String delimiters, boolean delimAsToken)
In all versions, str is the string that will be tokenized. In the first version, the default delimiters
are used. In the second and third versions, delimiters is a string that specifies the delimiters.
In the third version, if delimAsToken is true, then the delimiters are also returned as tokens
when the string is parsed. Otherwise, the delimiters are not returned. Delimiters are not
returned as tokens by the first two forms.
503504
Part II:
The Java Library
Once you have created a StringTokenizer object, the nextToken( ) method is used to extract
consecutive tokens. The hasMoreTokens( ) method returns true while there are more tokens to
be extracted. Since StringTokenizer implements Enumeration, the hasMoreElements( ) and
nextElement( ) methods are also implemented, and they act the same as hasMoreTokens( ) and
nextToken( ), respectively. The StringTokenizer methods are shown in Table 18-1.
Here is an example that creates a StringTokenizer to parse “key=value” pairs. Consecutive
sets of “key=value” pairs are separated by a semicolon.
// Demonstrate StringTokenizer.
import java.util.StringTokenizer;
class STDemo 
The output from this program is shown here:
title Java: The Complete Reference
author Schildt
publisher Osborne/McGraw-Hill
copyright 2007
Method Description
int countTokens( ) Using the current set of delimiters, the method determines
the number of tokens left to be parsed and returns the
result.
boolean hasMoreElements( ) Returns true if one or more tokens remain in the string and
returns false if there are none.
boolean hasMoreTokens( ) Returns true if one or more tokens remain in the string and
returns false if there are none.
Object nextElement( ) Returns the next token as an Object.
String nextToken( ) Returns the next token as a String.
String nextToken(String delimiters) Returns the next token as a String and sets the delimiters
string to that specified by delimiters.
T ABLE 18-1
The Methods Defined by StringTokenizerChapter 18:
java.util Part 2: More Utility Classes
BitSet
A BitSet class creates a special type of array that holds bit values. This array can increase in size
as needed. This makes it similar to a vector of bits. The BitSet constructors are shown here:
BitSet( )
BitSet(int size)
The first version creates a default object. The second version allows you to specify its initial
size (that is, the number of bits that it can hold). All bits are initialized to zero.
BitSet defines the methods listed in Table 18-2.
Method Description
void and(BitSet bitSet) ANDs the contents of the invoking BitSet object with those
specified by bitSet. The result is placed into the invoking
object.
void andNot(BitSet bitSet) For each 1 bit in bitSet, the corresponding bit in the invoking
BitSet is cleared.
int cardinality( ) Returns the number of set bits in the invoking object.
void clear( ) Zeros all bits.
void clear(int index) Zeros the bit specified by index.
void clear(int startIndex,
int endIndex) Zeros the bits from startIndex to endIndex–1.
Object clone( ) Duplicates the invoking BitSet object.
boolean equals(Object bitSet) Returns true if the invoking bit set is equivalent to the one
passed in bitSet. Otherwise, the method returns false.
void flip(int index) Reverses the bit specified by index.
void flip(int startIndex,
int endIndex) Reverses the bits from startIndex to endIndex–1.
boolean get(int index) Returns the current state of the bit at the specified index.
BitSet get(int startIndex,
int endIndex) Returns a BitSet that consists of the bits from startIndex
to endIndex–1. The invoking object is not changed.
int hashCode( ) Returns the hash code for the invoking object.
boolean intersects(BitSet bitSet) Returns true if at least one pair of corresponding bits within
the invoking object and bitSet are 1.
boolean isEmpty( ) Returns true if all bits in the invoking object are zero.
int length( ) Returns the number of bits required to hold the contents of
the invoking BitSet. This value is determined by the location
of the last 1 bit.
int nextClearBit(int startIndex) Returns the index of the next cleared bit (that is, the next
zero bit), starting from the index specified by startIndex.
T ABLE 18-2
The Methods Defined by BitSet
505506
Part II:
The Java Library
Method Description
int nextSetBit(int startIndex) Returns the index of the next set bit (that is, the next 1 bit),
starting from the index specified by startIndex. If no bit is set,
–1 is returned.
void or(BitSet bitSet) ORs the contents of the invoking BitSet object with that
specified by bitSet. The result is placed into the invoking object.
void set(int index) Sets the bit specified by index.
void set(int index, boolean v) Sets the bit specified by index to the value passed in v. true
sets the bit, false clears the bit.
void set(int startIndex,
int endIndex) Sets the bits from startIndex to endIndex–1.
Sets the bits from startIndex to endIndex–1, to the value
void set(int startIndex,
int endIndex, boolean v) passed in v. true sets the bits, false clears the bits.
int size( ) Returns the number of bits in the invoking BitSet object.
String toString( ) Returns the string equivalent of the invoking BitSet object.
void xor(BitSet bitSet) XORs the contents of the invoking BitSet object with that
specified by bitSet. The result is placed into the invoking object.
T ABLE 18-2
The Methods Defined by BitSet (continued)
Here is an example that demonstrates BitSet:
// BitSet Demonstration.
import java.util.BitSet;
class BitSetDemo 
The output from this program is shown here. When toString( ) converts a BitSet object to its
string equivalent, each set bit is represented by its bit position. Cleared bits are not shown.
Initial pattern in bits1:

Initial pattern in bits2:

bits2 AND bits1:

bits2 OR bits1:

bits2 XOR bits1:

Date
The Date class encapsulates the current date and time. Before beginning our examination of
Date, it is important to point out that it has changed substantially from its original version
defined by Java 1.0. When Java 1.1 was released, many of the functions carried out by the
original Date class were moved into the Calendar and DateFormat classes, and as a result,
many of the original 1.0 Date methods were deprecated. Since the deprecated 1.0 methods
should not be used for new code, they are not described here.
Date supports the following constructors:
Date( )
Date(long millisec)
The first constructor initializes the object with the current date and time. The second constructor
accepts one argument that equals the number of milliseconds that have elapsed since midnight,
January 1, 1970. The nondeprecated methods defined by Date are shown in Table 18-3. Date also
implements the Comparable interface.
507508
Part II:
The Java Library
Method Description
boolean after(Date date) Returns true if the invoking Date object contains a date that is
later than the one specified by date. Otherwise, it returns false.
boolean before(Date date) Returns true if the invoking Date object contains a date that is
earlier than the one specified by date. Otherwise, it returns false.
Object clone( ) Duplicates the invoking Date object.
int compareTo(Date date) Compares the value of the invoking object with that of date. Returns
0 if the values are equal. Returns a negative value if the invoking
object is earlier than date. Returns a positive value if the invoking
object is later than date.
boolean equals(Object date) Returns true if the invoking Date object contains the same time
and date as the one specified by date. Otherwise, it returns false.
long getTime( ) Returns the number of milliseconds that have elapsed since
January 1, 1970.
int hashCode( ) Returns a hash code for the invoking object.
void setTime(long time) Sets the time and date as specified by time, which represents
an elapsed time in milliseconds from midnight, January 1, 1970.
String toString( ) Converts the invoking Date object into a string and returns the result.
T ABLE 18-3
The Nondeprecated Methods Defined by Date
As you can see by examining Table 18-3, the Date features do not allow you to obtain
the individual components of the date or time. As the following program demonstrates, you
can only obtain the date and time in terms of milliseconds or in its default string representation
as returned by toString( ). To obtain more-detailed information about the date and time,
you will use the Calendar class.
// Show date and time using only Date methods.
import java.util.Date;
class DateDemo Chapter 18:
java.util Part 2: More Utility Classes
Sample output is shown here:
Mon Jan 01 16:28:16 CST 2007
Milliseconds since Jan. 1, 1970 GMT = 1167690496023
Calendar
The abstract Calendar class provides a set of methods that allows you to convert a time in
milliseconds to a number of useful components. Some examples of the type of information
that can be provided are year, month, day, hour, minute, and second. It is intended that
subclasses of Calendar will provide the specific functionality to interpret time information
according to their own rules. This is one aspect of the Java class library that enables you
to write programs that can operate in international environments. An example of such a
subclass is GregorianCalendar.
Calendar provides no public constructors.
Calendar defines several protected instance variables. areFieldsSet is a boolean that
indicates if the time components have been set. fields is an array of ints that holds the
components of the time. isSet is a boolean array that indicates if a specific time component
has been set. time is a long that holds the current time for this object. isTimeSet is a boolean
that indicates if the current time has been set.
Some commonly used methods defined by Calendar are shown in Table 18-4.
Method Description
abstract void add(int which, int val) Adds val to the time or date component specified
by which. To subtract, add a negative value. which
must be one of the fields defined by Calendar, such
as Calendar.HOUR.
boolean after(Object calendarObj) Returns true if the invoking Calendar object
contains a date that is later than the one specified
by calendarObj. Other wise, it returns false.
boolean before(Object calendarObj) Returns true if the invoking Calendar object contains
a date that is earlier than the one specified by
calendarObj. Otherwise, it returns false.
final void clear( ) Zeros all time components in the invoking object.
final void clear(int which) Zeros the time component specified by which in
the invoking object.
Object clone( ) Returns a duplicate of the invoking object.
boolean equals(Object calendarObj) Returns true if the invoking Calendar object
contains a date that is equal to the one specified
by calendarObj. Otherwise, it returns false.
T ABLE 18-4
Commonly Used Methods Defined by Calendar
509510
Part II:
The Java Library
Method Description
int get(int calendarField) Returns the value of one component of the invoking
object. The component is indicated by calendarField.
Examples of the components that can be requested
are Calendar.YEAR, Calendar.MONTH,
Calendar.MINUTE, and so forth.
static Locale[ ] getAvailableLocales( ) Returns an array of Locale objects that contains
the locales for which calendars are available.
static Calendar getInstance( ) Returns a Calendar object for the default locale and
time zone.
static Calendar getInstance(TimeZone tz) Returns a Calendar object for the time zone
specified by tz. The default locale is used.
static Calendar getInstance(Locale locale) Returns a Calendar object for the locale specified
by locale. The default time zone is used.
static Calendar getInstance(TimeZone tz,
Locale locale) Returns a Calendar object for the time zone
specified by tz and the locale specified by locale.
final Date getTime( ) Returns a Date object equivalent to the time of the
invoking object.
TimeZone getTimeZone( ) Returns the time zone for the invoking object.
final boolean isSet(int which) Returns true if the specified time component is set.
Otherwise, it returns false.
void set(int which, int val) Sets the date or time component specified by which
to the value specified by val in the invoking object.
which must be one of the fields defined by
Calendar, such as Calendar.HOUR.
final void set(int year, int month,
int dayOfMonth) Sets various date and time components of the
invoking object.
final void set(int year, int month,
int dayOfMonth, int hours,
int minutes) Sets various date and time components of the
invoking object.
final void set(int year, int month,
int dayOfMonth, int hours,
int minutes, int seconds) Sets various date and time components of the
invoking object.
final void setTime(Date d) Sets various date and time components of the
invoking object. This information is obtained from
the Date object d.
void setTimeZone(TimeZone tz) Sets the time zone for the invoking object to that
specified by tz.
T ABLE 18-4
Commonly Used Methods Defined by Calendar (continued)
Calendar defines the following int constants, which are used when you get or set
components of the calendar:Chapter 18:
java.util Part 2: More Utility Classes
ALL_STYLES FRIDAY PM
AM HOUR SATURDAY
AM_PM HOUR_OF_DAY SECOND
APRIL JANUARY SEPTEMBER
AUGUST JULY SHORT
DATE JUNE SUNDAY
DAY_OF_MONTH LONG THURSDAY
DAY_OF_WEEK MARCH TUESDAY
DAY_OF_WEEK_IN_MONTH MAY UNDECIMBER
DAY_OF_YEAR MILLISECOND WEDNESDAY
DECEMBER MINUTE WEEK_OF_MONTH
DST_OFFSET MONDAY WEEK_OF_YEAR
ERA MONTH YEAR
FEBRUARY NOVEMBER ZONE_OFFSET
FIELD_COUNT OCTOBER
The following program demonstrates several Calendar methods:
// Demonstrate Calendar
import java.util.Calendar;
class CalendarDemo 
Sample output is shown here:
Date: Jan 1 2007
Time: 11:24:25
Updated time: 10:29:22
GregorianCalendar
GregorianCalendar is a concrete implementation of a Calendar that implements the normal
Gregorian calendar with which you are familiar. The getInstance( ) method of Calendar
will typically return a GregorianCalendar initialized with the current date and time in the
default locale and time zone.
GregorianCalendar defines two fields: AD and BC. These represent the two eras defined
by the Gregorian calendar.
There are also several constructors for GregorianCalendar objects. The default,
GregorianCalendar( ), initializes the object with the current date and time in the default
locale and time zone. Three more constructors offer increasing levels of specificity:
GregorianCalendar(int year, int month, int dayOfMonth)
GregorianCalendar(int year, int month, int dayOfMonth, int hours,
int minutes)
GregorianCalendar(int year, int month, int dayOfMonth, int hours,
int minutes, int seconds)
All three versions set the day, month, and year. Here, year specifies the year. The month
is specified by month, with zero indicating January. The day of the month is specified by
dayOfMonth. The first version sets the time to midnight. The second version also sets the
hours and the minutes. The third version adds seconds.
You can also construct a GregorianCalendar object by specifying the locale and/or time
zone. The following constructors create objects initialized with the current date and time
using the specified time zone and/or locale:
GregorianCalendar(Locale locale)
GregorianCalendar(TimeZone timeZone)
GregorianCalendar(TimeZone timeZone, Locale locale)
GregorianCalendar provides an implementation of all the abstract methods in Calendar.
It also provides some additional methods. Perhaps the most interesting is isLeapYear( ), which
tests if the year is a leap year. Its form is
boolean isLeapYear(int year)
This method returns true if year is a leap year and false otherwise.Chapter 18:
java.util Part 2: More Utility Classes
The following program demonstrates GregorianCalendar:
// Demonstrate GregorianCalendar
import java.util.*;
class GregorianCalendarDemo 
Sample output is shown here:
Date: Jan 1 2007
Time: 11:25:27
The current year is not a leap year
TimeZone
Another time-related class is TimeZone. The TimeZone class allows you to work with time
zone offsets from Greenwich mean time (GMT), also referred to as Coordinated Universal Time
(UTC). It also computes daylight saving time. TimeZone only supplies the default constructor.
A sampling of methods defined by TimeZone is given in Table 18-5.
513514
Part II:
The Java Library
Method Description
Object clone( ) Returns a TimeZone-specific version of clone( ).
static String[ ] getAvailableIDs( ) Returns an array of String objects representing the
names of all time zones.
static String[ ]
getAvailableIDs(int timeDelta) Returns an array of String objects representing the
names of all time zones that are timeDelta offset from
GMT.
static TimeZone getDefault( ) Returns a TimeZone object that represents the default
time zone used on the host computer.
String getID( ) Returns the name of the invoking TimeZone object.
abstract int getOffset(int era, int year,
int month,
int dayOfMonth,
int dayOfWeek,
int millisec) Returns the offset that should be added to GMT to
compute local time. This value is adjusted for daylight
saving time. The parameters to the method represent
date and time components.
abstract int getRawOffset( ) Returns the raw offset that should be added to GMT
to compute local time. This value is not adjusted for
daylight saving time.
static TimeZone
getTimeZone(String tzName) Returns the TimeZone object for the time zone named
tzName.
abstract boolean inDaylightTime(Date d) Returns true if the date represented by d is in daylight
saving time in the invoking object. Otherwise, it
returns false.
static void setDefault(TimeZone tz) Sets the default time zone to be used on this host. tz
is a reference to the TimeZone object to be used.
void setID(String tzName) Sets the name of the time zone (that is, its ID) to that
specified by tzName.
abstract void setRawOffset(int millis) Sets the offset in milliseconds from GMT.
abstract boolean useDaylightTime( ) Returns true if the invoking object uses daylight saving
time. Otherwise, it returns false.
T ABLE 18-5
Some of the Methods Defined by TimeZone
SimpleTimeZone
The SimpleTimeZone class is a convenient subclass of TimeZone. It implements TimeZone’s
abstract methods and allows you to work with time zones for a Gregorian calendar. It also
computes daylight saving time.
SimpleTimeZone defines four constructors. One is
SimpleTimeZone(int timeDelta, String tzName)
This constructor creates a SimpleTimeZone object. The offset relative to Greenwich mean
time (GMT) is timeDelta. The time zone is named tzName.Chapter 18:
java.util Part 2: More Utility Classes
The second SimpleTimeZone constructor is
SimpleTimeZone(int timeDelta, String tzId, int dstMonth0,
int dstDayInMonth0, int dstDay0, int time0,
int dstMonth1, int dstDayInMonth1, int dstDay1,
int time1)
Here, the offset relative to GMT is specified in timeDelta. The time zone name is passed in tzId.
The start of daylight saving time is indicated by the parameters dstMonth0, dstDayInMonth0,
dstDay0, and time0. The end of daylight saving time is indicated by the parameters dstMonth1,
dstDayInMonth1, dstDay1, and time1.
The third SimpleTimeZone constructor is
SimpleTimeZone(int timeDelta, String tzId, int dstMonth0,
int dstDayInMonth0, int dstDay0, int time0,
int dstMonth1, int dstDayInMonth1, int dstDay1,
int time1, int dstDelta)
Here, dstDelta is the number of milliseconds saved during daylight saving time.
The fourth SimpleTimeZone constructor is
SimpleTimeZone(int timeDelta, String tzId, int dstMonth0,
int dstDayInMonth0, int dstDay0, int time0,
int time0mode, int dstMonth1, int dstDayInMonth1,
int dstDay1, int time1, int time1mode, int dstDelta)
Here, time0mode specifies the mode of the starting time, and time1mode specifies the
mode of the ending time. Valid mode values include
STANDARD_TIME
WALL_TIME
UTC_TIME
The time mode indicates how the time values are interpreted. The default mode used by the
other constructors is WALL_TIME.
Locale
The Locale class is instantiated to produce objects that describe a geographical or cultural
region. It is one of several classes that provide you with the ability to write programs that
can execute in different international environments. For example, the formats used to display
dates, times, and numbers are different in various regions.
Internationalization is a large topic that is beyond the scope of this book. However, many
programs will only need to deal with its basics, which include setting the current locale.
The Locale class defines the following constants that are useful for dealing with the most
common locales:
CANADA GERMAN KOREAN
CANADA_FRENCH GERMANY PRC
515516
Part II:
The Java Library
CHINA ITALIAN SIMPLIFIED_CHINESE
CHINESE ITALY TAIWAN
ENGLISH JAPAN TRADITIONAL_CHINESE
FRANCE JAPANESE UK
FRENCH KOREA US
For example, the expression Locale.CANADA represents the Locale object for Canada.
The constructors for Locale are
Locale(String language)
Locale(String language, String country)
Locale(String language, String country, String data)
These constructors build a Locale object to represent a specific language and in the case
of the last two, country. These values must contain ISO-standard language and country codes.
Auxiliary browser and vendor-specific information can be provided in data.
Locale defines several methods. One of the most important is setDefault( ), shown here:
static void setDefault(Locale localeObj)
This sets the default locale to that specified by localeObj.
Some other interesting methods are the following:
final String getDisplayCountry( )
final String getDisplayLanguage( )
final String getDisplayName( )
These return human-readable strings that can be used to display the name of the country,
the name of the language, and the complete description of the locale.
The default locale can be obtained using getDefault( ), shown here:
static Locale getDefault( )
Calendar and GregorianCalendar are examples of classes that operate in a locale-
sensitive manner. DateFormat and SimpleDateFormat also depend on the locale.
Random
The Random class is a generator of pseudorandom numbers. These are called pseudorandom
numbers because they are simply uniformly distributed sequences. Random defines the
following constructors:
Random( )
Random(long seed)
The first version creates a number generator that uses the current time as the starting, or seed,
value. The second form allows you to specify a seed value manually.Chapter 18:
java.util Part 2: More Utility Classes
Method Description
boolean nextBoolean( ) Returns the next boolean random number.
void nextBytes(byte vals[ ]) Fills vals with randomly generated values.
double nextDouble( ) Returns the next double random number.
float nextFloat( ) Returns the next float random number.
double nextGaussian( ) Returns the next Gaussian random number.
int nextInt( ) Returns the next int random number.
int nextInt(int n) Returns the next int random number within the range zero to n.
long nextLong( ) Returns the next long random number.
void setSeed(long newSeed) Sets the seed value (that is, the starting point for the random
number generator) to that specified by newSeed.
T ABLE 18-6
The Methods Defined by Random
If you initialize a Random object with a seed, you define the starting point for the random
sequence. If you use the same seed to initialize another Random object, you will extract the
same random sequence. If you want to generate different sequences, specify different seed
values. The easiest way to do this is to use the current time to seed a Random object. This
approach reduces the possibility of getting repeated sequences.
The public methods defined by Random are shown in Table 18-6.
As you can see, there are seven types of random numbers that you can extract from a
Random object. Random Boolean values are available from nextBoolean( ). Random bytes
can be obtained by calling nextBytes( ). Integers can be extracted via the nextInt( ) method.
Long integers, uniformly distributed over their range, can be obtained with nextLong( ).
The nextFloat( ) and nextDouble( ) methods return a uniformly distributed float and double,
respectively, between 0.0 and 1.0. Finally, nextGaussian( ) returns a double value centered
at 0.0 with a standard deviation of 1.0. This is what is known as a bell curve.
Here is an example that demonstrates the sequence produced by nextGaussian( ). It
obtains 100 random Gaussian values and averages these values. The program also counts
the number of values that fall within two standard deviations, plus or minus, using increments
of 0.5 for each category. The result is graphically displayed sideways on the screen.
// Demonstrate random Gaussian values.
import java.util.Random;
class RandDemo 
Here is a sample program run. As you can see, a bell-like distribution of numbers is obtained.
Average of values: 0.0702235271133344
**
*******
******
***************
******************
*****************
*************
**********
********
***
Observable
The Observable class is used to create subclasses that other parts of your program can
observe. When an object of such a subclass undergoes a change, observing classes are
notified. Observing classes must implement the Observer interface, which defines the
update( ) method. The update( ) method is called when an observer is notified of a change
in an observed object.
Observable defines the methods shown in Table 18-7. An object that is being observed
must follow two simple rules. First, if it has changed, it must call setChanged( ). Second,
when it is ready to notify observers of this change, it must call notifyObservers( ). This
causes the update( ) method in the observing object(s) to be called. Be careful—if the object
calls notifyObservers( ) without having previously called setChanged( ), no action will take
place. The observed object must call both setChanged( ) and notifyObservers( ) before
update( ) will be called.
Notice that notifyObservers( ) has two forms: one that takes an argument and one that does
not. If you call notifyObservers( ) with an argument, this object is passed to the observer’s
update( ) method as its second parameter. Otherwise, null is passed to update( ). You can use
the second parameter for passing any type of object that is appropriate for your application.Chapter 18:
java.util Part 2: More Utility Classes
Method Description
void addObserver(Observer obj) Adds obj to the list of objects observing the invoking object.
protected void clearChanged( ) Calling this method returns the status of the invoking object
to “unchanged.”
int countObservers( ) Returns the number of objects observing the invoking object.
void deleteObserver(Observer obj) Removes obj from the list of objects observing the invoking
object.
void deleteObservers( ) Removes all observers for the invoking object.
boolean hasChanged( ) Returns true if the invoking object has been modified and
false if it has not.
void notifyObservers( ) Notifies all observers of the invoking object that it has
changed by calling update( ). A null is passed as the second
argument to update( ).
void notifyObservers(Object obj) Notifies all observers of the invoking object that it has
changed by calling update( ). obj is passed as an argument
to update( ).
protected void setChanged( ) Called when the invoking object has changed.
T ABLE 18-7
The Methods Defined by Observable
The Observer Interface
To observe an observable object, you must implement the Observer interface. This interface
defines only the one method shown here:
void update(Observable observOb, Object arg)
Here, observOb is the object being observed, and arg is the value passed by notifyObservers( ).
The update( ) method is called when a change in the observed object takes place.
An Observer Example
Here is an example that demonstrates an observable object. It creates an observer class,
called Watcher, that implements the Observer interface. The class being monitored is called
BeingWatched. It extends Observable. Inside BeingWatched is the method counter( ),
which simply counts down from a specified value. It uses sleep( ) to wait a tenth of a
second between counts. Each time the count changes, notifyObservers( ) is called with the
current count passed as its argument. This causes the update( ) method inside Watcher to
be called, which displays the current count. Inside main( ), a Watcher and a BeingWatched
object, called observing and observed, respectively, are created. Then, observing is added
to the list of observers for observed. This means that observing.update( ) will be called each
time counter( ) calls notifyObservers( ).
/* Demonstrate the Observable class and the
Observer interface.
*/
519520
Part II:
The Java Library
import java.util.*;
// This is the observing class.
class Watcher implements Observer 
/ This is the class being observed.
class BeingWatched extends Observable 
class ObserverDemo 
The output from this program is shown here:
update()
update()
update()
update()
update()
update()
update()
update()
update()
update()
update()
called,
called,
called,
called,
called,
called,
called,
called,
called,
called,
called,
count
count
count
count
count
count
count
count
count
count
count
is
is
is
is
is
is
is
is
is
is
is
10
9
8
7
6
5
4
3
2
1
0Chapter 18:
java.util Part 2: More Utility Classes
More than one object can be an observer. For example, the following program implements
two observing classes and adds an object of each class to the BeingWatched observer list. The
second observer waits until the count reaches zero and then rings the bell.
/* An object may be observed by two or more
observers.
*/
import java.util.*;
// This is the first observing class.
class Watcher1 implements Observer 
// This is the second observing class.
class Watcher2 implements Observer 
// This is the class being observed.
class BeingWatched extends Observable 
class TwoObservers 
521522
Part II:
The Java Library
The Observable class and the Observer interface allow you to implement sophisticated
program architectures based on the document/view methodology. They are also useful in
multithreaded situations.
Timer and TimerTask
An interesting and useful feature offered by java.util is the ability to schedule a task for
execution at some future time. The classes that support this are Timer and TimerTask. Using
these classes, you can create a thread that runs in the background, waiting for a specific
time. When the time arrives, the task linked to that thread is executed. Various options
allow you to schedule a task for repeated execution, and to schedule a task to run on a
specific date. Although it was always possible to manually create a task that would be
executed at a specific time using the Thread class, Timer and TimerTask greatly simplify
this process.
Timer and TimerTask work together. Timer is the class that you will use to schedule
a task for execution. The task being scheduled must be an instance of TimerTask. Thus, to
schedule a task, you will first create a TimerTask object and then schedule it for execution
using an instance of Timer.
TimerTask implements the Runnable interface; thus, it can be used to create a thread
of execution. Its constructor is shown here:
TimerTask( )
TimerTask defines the methods shown in Table 18-8. Notice that run( ) is abstract, which
means that it must be overridden. The run( ) method, defined by the Runnable interface,
contains the code that will be executed. Thus, the easiest way to create a timer task is to extend
TimerTask and override run( ).
Once a task has been created, it is scheduled for execution by an object of type Timer.
The constructors for Timer are shown here:
Timer( )
Timer(boolean DThread)
Timer(String tName)
Timer(String tName, boolean DThread)
The first version creates a Timer object that runs as a normal thread. The second uses a
daemon thread if DThread is true. A daemon thread will execute only as long as the rest of
the program continues to execute. The third and fourth constructors allow you to specify a
name for the Timer thread. The methods defined by Timer are shown in Table 18-9.
Method Description
boolean cancel( ) Terminates the task. Returns true if an execution of the task is
prevented. Otherwise, returns false.
abstract void run( ) Contains the code for the timer task.
long scheduledExecutionTime( ) Returns the time at which the last execution of the task was
scheduled to have occurred.
T ABLE 18-8
The Methods Defined by TimerTaskChapter 18:
java.util Part 2: More Utility Classes
Method Description
void cancel( ) Cancels the timer thread.
int purge( ) Deletes cancelled tasks from the timer’s queue.
void schedule(TimerTask TTask,
long wait) TTask is scheduled for execution after the period passed
in wait has elapsed. The wait parameter is specified in
milliseconds.
void schedule(TimerTask TTask,
long wait, long repeat) TTask is scheduled for execution after the period passed
in wait has elapsed. The task is then executed repeatedly
at the interval specified by repeat. Both wait and repeat
are specified in milliseconds.
void schedule(TimerTask TTask,
Date targetTime) TTask is scheduled for execution at the time specified
by targetTime.
void schedule(TimerTask TTask,
Date targetTime,
long repeat) TTask is scheduled for execution at the time specified
by targetTime. The task is then executed repeatedly at
the interval passed in repeat. The repeat parameter is
specified in milliseconds.
void scheduleAtFixedRate(
TimerTask TTask,
long wait, long repeat) TTask is scheduled for execution after the period passed
in wait has elapsed. The task is then executed repeatedly
at the interval specified by repeat. Both wait and repeat
are specified in milliseconds. The time of each repetition is
relative to the first execution, not the preceding execution.
Thus, the overall rate of execution is fixed.
void scheduleAtFixedRate(
TimerTask TTask,
Date targetTime,
long repeat) TTask is scheduled for execution at the time specified
by targetTime. The task is then executed repeatedly at
the interval passed in repeat. The repeat parameter is
specified in milliseconds. The time of each repetition is
relative to the first execution, not the preceding execution.
Thus, the overall rate of execution is fixed.
T ABLE 18-9
The Methods Defined by Timer
Once a Timer has been created, you will schedule a task by calling schedule( ) on the
Timer that you created. As Table 18-9 shows, there are several forms of schedule( ) which
allow you to schedule tasks in a variety of ways.
If you create a non-daemon task, then you will want to call cancel( ) to end the task when
your program ends. If you don’t do this, then your program may “hang” for a period of time.
The following program demonstrates Timer and TimerTask. It defines a timer task whose
run( ) method displays the message “Timer task executed.” This task is scheduled to run once
every half second after an initial delay of one second.
// Demonstrate Timer and TimerTask.
import java.util.*;
class MyTimerTask extends TimerTask 
class TTest 
Currency
The Currency class encapsulates information about a currency. It defines no constructors. The
methods supported by Currency are shown in Table 18-10. The following program
demonstrates Currency:
// Demonstrate Currency.
import java.util.*;
class CurDemo 
The output is shown here:
Symbol: $
Default fractional digits: 2Chapter 18:
java.util Part 2: More Utility Classes
Method Description
String getCurrencyCode( ) Returns the code (as defined by ISO 4217) that describes
the invoking currency.
int getDefaultFractionDigits( ) Returns the number of digits after the decimal point that
are normally used by the invoking currency. For example,
there are 2 fractional digits normally used for dollars.
static Currency
getInstance(Locale localeObj) Returns a Currency object for the locale specified by
localeObj.
static Currency
getInstance(String code) Returns a Currency object associated with the currency
code passed in code.
String getSymbol( ) Returns the currency symbol (such as $) for the invoking
object.
String getSymbol(Locale localeObj) Returns the currency symbol (such as $) for the locale
passed in localeObj.
String toString( )
T ABLE 18-10
Returns the currency code for the invoking object.
The Methods Defined by Currency
Formatter
With the release of JDK 5, Java added a capability long desired by programmers: the ability to
easily create formatted output. Since the beginning, Java has offered a rich and varied API, but
it had not always offered an easy way to create formatted text output, especially for numeric
values. Classes such as NumberFormat, DateFormat, and MessageFormat provided by earlier
versions of Java do have useful formatting capabilities, but they were not especially convenient
to use. Furthermore, unlike C and C++ that support the widely understood and used printf( )
family of functions which offers a simple way to format output, Java had previously not offered
such methods. One reason for this is that printf-style formatting requires the use of
variable-length arguments (varargs), which Java did not support until the release of JDK 5. Once
varargs were available, it was a simple matter to add a general-purpose formatter.
At the core of Java’s support for creating formatted output is the Formatter class. It provides
format conversions that let you display numbers, strings, and time and date in virtually any
format you like. It operates in a manner similar to the C/C++ printf( ) function, which means
that if you are familiar with C/C++, then learning to use Formatter will be very easy. It also
further streamlines the conversion of C/C++ code to Java. If you are not familiar with C/C++,
it is still quite easy to format data.
N OTE Although Java’s Formatter class operates in a manner very similar to the C/C++ printf( )
function, there are some differences, and some new features. Therefore, if you have a C/C++
background, a careful reading is advised.
525526
Part II:
The Java Library
The Formatter Constructors
Before you can use Formatter to format output, you must create a Formatter object. In general,
Formatter works by converting the binary form of data used by a program into formatted
text. It stores the formatted text in a buffer, the contents of which can be obtained by your
program whenever they are needed. It is possible to let Formatter supply this buffer
automatically, or you can specify the buffer explicitly when a Formatter object is created.
It is also possible to have Formatter output its buffer to a file.
The Formatter class defines many constructors, which enable you to construct a Formatter
in a variety of ways. Here is a sampling:
Formatter( )
Formatter(Appendable buf)
Formatter(Appendable buf, Locale loc)
Formatter(String filename)
throws FileNotFoundException
Formatter(String filename, String charset)
throws FileNotFoundException, UnsupportedEncodingException
Formatter(File outF)
throws FileNotFoundException
Formatter(OutputStream outStrm)
Here, buf specifies a buffer for the formatted output. If buf is null, then Formatter automatically
allocates a StringBuilder to hold the formatted output. The loc parameter specifies a locale.
If no locale is specified, the default locale is used. The filename parameter specifies the name
of a file that will receive the formatted output. The charset parameter specifies the character
set. If no character set is specified, then the default character set is used. The outF parameter
specifies a reference to an open file that will receive output. The outStrm parameter specifies
a reference to an output stream that will receive output. When using a file, output is also
written to the file.
Perhaps the most widely used constructor is the first, which has no parameters.
It automatically uses the default locale and allocates a StringBuilder to hold the formatted
output.
The Formatter Methods
Formatter defines the methods shown in Table 18-11.
Formatting Basics
After you have created a Formatter, you can use it to create a formatted string. To do so, use
the format( ) method. The most commonly used version is shown here:
Formatter format(String fmtString, Object ... args)Chapter 18:
java.util Part 2: More Utility Classes
Method Description
void close( ) Closes the invoking Formatter. This causes any resources
used by the object to be released. After a Formatter has
been closed, it cannot be reused. An attempt to use a
closed Formatter results in a FormatterClosedException.
void flush( ) Flushes the format buffer. This causes any output currently
in the buffer to be written to the destination. This applies
mostly to a Formatter tied to a file.
Formatter format(String fmtString,
Object ... args) Formats the arguments passed via args according to the format
specifiers contained in fmtString. Returns the invoking object.
Formatter format(Locale loc,
String fmtString,
Object ... args) Formats the arguments passed via args according to the format
specifiers contained in fmtString. The locale specified by loc is
used for this format. Returns the invoking object.
IOException ioException( ) If the underlying object that is the destination for output throws
an IOException, then this exception is returned. Otherwise,
null is returned.
Locale locale( ) Returns the invoking object’s locale.
Appendable out( ) Returns a reference to the underlying object that is the
destination for output.
String toString( ) Returns a String containing the formatted output.
T ABLE 18-11
The Methods Defined by Formatter
The fmtSring consists of two types of items. The first type is composed of characters that are
simply copied to the output buffer. The second type contains format specifiers that define the
way the subsequent arguments are displayed.
In its simplest form, a format specifier begins with a percent sign followed by the format
conversion specifier. All format conversion specifiers consist of a single character. For example,
the format specifier for floating-point data is %f. In general, there must be the same number
of arguments as there are format specifiers, and the format specifiers and the arguments are
matched in order from left to right. For example, consider this fragment:
Formatter fmt = new Formatter();
fmt.format("Formatting %s is easy %d %f", "with Java", 10, 98.6);
This sequence creates a Formatter that contains the following string:
Formatting with Java is easy 10 98.600000
In this example, the format specifiers, %s, %d, and %f, are replaced with the arguments that
follow the format string. Thus, %s is replaced by “with Java”, %d is replaced by 10, and %f
is replaced by 98.6. All other characters are simply used as-is. As you might guess, the
format specifier %s specifies a string, and %d specifies an integer value. As mentioned
earlier, the %f specifies a floating-point value.
527528
Part II:
T ABLE 18-12
The Format
Specifiers
The Java Library
Format Specifier Conversion Applied
%a
%A Floating-point hexadecimal
%b
%B Boolean
%c Character
%d Decimal integer
%h
%H Hash code of the argument
%e
%E Scientific notation
%f Decimal floating-point
%g
%G Uses %e or %f, whichever is shorter
%o Octal integer
%n Inserts a newline character
%s
%S String
%t
%T Time and date
%x
%X Integer hexadecimal
%% Inserts a % sign
The format( ) method accepts a wide variety of format specifiers, which are shown in
Table 18-12. Notice that many specifiers have both upper- and lowercase forms. When an
uppercase specifier is used, then letters are shown in uppercase. Otherwise, the upper- and
lowercase specifiers perform the same conversion. It is important to understand that Java
type-checks each format specifier against its corresponding argument. If the argument doesn’t
match, an IllegalFormatException is thrown.
Once you have formatted a string, you can obtain it by calling toString( ). For example,
continuing with the preceding example, the following statement obtains the formatted string
contained in fmt:
String str = fmt.toString();
Of course, if you simply want to display the formatted string, there is no reason to first
assign it to a String object. When a Formatter object is passed to println( ), for example, its
toString( ) method is automatically called.
Here is a short program that puts together all of the pieces, showing how to create and
display a formatted string:Chapter 18:
java.util Part 2: More Utility Classes
// A very simple example that uses Formatter.
import java.util.*;
class FormatDemo 
One other point: You can obtain a reference to the underlying output buffer by calling
out( ). It returns a reference to an Appendable object.
Now that you know the general mechanism used to create a formatted string, the remainder
of this section discusses in detail each conversion. It also describes various options, such as
justification, minimum field width, and precision.
Formatting Strings and Characters
To format an individual character, use %c. This causes the matching character argument to
be output, unmodified. To format a string, use %s.
Formatting Numbers
To format an integer in decimal format, use %d. To format a floating-point value in decimal
format, use %f. To format a floating-point value in scientific notation, use %e. Numbers
represented in scientific notation take this general form:
x.dddddde+/–yy
The %g format specifier causes Formatter to use either %f or %e, whichever is shorter.
The following program demonstrates the effect of the %g format specifier:
// Demonstrate the %g format specifier.
import java.util.*;
class FormatDemo2 
529530
Part II:
The Java Library
It produces the following output:
1000.000000
1000.000000 100000.000000
1000.000000 100000.000000 1.000000e+07
1000.000000 100000.000000 1.000000e+07 1.000000e+09
You can display integers in octal or hexadecimal format by using %o and %x, respectively.
For example, this fragment:
fmt.format("Hex: %x, Octal: %o", 196, 196);
produces this output:
Hex: c4, Octal: 304
You can display floating-point values in hexadecimal format by using %a. The format
produced by %a appears a bit strange at first glance. This is because its representation uses
a form similar to scientific notation that consists of a significand and an exponent, both in
hexadecimal. Here is the general format:
0x1.sigpexp
Here, sig contains the fractional portion of the significand and exp contains the exponent.
The p indicates the start of the exponent. For example, this call:
fmt.format("%a", 123.123);
produces this output:
0x1.ec7df3b645a1dp6
Formatting Time and Date
One of the more powerful conversion specifiers is %t. It lets you format time and date
information. The %t specifier works a bit differently than the others because it requires the
use of a suffix to describe the portion and precise format of the time or date desired. The
suffixes are shown in Table 18-13. For example, to display minutes, you would use %tM,
where M indicates minutes in a two-character field. The argument corresponding to the %t
specifier must be of type Calendar, Date, Long, or long.
Here is a program that demonstrates several of the formats:
// Formatting time and date.
import java.util.*;
class TimeDateFormat 
Sample output is shown here:
09:17:15 AM
Mon Jan 01 09:17:15 CST 2007
9:17
January Jan 01
T ABLE 18-13
The Time and Date
Format Suffixes
Suffix Replaced By
a Abbreviated weekday name
A Full weekday name
b Abbreviated month name
B Full month name
c Standard date and time string formatted as
day month date hh::mm:ss tzone year
C First two digits of year
d Day of month as a decimal (01–31)
D month/day/year
e Day of month as a decimal (1–31)
F year-month-day
h Abbreviated month name
H Hour (00 to 23)
I Hour (01 to 12)
j Day of year as a decimal (001 to 366)
k Hour (0 to 23)
l Hour (1 to 12)
531532
Part II: The Java Library
T ABLE 18-13 Suffix Replaced By
L Millisecond (000 to 999)
m Month as decimal (01 to 13)
M Minute as decimal (00 to 59)
N Nanosecond (000000000 to 999999999)
p Locale’s equivalent of AM or PM in lowercase
Q Milliseconds from 1/1/1970
r hh:mm:ss (12-hour format)
The Time and Date
Format Suffixes
(continued)
R hh:mm (24-hour format)
S Seconds (00 to 60)
s Seconds from 1/1/1970 UTC
T hh:mm:ss (24-hour format)
y Year in decimal without century (00 to 99)
Y Year in decimal including century (0001 to 9999)
z Offset from UTC
Z Time zone name
The %n and %% Specifiers
The %n and %% format specifiers differ from the others in that they do not match an
argument. Instead, they are simply escape sequences that insert a character into the output
sequence. The %n inserts a newline. The %% inserts a percent sign. Neither of these characters
can be entered directly into the format string. Of course, you can also use the standard
escape sequence \n to embed a newline character.
Here is an example that demonstrates the %n and %% format specifiers:
// Demonstrate the %n and %% format specifiers.
import java.util.*;
class FormatDemo3 
It displays the following output:
Copying file
Transfer is 88% completeChapter 18:
java.util Part 2: More Utility Classes
Specifying a Minimum Field Width
An integer placed between the % sign and the format conversion code acts as a minimum
field-width specifier. This pads the output with spaces to ensure that it reaches a certain
minimum length. If the string or number is longer than that minimum, it will still be
printed in full. The default padding is done with spaces. If you want to pad with 0’s, place
a 0 before the field-width specifier. For example, %05d will pad a number of less than five
digits with 0’s so that its total length is five. The field-width specifier can be used with all
format specifiers except %n.
The following program demonstrates the minimum field-width specifier by applying
it to the %f conversion:
// Demonstrate a field-width specifier.
import java.util.*;
class FormatDemo4 
This program produces the following output:
|10.123450|
|
10.123450|
|00010.123450|
The first line displays the number 10.12345 in its default width. The second line displays
that value in a 12-character field. The third line displays the value in a 12-character field,
padded with leading zeros.
The minimum field-width modifier is often used to produce tables in which the columns
line up. For example, the next program produces a table of squares and cubes for the numbers
between 1 and 10:
// Create a table of squares and cubes.
import java.util.*;
class FieldWidthDemo 
Its output is shown here:
1
2
3
4
5
6
7
8
9
10
1
1
4
8
9
27
16
64
25 125
36 216
49 343
64 512
81 729
100 1000
Specifying Precision
A precision specifier can be applied to the %f, %e, %g, and %s format specifiers. It follows the
minimum field-width specifier (if there is one) and consists of a period followed by an integer.
Its exact meaning depends upon the type of data to which it is applied.
When you apply the precision specifier to floating-point data using the %f or %e
specifiers, it determines the number of decimal places displayed. For example, %10.4f displays
a number at least ten characters wide with four decimal places. When using %g, the precision
determines the number of significant digits. The default precision is 6.
Applied to strings, the precision specifier specifies the maximum field length. For example,
%5.7s displays a string at least five and not exceeding seven characters long. If the string is
longer than the maximum field width, the end characters will be truncated.
The following program illustrates the precision specifier:
// Demonstrate the precision modifier.
import java.util.*;
class PrecisionDemo 
It produces the following output:
123.1235
1.23e+02
Formatting with
Using the Format Flags
Formatter recognizes a set of format flags that lets you control various aspects of a conversion.
All format flags are single characters, and a format flag follows the % in a format specification.
The flags are shown here:
Flag Effect
– Left justification
# Alternate conversion format
0 Output is padded with zeros rather than spaces
space Positive numeric output is preceded by a space
+ Positive numeric output is preceded by a + sign
, Numeric values include grouping separators
( Negative numeric values are enclosed within parentheses
Not all flags apply to all format specifiers. The following sections explain each in detail.
Justifying Output
By default, all output is right-justified. That is, if the field width is larger than the data printed,
the data will be placed on the right edge of the field. You can force output to be left-justified
by placing a minus sign directly after the %. For instance, %–10.2f left-justifies a floating-point
number with two decimal places in a 10-character field. For example, consider this program:
// Demonstrate left justification.
import java.util.*;
class LeftJustify 
It produces the following output:
|
123.12|
|123.12
|
As you can see, the second line is left-justified within a 10-character field.
The Space, +, 0, and ( Flags
To cause a + sign to be shown before positive numeric values, add the + flag. For example,
fmt.format("%+d", 100);
creates this string:
+100
When creating columns of numbers, it is sometimes useful to output a space before
positive values so that positive and negative values line up. To do this, add the space flag.
For example,
// Demonstrate the space format specifiers.
import java.util.*;
class FormatDemo5 Chapter 18:
java.util Part 2: More Utility Classes
The output is shown here:
-100
100
-200
200
Notice that the positive values have a leading space, which causes the digits in the column
to line up properly.
To show negative numeric output inside parentheses, rather than with a leading , – use
the ( flag. For example,
fmt.format("%(d", -100);
creates this string:
(100)
The 0 flag causes output to be padded with zeros rather than spaces.
The Comma Flag
When displaying large numbers, it is often useful to add grouping separators, which in
English are commas. For example, the value 1234567 is more easily read when formatted
as 1,234,567. To add grouping specifiers, use the comma (,) flag. For example,
fmt.format("%,.2f", 4356783497.34);
creates this string:
4,356,783,497.34
The # Flag
The # can be applied to %o, %x, %e, and %f. For %e and %f, the # ensures that there
will be a decimal point even if there are no decimal digits. If you precede the %x format
specifier with a #, the hexadecimal number will be printed with a 0x prefix. Preceding the
%o specifier with # causes the number to be printed with a leading zero.
The Uppercase Option
As mentioned earlier, several of the format specifiers have uppercase versions that cause the
conversion to use uppercase where appropriate. The following table describes the effect.
Specifier Effect
%A Causes the hexadecimal digits a through f to be displayed in uppercase as A
through F. Also, the prefix 0x is displayed as 0X, and the p will be displayed as P.
%B Uppercases the values true and false.
537538
Part II:
The Java Library
Specifier Effect
%E Causes the e symbol that indicates the exponent to be displayed in uppercase.
%G Causes the e symbol that indicates the exponent to be displayed in uppercase.
%H Causes the hexadecimal digits a through f to be displayed in uppercase as A
through F.
%S Uppercases the corresponding string.
%T Causes all alphabetical output to be displayed in uppercase.
%X Causes the hexadecimal digits a through f to be displayed in uppercase as A
through F. Also, the optional prefix 0x is displayed as 0X, if present.
For example, this call:
fmt.format("%X", 250);
creates this string:
FA
This call:
fmt.format("%E", 123.1234);
creates this string:
1.231234E+02
Using an Argument Index
Formatter includes a very useful feature that lets you specify the argument to which a format
specifier applies. Normally, format specifiers and arguments are matched in order, from left
to right. That is, the first format specifier matches the first argument, the second format
specifier matches the second argument, and so on. However, by using an argument index,
you can explicitly control which argument a format specifier matches.
An argument index immediately follows the % in a format specifier. It has the following
format:
n$
where n is the index of the desired argument, beginning with 1. For example, consider this
example:
fmt.format("%3$d %1$d %2$d", 10, 20, 30);
It produces this string:
30 10 20Chapter 18:
java.util Part 2: More Utility Classes
In this example, the first format specifier matches 30, the second matches 10, and the
third matches 20. Thus, the arguments are used in an order other than strictly left to right.
One advantage of argument indexes is that they enable you to reuse an argument without
having to specify it twice. For example, consider this line:
fmt.format("%d in hex is %1$x", 255);
It produces the following string:
255 in hex is ff
As you can see, the argument 255 is used by both format specifiers.
There is a convenient shorthand called a relative index that enables you to reuse the
argument matched by the preceding format specifier. Simply specify < for the argument
index. For example, the following call to format( ) produces the same results as the previous
example:
fmt.format("%d in hex is %<x", 255);
Relative indexes are especially useful when creating custom time and date formats.
Consider the following example:
// Use relative indexes to simplify the
// creation of a custom time and date format.
import java.util.*;
class FormatDemo6 
Here is sample output:
Today is day 1 of Jan, 2007
Because of relative indexing, the argument cal need only be passed once, rather than
three times.
The Java printf( ) Connection
Although there is nothing technically wrong with using Formatter directly (as the preceding
examples have done) when creating output that will be displayed on the console, there is
a more convenient alternative: the printf( ) method. The printf( ) method automatically uses
Formatter to create a formatted string. It then displays that string on System.out, which
is the console by default. The printf( ) method is defined by both PrintStream and
PrintWriter. The printf( ) method is described in Chapter 19.
539540
Part II:
The Java Library
Scanner
Scanner is the complement of Formatter. Added by JDK 5, Scanner reads formatted input
and converts it into its binary form. Although it has always been possible to read formatted
input, it required more effort than most programmers would prefer. Because of the addition
of Scanner, it is now easy to read all types of numeric values, strings, and other types of
data, whether it comes from a disk file, the keyboard, or another source.
Scanner can be used to read input from the console, a file, a string, or any source that
implements the Readable interface or ReadableByteChannel. For example, you can use
Scanner to read a number from the keyboard and assign its value to a variable. As you will
see, given its power, Scanner is surprisingly easy to use.
The Scanner Constructors
Scanner defines the constructors shown in Table 18-14. In general, a Scanner can be
created for a String, an InputStream, a File, or any object that implements the Readable
or ReadableByteChannel interfaces. Here are some examples.
The following sequence creates a Scanner that reads the file Test.txt:
FileReader fin = new FileReader("Test.txt");
Scanner src = new Scanner(fin);
This works because FileReader implements the Readable interface. Thus, the call to the
constructor resolves to Scanner(Readable).
Method Description
Scanner(File from)
throws FileNotFoundException Creates a Scanner that uses the file specified by
from as a source for input.
Scanner(File from, String charset)
throws FileNotFoundException Creates a Scanner that uses the file specified by from
with the encoding specified by charset as a source for
input.
Scanner(InputStream from) Creates a Scanner that uses the stream specified
by from as a source for input.
Scanner(InputStream from, String charset) Creates a Scanner that uses the stream specified
by from with the encoding specified by charset as
a source for input.
Scanner(Readable from) Creates a Scanner that uses the Readable object
specified by from as a source for input.
Scanner (ReadableByteChannel from) Creates a Scanner that uses the ReadableByteChannel
specified by from as a source for input.
Scanner(ReadableByteChannel from,
String charset) Creates a Scanner that uses the ReadableByteChannel
specified by from with the encoding specified by charset
as a source for input.
Scanner(String from) Creates a Scanner that uses the string specified by
from as a source for input.
T ABLE 18-14
The Scanner ConstructorsChapter 18:
java.util Part 2: More Utility Classes
This next line creates a Scanner that reads from standard input, which is the keyboard
by default:
Scanner conin = new Scanner(System.in);
This works because System.in is an object of type InputStream. Thus, the call to the
constructor maps to Scanner(InputStream).
The next sequence creates a Scanner that reads from a string.
String instr = "10 99.88 scanning is easy.";
Scanner conin = new Scanner(instr);
Scanning Basics
Once you have created a Scanner, it is a simple matter to use it to read formatted input.
In general, a Scanner reads tokens from the underlying source that you specified when the
Scanner was created. As it relates to Scanner, a token is a portion of input that is delineated
by a set of delimiters, which is whitespace by default. A token is read by matching it with a
particular regular expression, which defines the format of the data. Although Scanner allows
you to define the specific type of expression that its next input operation will match, it includes
many predefined patterns, which match the primitive types, such as int and double, and
strings. Thus, often you won’t need to specify a pattern to match.
In general, to use Scanner, follow this procedure:
1. Determine if a specific type of input is available by calling one of Scanner’s
hasNextX methods, where X is the type of data desired.
2. If input is available, read it by calling one of Scanner’s nextX methods.
3. Repeat the process until input is exhausted.
As the preceding indicates, Scanner defines two sets of methods that enable you to read
input. The first are the hasNextX methods, which are shown in Table 18-15. These methods
determine if the specified type of input is available. For example, calling hasNextInt( ) returns
true only if the next token to be read is an integer. If the desired data is available, then you
read it by calling one of Scanner’s nextX methods, which are shown in Table 18-16. For
example, to read the next integer, call nextInt( ). The following sequence shows how to read
a list of integers from the keyboard.
Scanner conin = new Scanner(System.in);
int i;
// Read a list of integers.
while(conin.hasNextInt()) 
541542
Part II:
The Java Library
Method Description
boolean hasNext( ) Returns true if another token of any type is available to
be read. Returns false otherwise.
boolean hasNext(Pattern pattern) Returns true if a token that matches the pattern passed
in pattern is available to be read. Returns false otherwise.
boolean hasNext(String pattern) Returns true if a token that matches the pattern passed
in pattern is available to be read. Returns false otherwise.
boolean hasNextBigDecimal( ) Returns true if a value that can be stored in a BigDecimal
object is available to be read. Returns false otherwise.
boolean hasNextBigInteger( ) Returns true if a value that can be stored in a BigInteger
object is available to be read. Returns false otherwise. The
default radix is used. (Unless changed, the default radix is 10.)
boolean hasNextBigInteger(int radix) Returns true if a value in the specified radix that can be
stored in a BigInteger object is available to be read.
Returns false otherwise.
boolean hasNextBoolean( ) Returns true if a boolean value is available to be read.
Returns false otherwise.
boolean hasNextByte( ) Returns true if a byte value is available to be read. Returns
false otherwise. The default radix is used. (Unless changed,
the default radix is 10.)
boolean hasNextByte(int radix) Returns true if a byte value in the specified radix is available
to be read. Returns false otherwise.
boolean hasNextDouble( ) Returns true if a double value is available to be read. Returns
false otherwise.
boolean hasNextFloat( ) Returns true if a float value is available to be read. Returns
false otherwise.
boolean hasNextInt( ) Returns true if an int value is available to be read. Returns
false otherwise. The default radix is used. (Unless changed,
the default radix is 10.)
boolean hasNextInt(int radix) Returns true if an int value in the specified radix is available
to be read. Returns false otherwise.
boolean hasNextLine( ) Returns true if a line of input is available.
boolean hasNextLong( ) Returns true if a long value is available to be read. Returns
false otherwise. The default radix is used. (Unless changed,
the default radix is 10.)
boolean hasNextLong(int radix) Returns true if a long value in the specified radix is available
to be read. Returns false otherwise.
boolean hasNextShort( ) Returns true if a short value is available to be read.
Returns false otherwise. The default radix is used. (Unless
changed, the default radix is 10.)
boolean hasNextShort(int radix) Returns true if a short value in the specified radix is available
to be read. Returns false otherwise.
T ABLE 18-15
The Scanner hasNext MethodsChapter 18:
java.util Part 2: More Utility Classes
Method Description
String next( ) Returns the next token of any type from the input source.
String next(Pattern pattern) Returns the next token that matches the pattern passed
in pattern from the input source.
String next(String pattern) Returns the next token that matches the pattern passed
in pattern from the input source.
BigDecimal nextBigDecimal( ) Returns the next token as a BigDecimal object.
BigInteger nextBigInteger( ) Returns the next token as a BigInteger object. The default
radix is used. (Unless changed, the default radix is 10.)
BigInteger nextBigInteger(int radix) Returns the next token (using the specified radix) as a
BigInteger object.
boolean nextBoolean( ) Returns the next token as a boolean value.
byte nextByte( ) Returns the next token as a byte value. The default radix
is used. (Unless changed, the default radix is 10.)
byte nextByte(int radix) Returns the next token (using the specified radix) as a
byte value.
double nextDouble( ) Returns the next token as a double value.
float nextFloat( ) Returns the next token as a float value.
int nextInt( ) Returns the next token as an int value. The default radix
is used. (Unless changed, the default radix is 10.)
int nextInt(int radix) Returns the next token (using the specified radix) as an
int value.
String nextLine( ) Returns the next line of input as a string.
long nextLong( ) Returns the next token as a long value. The default radix
is used. (Unless changed, the default radix is 10.)
long nextLong(int radix) Returns the next token (using the specified radix) as a
long value.
short nextShort( ) Returns the next token as a short value. The default radix
is used. (Unless changed, the default radix is 10.)
short nextShort(int radix) Returns the next token (using the specified radix) as a
short value.
T ABLE 18-16
The Scanner next Methods
The while loop stops as soon as the next token is not an integer. Thus, the loop
stops reading integers as soon as a non-integer is encountered in the input stream.
If a next method cannot find the type of data it is looking for, it throws a
NoSuchElementException. For this reason, it is best to first confirm that the desired type of
data is available by calling a hasNext method before calling its corresponding next method.
543544
Part II:
The Java Library
Some Scanner Examples
The addition of Scanner to Java makes what was formerly a tedious task into an easy one.
To understand why, let’s look at some examples. The following program averages a list of
numbers entered at the keyboard:
// Use Scanner to compute an average of the values.
import java.util.*;
class AvgNums 
The program reads numbers from the keyboard, summing them in the process, until the
user enters the string “done”. It then stops input and displays the average of the numbers.
Here is a sample run:
Enter numbers to average.
1.2
2
3.4
4
done
Average is 2.65
The program reads numbers until it encounters a token that does not represent a valid
double value. When this occurs, it confirms that the token is the string “done”. If it is, the
program terminates normally. Otherwise, it displays an error.Chapter 18:
java.util Part 2: More Utility Classes
Notice that the numbers are read by calling nextDouble( ). This method reads any
number that can be converted into a double value, including an integer value, such as 2,
and a floating-point value like 3.4. Thus, a number read by nextDouble( ) need not specify a
decimal point. This same general principle applies to all next methods. They will match and
read any data format that can represent the type of value being requested.
One thing that is especially nice about Scanner is that the same technique used to read
from one source can be used to read from another. For example, here is the preceding program
reworked to average a list of numbers contained in a text file:
// Use Scanner to compute an average of the values in a file.
import java.util.*;
import java.io.*;
class AvgFile 
Here is the output:
Average is 6.2
545546
Part II:
The Java Library
You can use Scanner to read input that contains several different types of data—even if
the order of that data is unknown in advance. You must simply check what type of data is
available before reading it. For example, consider this program:
// Use Scanner to read various types of data from a file.
import java.util.*;
import java.io.*;
class ScanMixed 
Here is the output:
String: Testing
String: ScannerChapter 18:
java.util Part 2: More Utility Classes
int: 10
double: 12.2
String: one
boolean: true
String: two
boolean: false
When reading mixed data types, as the preceding program does, you need to be a bit
careful about the order in which you call the next methods. For example, if the loop reversed
the order of the calls to nextInt( ) and nextDouble( ), both numeric values would have been
read as doubles, because nextDouble( ) matches any numeric string that can be represented
as a double.
Setting Delimiters
Scanner defines where a token starts and ends based on a set of delimiters. The default delimiters
are the whitespace characters, and this is the delimiter set that the preceding examples have
used. However, it is possible to change the delimiters by calling the useDelimiter( ) method,
shown here:
Scanner useDelimiter(String pattern)
Scanner useDelimiter(Pattern pattern)
Here, pattern is a regular expression that specifies the delimiter set.
Here is the program that reworks the average program shown earlier so that it reads a
list of numbers that are separated by commas, and any number of spaces:
// Use Scanner to compute an average a list of
// comma-separated values.
import java.util.*;
import java.io.*;
class SetDelimiters 
In this version, the numbers written to test.txt are separated by commas and spaces. The
use of the delimiter pattern “, *” tells Scanner to match a comma and zero or more spaces as
delimiters. The output is the same as before.
You can obtain the current delimiter pattern by calling delimiter( ), shown here:
Pattern delimiter( )
Other Scanner Features
Scanner defines several other methods in addition to those already discussed. One that is
particularly useful in some circumstances is findInLine( ). Its general forms are shown here:
String findInLine(Pattern pattern)
String findInLine(String pattern)
This method searches for the specified pattern within the next line of text. If the pattern is
found, the matching token is consumed and returned. Otherwise, null is returned. It operates
independently of any delimiter set. This method is useful if you want to locate a specific
pattern. For example, the following program locates the Age field in the input string and
then displays the age:
// Demonstrate findInLine().
import java.util.*;
class FindInLineDemo 
The output is 28. In the program, findInLine( ) is used to find an occurrence of the pattern
“Age”. Once found, the next token is read, which is the age.
Related to findInLine( ) is findWithinHorizon( ) It is shown here:
String findWithinHorizon(Pattern pattern, int count)
String findWithinHorizon(String pattern, int count)
This method attempts to find an occurrence of the specified pattern within the next count
characters. If successful, it returns the matching pattern. Otherwise, it returns null. If count is
zero, then all input is searched until either a match is found or the end of input is encountered.
You can bypass a pattern using skip( ), shown here:
Scanner skip(Pattern pattern)
Scanner skip(String pattern)
If pattern is matched, skip( ) simply advances beyond it and returns a reference to the invoking
object. If pattern is not found, skip( ) throws NoSuchElementException.
Other Scanner methods include radix( ), which returns the default radix used by the
Scanner; useRadix( ), which sets the radix; reset( ), which resets the scanner; and close( ),
which closes the scanner.
The ResourceBundle, ListResourceBundle,
and PropertyResourceBundle Classes
The java.util package includes three classes that aid in the internationalization of your
program. The first is the abstract class ResourceBundle. It defines methods that enable you
to manage a collection of locale-sensitive resources, such as the strings that are used to label
the user interface elements in your program. You can define two or more sets of translated
strings that support various languages, such as English, German, or Chinese, with each
translation set residing in its own bundle. You can then load the bundle appropriate to the
current locale and use the strings to construct the program’s user interface.
Resource bundles are identified by their family name (also called their base name). To
the family name can be added a two-character lowercase language code which specifies the
language. In this case, if a requested locale matches the language code, then that version
of the resource bundle is used. For example, a resource bundle with a family name of
SampleRB could have a German version called SampleRB_de and a Russian version
called SampleRB_ru. (Notice that an underscore links the family name to the language
code.) Therefore, if the locale is Locale.GERMAN, SampleRB_de will be used.
It is also possible to indicate specific variants of a language that relate to a specific country
by specifying a country code after the language code. A country code is a two-character uppercase
identifier, such as AU for Australia or IN for India. A country code is also preceded by an
549550
Part II:
The Java Library
underscore when linked to the resource bundle name. A resource bundle that has only the
family name is the default bundle. It is used when no language-specific bundles are applicable.
N OTE The language codes are defined by ISO standard 639 and the country codes by ISO
standard 3166.
The methods defined by ResourceBundle are summarized in Table 18-17. One important
point: null keys are not allowed and several of the methods will throw a NullPointerException
if null is passed as the key. Notice the nested class ResourceBundle.Control. It was added by
Java SE 6 and is used to control the resource-bundle loading process.
There are two subclasses of ResourceBundle. The first is PropertyResourceBundle, which
manages resources by using property files. PropertyResourceBundle adds no methods of
Method Description
static final void clearCache( ) Deletes all resource bundles from the cache that were
loaded by the default class loader. (Added by Java SE 6.)
static final void
clearCache(ClassLoader ldr) Deletes all resource bundles from the cache that were
loaded by ldr. (Added by Java SE 6.)
boolean containsKey(String k) Returns true if k is a key within the invoking resource
bundle (or its parent). (Added by Java SE 6.)
static final ResourceBundle
getBundle(String familyName) Loads the resource bundle with a family name of
familyName using the default locale and the default class
loader. Throws MissingResourceException if no resource
bundle matching the family name specified by familyName
is available.
static final ResourceBundle
getBundle(String familyName,
Locale loc) Loads the resource bundle with a family name of
familyName using the specified locale and the default
class loader. Throws MissingResourceException if no
resource bundle matching the family name specified by
familyName is available.
static ResourceBundle
getBundle(String familyName,
Locale loc,
ClassLoader ldr) Loads the resource bundle with a family name of
familyName using the specified locale and the specified
class loader. Throws MissingResourceException if no
resource bundle matching the family name specified by
familyName is available.
static final ResourceBundle
getBundle(String familyName,
ResourceBundle.Control cntl) Loads the resource bundle with a family name of
familyName using the default locale and the default class
loader. The loading process is under the control of cntl.
Throws MissingResourceException if no resource bundle
matching the family name specified by familyName is
available. (Added by Java SE 6.)
static final ResourceBundle
getBundle(String familyName,
Locale loc,
ResourceBundle.Control cntl) Loads the resource bundle with a family name of
familyName using the specified locale and the default
class loader. The loading process is under the control of
cntl. Throws MissingResourceException if no resource
bundle matching the family name specified by familyName
is available. (Added by Java SE 6.)
T ABLE 18-17
The Methods Defined by ResourceBundleChapter 18:
java.util Part 2: More Utility Classes
Method Description
static ResourceBundle
getBundle(String familyName,
Locale loc,
ClassLoader ldr,
ResourceBundle.Control cntl) Loads the resource bundle with a family name of
familyName using the specified locale and the specified
class loader. The loading process is under the control of
cntl. Throws MissingResourceException if no resource
bundle matching the family name specified by familyName
is available. (Added by Java SE 6.)
abstract Enumeration<String> getKeys( ) Returns the resource bundle keys as an enumeration of
strings. Any parent’s keys are also obtained.
Locale getLocale( ) Returns the locale supported by the resource bundle.
final Object getObject(String k) Returns the object associated with the key passed via k.
Throws MissingResourceException if k is not in the
resource bundle.
final String getString(String k) Returns the string associated with the key passed via k.
Throws MissingResourceException if k is not in the
resource bundle. Throws ClassCastException if the
object associated with k is not a string.
final String[ ] getStringArray(String k) Returns the string array associated with the key passed
via k. Throws MissingResourceException if k is not in the
resource bundle. Throws ClassCastException if the
object associated with k is not a string array.
protected abstract Object
handleGetObject(String k) Returns the object associated with the key passed via k.
Returns null if k is not in the resource bundle.
protected Set<String> handleKeySet( ) Returns the resource bundle keys as a set of strings. No
parent’s keys are obtained. Also, keys with null values
are not obtained. (Added by Java SE 6.)
Set<String> keySet( ) Returns the resource bundle keys as a set of strings. Any
parent keys are also obtained. (Added by Java SE 6.)
protected void
setParent(ResourceBundle parent) Sets parent as the parent bundle for the resource bundle.
When a key is looked up, the parent will be searched if
the key is not found in the invoking resource object.
T ABLE 18-17
The Methods Defined by ResourceBundle (continued)
its own. The second is the abstract class ListResourceBundle, which manages resources in
an array of key/value pairs. ListResourceBundle adds the method getContents( ), which
all subclasses must implement. It is shown here:
protected abstract Object[ ][ ] getContents( )
It returns a two-dimensional array that contains key/value pairs that represent resources.
The keys must be strings. The values are typically strings, but can be other types of objects.
Here is an example that demonstrates using a resource bundle. The resource bundle
has the family name SampleRB. Two resource bundle classes of this family are created by
extending ListResourceBundle. The first is called SampleRB, and it is the default bundle
(which uses English). It is shown here:
import java.util.*;
551552
Part II:
The Java Library
public class SampleRB extends ListResourceBundle 
The second resource bundle, shown next, is called SampleRB_de. It contains the
German translation.
import java.util.*;
// German version.
public class SampleRB_de extends ListResourceBundle 
The following program demonstrates these two resource bundles by displaying the string
associated with each key for both the default (English) version and the German version:
// Demonstrate a resource bundle.
import java.util.*;
class LRBDemo 
The output from the program is shown here:
English version:
String for Title key : My Program
String for StopText key: Stop
String for StartText key: Start
German
String
String
String
version:
for Title key : Mein Programm
for StopText key: Anschlag
for StartText key: Anfang
Miscellaneous Utility Classes and Interfaces
In addition to the classes already discussed, java.util includes the following classes:
EventListenerProxy Extends the EventListener class to allow additional parameters. See Chapter 22 for a
discussion of event listeners.
EventObject The superclass for all event classes. Events are discussed in Chapter 22.
FormattableFlags Defines formatting flags that are used with the Formattable interface.
PropertyPermission Manages property permissions.
ServiceLoader Provides a means of finding service providers. (Added by Java SE 6.)
UUID Encapsulates and manages Universally Unique Identifiers (UUIDs).
The following interfaces are also packaged in java.util:
EventListener Indicates that a class is an event listener. Events are discussed in Chapter 22.
Formattable Enables a class to provide custom formatting.
553554
Part II:
The Java Library
The java.util Subpackages
Java defines the following subpackages to java.util:
• java.util.concurrent
• java.util.concurrent.atomic
• java.util.concurrent.locks
• java.util.jar
• java.util.logging
• java.util.prefs
• java.util.regex
• java.util.spi
• java.util.zip
Each is briefly examined here.
java.util.concurrent, java.util.concurrent.atomic, and java.util.concurrent.locks
The java.util.concurrent package along with its two subpackages, java.util.concurrent.atomic
and java.util.concurrent.locks, support concurrent programming. These packages provide
a high-performance alternative to using Java’s built-in synchronization features when
thread-safe operation is required. These packages are examined in detail in Chapter 26.
java.util.jar
The java.util.jar package provides the ability to read and write Java Archive (JAR) files.
java.util.logging
The java.util.logging package provides support for program activity logs, which can be
used to record program actions, and to help find and debug problems.
java.util.prefs
The java.util.prefs package provides support for user preferences. It is typically used to
support program configuration.
java.util.regex
The java.util.regex package provides support for regular expression handling. It is described
in detail in Chapter 27.
java.util.spi
The java.util.spi package provides support for service providers. (Added by Java SE 6.)
java.util.zip
The java.util.zip package provides the ability to read and write files in the popular ZIP
and GZIP formats. Both ZIP and GZIP input and output streams are available.19
Input/Output:
Exploring java.io
T
his chapter explores java.io, which provides support for I/O operations. In Chapter 13,
we presented an overview of Java’s I/O system. Here, we will examine the Java I/O
system in greater detail.
As all programmers learn early on, most programs cannot accomplish their goals without
accessing external data. Data is retrieved from an input source. The results of a program are
sent to an output destination. In Java, these sources or destinations are defined very broadly.
For example, a network connection, memory buffer, or disk file can be manipulated by the
Java I/O classes. Although physically different, these devices are all handled by the same
abstraction: the stream. A stream, as explained in Chapter 13, is a logical entity that either
produces or consumes information. A stream is linked to a physical device by the Java I/O
system. All streams behave in the same manner, even if the actual physical devices they are
linked to differ.
N OTE In addition to the I/O capabilities discussed here, Java provides further I/O support in the
java.nio package, which is described in Chapter 27.
The Java I/O Classes and Interfaces
The I/O classes defined by java.io are listed here:
BufferedInputStream FileWriter PipedOutputStream
BufferedOutputStream FilterInputStream PipedReader
BufferedReader FilterOutputStream PipedWriter
BufferedWriter FilterReader PrintStream
ByteArrayInputStream FilterWriter PrintWriter
ByteArrayOutputStream InputStream PushbackInputStream
CharArrayReader InputStreamReader PushbackReader
CharArrayWriter LineNumberReader RandomAccessFile
555556
Part II:
The Java Library
Console ObjectInputStream Reader
DataInputStream ObjectInputStream.GetField SequenceInputStream
DataOutputStream ObjectOutputStream SerializablePermission
File ObjectOutputStream.PutField StreamTokenizer
FileDescriptor ObjectStreamClass StringReader
FileInputStream ObjectStreamField StringWriter
FileOutputStream OutputStream Writer
FilePermission OutputStreamWriter FileReader PipedInputStream
Console was added by Java SE 6.
The java.io package also contains two deprecated classes that are not shown in the
preceding table: LineNumberInputStream and StringBufferInputStream. These classes
should not be used for new code.
The following interfaces are defined by java.io:
Closeable FileFilter ObjectInputValidation
DataInput FilenameFilter ObjectOutput
DataOutput Flushable ObjectStreamConstants
Externalizable ObjectInput Serializable
As you can see, there are many classes and interfaces in the java.io package. These include
byte and character streams, and object serialization (the storage and retrieval of objects). This
chapter examines several of the most commonly used I/O components. The new Console class
is also examined. We begin our discussion with one of the most distinctive I/O classes: File.
File
Although most of the classes defined by java.io operate on streams, the File class does not.
It deals directly with files and the file system. That is, the File class does not specify how
information is retrieved from or stored in files; it describes the properties of a file itself. A
File object is used to obtain or manipulate the information associated with a disk file, such
as the permissions, time, date, and directory path, and to navigate subdirectory hierarchies.
Files are a primary source and destination for data within many programs. Although
there are severe restrictions on their use within applets for security reasons, files are still a
central resource for storing persistent and shared information. A directory in Java is treated
simply as a File with one additional property—a list of filenames that can be examined by
the list( ) method.
The following constructors can be used to create File objects:
File(String directoryPath)
File(String directoryPath, String filename)
File(File dirObj, String filename)
File(URI uriObj)Chapter 19:
Input/Output: Exploring java.io
Here, directoryPath is the path name of the file, filename is the name of the file or subdirectory,
dirObj is a File object that specifies a directory, and uriObj is a URI object that describes
a file.
The following example creates three files: f1, f2, and f3. The first File object is constructed
with a directory path as the only argument. The second includes two arguments—the path
and the filename. The third includes the file path assigned to f1 and a filename; f3 refers to the
same file as f2.
File f1 = new File("/");
File f2 = new File("/","autoexec.bat");
File f3 = new File(f1,"autoexec.bat");
N OTE Java does the right thing with path separators between UNIX and Windows conventions.
If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly.
Remember, if you are using the Windows convention of a backslash character (\), you will need
to use its escape sequence (\\) within a string.
File defines many methods that obtain the standard properties of a File object. For example,
getName( ) returns the name of the file, getParent( ) returns the name of the parent directory,
and exists( ) returns true if the file exists, false if it does not. The File class, however, is not
symmetrical. By this, we mean that there are a few methods that allow you to examine the
properties of a simple file object, but no corresponding function exists to change those attributes.
The following example demonstrates several of the File methods:
// Demonstrate File.
import java.io.File;
class FileDemo 
557558
Part II:
The Java Library
When you run this program, you will see something similar to the following:
File Name: COPYRIGHT
Path: /java/COPYRIGHT
Abs Path: /java/COPYRIGHT
Parent: /java
exists
is writeable
is readable
is not a directory
is normal file
is absolute
File last modified: 812465204000
File size: 695 Bytes
Most of the File methods are self-explanatory. isFile( ) and isAbsolute( ) are not. isFile( )
returns true if called on a file and false if called on a directory. Also, isFile( ) returns false
for some special files, such as device drivers and named pipes, so this method can be used
to make sure the file will behave as a file. The isAbsolute( ) method returns true if the file
has an absolute path and false if its path is relative.
File also includes two useful utility methods. The first is renameTo( ), shown here:
boolean renameTo(File newName)
Here, the filename specified by newName becomes the new name of the invoking File object.
It will return true upon success and false if the file cannot be renamed (if you either attempt
to rename a file so that it moves from one directory to another or use an existing filename,
for example).
The second utility method is delete( ), which deletes the disk file represented by the path
of the invoking File object. It is shown here:
boolean delete( )
You can also use delete( ) to delete a directory if the directory is empty. delete( ) returns true
if it deletes the file and false if the file cannot be removed.
Here are some other File methods that you will find helpful.
Method Description
void deleteOnExit( ) Removes the file associated with the invoking object when
the Java Virtual Machine terminates.
long getFreeSpace( ) Returns the number of free bytes of storage available on
the partition associated with the invoking object. (Added
by Java SE 6.)
long getTotalSpace( ) Returns the storage capacity of the partition associated
with the invoking object. (Added by Java SE 6.)
long getUsableSpace( ) Returns the number of usable free bytes of storage
available on the partition associated with the invoking
object. (Added by Java SE 6.)Chapter 19:
Input/Output: Exploring java.io
Method Description
boolean isHidden( ) Returns true if the invoking file is hidden. Returns false
otherwise.
boolean setLastModified(long millisec) Sets the time stamp on the invoking file to that specified
by millisec, which is the number of milliseconds from
January 1, 1970, Coordinated Universal Time (UTC).
boolean setReadOnly( )
Sets the invoking file to read-only.
Methods also exist to mark files as readable, writable, and executable. Because File
implements the Comparable interface, the method compareTo( ) is also supported.
Directories
A directory is a File that contains a list of other files and directories. When you create a File
object and it is a directory, the isDirectory( ) method will return true. In this case, you can
call list( ) on that object to extract the list of other files and directories inside. It has two forms.
The first is shown here:
String[ ] list( )
The list of files is returned in an array of String objects.
The program shown here illustrates how to use list( ) to examine the contents of a directory:
// Using directories.
import java.io.File;
class DirList 
559560
Part II:
The Java Library
Here is sample output from the program. (Of course, the output you see will be different,
based on what is in the directory.)
Directory of /java
bin is a directory
lib is a directory
demo is a directory
COPYRIGHT is a file
README is a file
index.html is a file
include is a directory
src.zip is a file
src is a directory
Using FilenameFilter
You will often want to limit the number of files returned by the list( ) method to include
only those files that match a certain filename pattern, or filter. To do this, you must use a
second form of list( ), shown here:
String[ ] list(FilenameFilter FFObj)
In this form, FFObj is an object of a class that implements the FilenameFilter interface.
FilenameFilter defines only a single method, accept( ), which is called once for each file
in a list. Its general form is given here:
boolean accept(File directory, String filename)
The accept( ) method returns true for files in the directory specified by directory that should
be included in the list (that is, those that match the filename argument), and returns false for
those files that should be excluded.
The OnlyExt class, shown next, implements FilenameFilter. It will be used to modify
the preceding program so that it restricts the visibility of the filenames returned by list( )
to files with names that end in the file extension specified when the object is constructed.
import java.io.*;
public class OnlyExt implements FilenameFilter 
The modified directory listing program is shown here. Now it will only display files that use
the .html extension.Chapter 19:
Input/Output: Exploring java.io
// Directory of .HTML files.
import java.io.*;
class DirListOnly 
The listFiles( ) Alternative
There is a variation to the list( ) method, called listFiles( ), which you might find useful.
The signatures for listFiles( ) are shown here:
File[ ] listFiles( )
File[ ] listFiles(FilenameFilter FFObj)
File[ ] listFiles(FileFilter FObj)
These methods return the file list as an array of File objects instead of strings. The first method
returns all files, and the second returns those files that satisfy the specified FilenameFilter.
Aside from returning an array of File objects, these two versions of listFiles( ) work like their
equivalent list( ) methods.
The third version of listFiles( ) returns those files with path names that satisfy the specified
FileFilter. FileFilter defines only a single method, accept( ), which is called once for each file in a
list. Its general form is given here:
boolean accept(File path)
The accept( ) method returns true for files that should be included in the list (that is, those
that match the path argument), and false for those that should be excluded.
Creating Directories
Another two useful File utility methods are mkdir( ) and mkdirs( ). The mkdir( ) method
creates a directory, returning true on success and false on failure. Failure indicates that the
path specified in the File object already exists, or that the directory cannot be created because
the entire path does not exist yet. To create a directory for which no path exists, use the mkdirs( )
method. It creates both a directory and all the parents of the directory.
The Closeable and Flushable Interfaces
Recently (with the release of JDK 5), two interfaces were added to java.io: Closeable and
Flushable. The interfaces are implemented by several of the I/O classes. Their inclusion
does not add new functionality to the stream classes. They simply offer a uniform way of
specifying that a stream can be closed or flushed.
561562
Part II:
The Java Library
Objects of a class that implements Closeable can be closed. It defines the close( ) method,
shown here:
void close( ) throws IOException
This method closes the invoking stream, releasing any resources that it may hold. This
interface is implemented by all of the I/O classes that open a stream that can be closed.
Objects of a class that implements Flushable can force buffered output to be written
to the stream to which the object is attached. It defines the flush( ) method, shown here:
void flush( ) throws IOException
Flushing a stream typically causes buffered output to be physically written to the underlying
device. This interface is implemented by all of the I/O classes that write to a stream.
The Stream Classes
Java’s stream-based I/O is built upon four abstract classes: InputStream, OutputStream,
Reader, and Writer. These classes were briefly discussed in Chapter 13. They are used to
create several concrete stream subclasses. Although your programs perform their I/O
operations through concrete subclasses, the top-level classes define the basic functionality
common to all stream classes.
InputStream and OutputStream are designed for byte streams. Reader and Writer are
designed for character streams. The byte stream classes and the character stream classes
form separate hierarchies. In general, you should use the character stream classes when
working with characters or strings, and use the byte stream classes when working with
bytes or other binary objects.
In the remainder of this chapter, both the byte- and character-oriented streams are
examined.
The Byte Streams
The byte stream classes provide a rich environment for handling byte-oriented I/O. A byte
stream can be used with any type of object, including binary data. This versatility makes
byte streams important to many types of programs. Since the byte stream classes are topped
by InputStream and OutputStream, our discussion will begin with them.
InputStream
InputStream is an abstract class that defines Java’s model of streaming byte input. It implements
the Closeable interface. Most of the methods in this class will throw an IOException on error
conditions. (The exceptions are mark( ) and markSupported( ).) Table 19-1 shows the methods
in InputStream.
OutputStream
OutputStream is an abstract class that defines streaming byte output. It implements the
Closeable and Flushable interfaces. Most of the methods in this class return void and throw
an IOException in the case of errors. (The exceptions are mark( ) and markSupported( ).)
Table 19-2 shows the methods in OutputStream.Chapter 19:
Input/Output: Exploring java.io
Method Description
int available( ) Returns the number of bytes of input currently available for
reading.
void close( ) Closes the input source. Further read attempts will generate
an IOException.
void mark(int numBytes) Places a mark at the current point in the input stream that will
remain valid until numBytes bytes are read.
boolean markSupported( ) Returns true if mark( )/reset( ) are supported by the invoking
stream.
int read( ) Returns an integer representation of the next available byte of
input. –1 is returned when the end of the file is encountered.
int read(byte buffer[ ]) Attempts to read up to buffer.length bytes into buffer and
returns the actual number of bytes that were successfully
read. –1 is returned when the end of the file is encountered.
int read(byte buffer[ ], int offset, Attempts to read up to numBytes bytes into buffer starting at
int numBytes)
buffer[offset], returning the number of bytes successfully
read. –1 is returned when the end of the file is encountered.
void reset( ) Resets the input pointer to the previously set mark.
long skip(long numBytes) Ignores (that is, skips) numBytes bytes of input, returning the
number of bytes actually ignored.
T ABLE 19-1
The Methods Defined by InputStream
N OTE Most of the methods described in Tables 19-1 and 19-2 are implemented by the subclasses of
InputStream and OutputStream. The mark( ) and reset( ) methods are exceptions; notice their
use or lack thereof by each subclass in the discussions that follow.
Method Description
void close( ) Closes the output stream. Further write attempts will
generate an IOException.
void flush( ) Finalizes the output state so that any buffers are cleared.
That is, it flushes the output buffers.
void write(int b) Writes a single byte to an output stream. Note that the
parameter is an int, which allows you to call write( ) with
expressions without having to cast them back to byte.
void write(byte buffer[ ]) Writes a complete array of bytes to an output stream.
void write(byte buffer[ ], int offset, Writes a subrange of numBytes bytes from the array buffer,
int numBytes)
beginning at buffer[offset].
T ABLE 19-2
The Methods Defined by OutputStream
563564
Part II:
The Java Library
FileInputStream
The FileInputStream class creates an InputStream that you can use to read bytes from a file.
Its two most common constructors are shown here:
FileInputStream(String filepath)
FileInputStream(File fileObj)
Either can throw a FileNotFoundException. Here, filepath is the full path name of a file, and
fileObj is a File object that describes the file.
The following example creates two FileInputStreams that use the same disk file and each
of the two constructors:
FileInputStream f0 = new FileInputStream("/autoexec.bat")
File f = new File("/autoexec.bat");
FileInputStream f1 = new FileInputStream(f);
Although the first constructor is probably more commonly used, the second allows us to
closely examine the file using the File methods, before we attach it to an input stream. When
a FileInputStream is created, it is also opened for reading. FileInputStream overrides six
of the methods in the abstract class InputStream. The mark( ) and reset( ) methods are not
overridden, and any attempt to use reset( ) on a FileInputStream will generate an IOException.
The next example shows how to read a single byte, an array of bytes, and a subrange
array of bytes. It also illustrates how to use available( ) to determine the number of bytes
remaining, and how to use the skip( ) method to skip over unwanted bytes. The program
reads its own source file, which must be in the current directory.
// Demonstrate FileInputStream.
import java.io.*;
class FileInputStreamDemo 
Here is the output produced by this program:
Total Available Bytes: 1433
First 35 bytes of the file one read() at a time
// Demonstrate FileInputStream.
im
Still Available: 1398
Reading the next 35 with one read(b[])
port java.io.*;
class FileInputS
Still Available: 1363
Skipping half of remaining bytes with skip()
Still Available: 682
Reading 17 into the end of array
port java.io.*;
read(b) != n) 
Here is how the program works. First, a file is opened by using the FileInputStream
constructor, and a reference to that object is assigned to fIn. Next, a channel connected to
the file is obtained by calling getChannel( ) on fIn, and the size of the file is obtained by
calling size( ). The program then calls the allocate( ) method of ByteBuffer to allocate a
buffer that will hold the contents of the file when it is read. A byte buffer is used because
FileChannel operates on bytes. A reference to this buffer is stored in mBuf. The contents
of the file are then read into mBuf through a call to read( ). Next, the buffer is rewound
through a call to rewind( ). This call is necessary because the current position is at the end
of the buffer after the call to read( ). It must be reset to the start of the buffer in order for the
bytes in mBuf to be read by calling get( ). Because mBuf is a byte buffer, the values returned
by get( ) are bytes. They are cast to char so that the file can be displayed as text. (Alternatively,
it is possible to create a buffer that encodes the bytes into characters, and then reads that buffer.)
The program ends by closing the channel and the file.Chapter 27:
NIO, Regular Expressions, and Other Packages
A second, and often easier, way to read a file is to map it to a buffer. The advantage to
this approach is that the buffer automatically contains the contents of the file. No explicit
read operation is necessary. To map and read the contents of a file, follow this general
procedure. First, open the file using FileInputStream. Next, obtain a channel to that file by
calling getChannel( ) on the file object. Then, map the channel to a buffer by calling map( )
on the FileChannel object. The map( ) method is shown here:
MappedByteBuffer map(FileChannel.MapMode how,
long pos, long size) throws IOException
The map( ) method causes the data in the file to be mapped into a buffer in memory. The
value in how determines what type of operations are allowed. It must be one of these values:
MapMode.READ_ONLY
MapMode.READ_WRITE
MapMode.PRIVATE
For reading a file, use MapMode.READ_ONLY. To read and write, use MapeMode.READ_
WRITE. MapMode.PRIVATE causes a private copy of the file to be made, and changes to
the buffer do not affect the underlying file. The location within the file to begin mapping
is specified by pos, and the number of bytes to map are specified by size. A reference to this
buffer is returned as a MappedByteBuffer, which is a subclass of ByteBuffer. Once the file
has been mapped to a buffer, you can read the file from that buffer.
The following program reworks the first example so that it uses a mapped file:
// Use
import
import
import
a mapped file to read a text file.
java.io.*;
java.nio.*;
java.nio.channels.*;
public class MappedChannelRead 
As before, the file is opened by using the FileInputStream constructor, and a reference
to that object is assigned to fIn. A channel connected to the file is obtained by calling
getChannel( ) on fIn, and the size of the file is obtained. Then the entire file is mapped into
memory by calling map( ), and a reference to the buffer is stored in mBuf. The bytes in mBuf
are read by calling get( ).
Writing to a File
There are several ways to write to a file through a channel. Again, we will look at two. First,
you can write data to an output file through a channel, by using explicit write operations.
Second, if the file is opened for read/write operations, you can map the file to a buffer and
then write to that buffer. Changes to the buffer will automatically be reflected in the file.
Both ways are described here.
To write to a file through a channel using explicit calls to write( ), follow these steps.
First, open the file for output. Next, allocate a byte buffer, put the data you want to write
into that buffer, and then call write( ) on the channel. The following program demonstrates
this procedure. It writes the alphabet to a file called test.txt.
// Write to a file using NIO.
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
public class ExplicitChannelWrite 
The call to rewind( ) on mBuf is necessary in order to reset the current position to zero after
data has been written to mBuf. Remember, each call to put( ) advances the current position.
Therefore, it is necessary for the current position to be reset to the start of the buffer before
calling write( ). If this is not done, write( ) will think that there is no data in the buffer.
To write to a file using a mapped file, follow these steps. First, open the file for read/write
operations. Next, map that file to a buffer by calling map( ). Then, write to the buffer. Because
the buffer is mapped to the file, any changes to that buffer are automatically reflected in the file.
Thus, no explicit write operations to the channel are necessary. Here is the preceding program
reworked so that a mapped file is used. Notice that the file is opened as a RandomAccessFile.
This is necessary to allow the file to be read and written.
// Write to a mapped file.
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
public class MappedChannelWrite 
As you can see, there are no explicit write operations to the channel itself. Because mBuf
is mapped to the file, changes to mBuf are automatically reflected in the underlying file.
Copying a File Using NIO
NIO simplifies some types of file operations. For example, the following program copies a
file. It does so by opening an input channel to the source file and an output channel to the
target file. It then writes the mapped input buffer to the output file in a single operation. You
might want to compare this version of the file copy program to the one found in Chapter 13.
As you will find, the part of the program that actually copies the file is substantially shorter.
// Copy a file using NIO.
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
public class NIOCopy 
Because the input file is mapped to mBuf, it contains the entire source file. Thus, the call to
write( ) copies all of mBuf to the target file. This, of course, means that the target file is an
identical copy of the source file.
Is NIO the Future of I/O Handling?
The NIO APIs offer an exciting new way to think about and handle some types of file
operations. Because of this, it is natural to ask the question, “Is NIO the future of I/O handling?”
Certainly, channels and buffers offer a clean way of thinking about I/O. However, they also
add another layer of abstraction. Furthermore, the traditional stream-based approach is
both well-understood and widely used. As explained at the outset, channel-based I/O is
currently designed to supplement, not replace, the standard I/O mechanisms defined in
java.io. In this role, the channel/buffer approach used by the NIO APIs succeeds admirably.
Whether the new approach will someday supplant the traditional approach, only time and
usage patterns will tell.
Regular Expression Processing
The java.util.regex package supports regular expression processing. As the term is used
here, a regular expression is a string of characters that describes a character sequence. This
general description, called a pattern, can then be used to find matches in other character
sequences. Regular expressions can specify wildcard characters, sets of characters, and
various quantifiers. Thus, you can specify a regular expression that represents a general
form that can match several different specific character sequences.
There are two classes that support regular expression processing: Pattern and Matcher.
These classes work together. Use Pattern to define a regular expression. Match the pattern
against another sequence using Matcher.
Pattern
The Pattern class defines no constructors. Instead, a pattern is created by calling the compile( )
factory method. One of its forms is shown here:
static Pattern compile(String pattern)
825826
Part II:
The Java Library
Here, pattern is the regular expression that you want to use. The compile( ) method transforms
the string in pattern into a pattern that can be used for pattern matching by the Matcher class.
It returns a Pattern object that contains the pattern.
Once you have created a Pattern object, you will use it to create a Matcher. This is done
by calling the matcher( ) factory method defined by Pattern. It is shown here:
Matcher matcher(CharSequence str)
Here str is the character sequence that the pattern will be matched against. This is called the
input sequence. CharSequence is an interface that defines a read-only set of characters. It is
implemented by the String class, among others. Thus, you can pass a string to matcher( ).
Matcher
The Matcher class has no constructors. Instead, you create a Matcher by calling the matcher( )
factory method defined by Pattern, as just explained. Once you have created a Matcher, you
will use its methods to perform various pattern matching operations.
The simplest pattern matching method is matches( ), which simply determines whether
the character sequence matches the pattern. It is shown here:
boolean matches( )
It returns true if the sequence and the pattern match, and false otherwise. Understand that
the entire sequence must match the pattern, not just a subsequence of it.
To determine if a subsequence of the input sequence matches the pattern, use find( ).
One version is shown here:
boolean find( )
It returns true if there is a matching subsequence and false otherwise. This method can be
called repeatedly, allowing it to find all matching subsequences. Each call to find( ) begins
where the previous one left off.
You can obtain a string containing the last matching sequence by calling group( ). One
of its forms is shown here:
String group( )
The matching string is returned. If no match exists, then an IllegalStateException is thrown.
You can obtain the index within the input sequence of the current match by calling
start( ). The index one past the end of the current match is obtained by calling end( ). These
methods are shown here:
int start( )
int end( )
Both throw IllegalStateException if no match exists.
You can replace all occurrences of a matching sequence with another sequence by
calling replaceAll( ), shown here:
String replaceAll(String newStr)Chapter 27:
NIO, Regular Expressions, and Other Packages
Here, newStr specifies the new character sequence that will replace the ones that match the
pattern. The updated input sequence is returned as a string.
Regular Expression Syntax
Before demonstrating Pattern and Matcher, it is necessary to explain how to construct a
regular expression. Although no rule is complicated by itself, there are a large number of
them, and a complete discussion is beyond the scope of this chapter. However, a few of the
more commonly used constructs are described here.
In general, a regular expression is comprised of normal characters, character classes
(sets of characters), wildcard characters, and quantifiers. A normal character is matched
as-is. Thus, if a pattern consists of “xy”, then the only input sequence that will match it is
“xy”. Characters such as newline and tab are specified using the standard escape sequences,
which begin with a \. For example, a newline is specified by \n. In the language of regular
expressions, a normal character is also called a literal.
A character class is a set of characters. A character class is specified by putting the
characters in the class between brackets. For example, the class [wxyz] matches w, x, y, or z.
To specify an inverted set, precede the characters with a ^. For example, [^wxyz] matches
any character except w, x, y, or z. You can specify a range of characters using a hyphen.
For example, to specify a character class that will match the digits 1 through 9, use [1-9].
The wildcard character is the . (dot) and it matches any character. Thus, a pattern that
consists of “.” will match these (and other) input sequences: “A”, “a”, “x”, and so on.
A quantifier determines how many times an expression is matched. The quantifiers are
shown here:
+ Match one or more.
* Match zero or more.
? Match zero or one.
For example, the pattern “x+” will match “x”, “xx”, and “xxx”, among others.
One other point: In general, if you specify an invalid expression, a PatternSyntaxException
will be thrown.
Demonstrating Pattern Matching
The best way to understand how regular expression pattern matching operates is to work
through some examples. The first, shown here, looks for a match with a literal pattern:
// A simple pattern matching demo.
import java.util.regex.*;
class RegExpr 
The output from the program is shown here:
Testing Java against Java.
Matches
Testing Java against Java SE 6.
No Match
Let’s look closely at this program. The program begins by creating the pattern that contains
the sequence “Java”. Next, a Matcher is created for that pattern that has the input sequence
“Java”. Then, the matches( ) method is called to determine if the input sequence matches
the pattern. Because the sequence and the pattern are the same, matches( ) returns true.
Next, a new Matcher is created with the input sequence “Java SE 6” and matches( ) is called
again. In this case, the pattern and the input sequence differ, and no match is found. Remember,
the matches( ) function returns true only when the input sequence precisely matches the
pattern. It will not return true just because a subsequence matches.
You can use find( ) to determine if the input sequence contains a subsequence that matches
the pattern. Consider the following program:
// Use find() to find a subsequence.
import java.util.regex.*;
class RegExpr2 Chapter 27:
NIO, Regular Expressions, and Other Packages
The output is shown here:
Looking for Java in Java SE 6.
subsequence found
In this case, find( ) finds the subsequence “Java”.
The find( ) method can be used to search the input sequence for repeated occurrences
of the pattern because each call to find( ) picks up where the previous one left off. For example,
the following program finds two occurrences of the pattern “test”:
// Use find() to find multiple subsequences.
import java.util.regex.*;
class RegExpr3 
The output is shown here:
test found at index 0
test found at index 11
As the output shows, two matches were found. The program uses the start( ) method to
obtain the index of each match.
Using Wildcards and Quantifiers
Although the preceding programs show the general technique for using Pattern and Matcher,
they don’t show their power. The real benefit of regular expression processing is not seen until
wildcards and quantifiers are used. To begin, consider the following example that uses the +
quantifier to match any arbitrarily long sequence of Ws.
// Use a quantifier.
import java.util.regex.*;
class RegExpr4 
829830
Part II:
The Java Library
The output from the program is shown here:
Match: W
Match: WW
Match: WWW
As the output shows, the regular expression pattern “W+” matches any arbitrarily long
sequence of Ws.
The next program uses a wildcard to create a pattern that will match any sequence that
begins with e and ends with d. To do this, it uses the dot wildcard character along with the +
quantifier.
// Use wildcard and quantifier.
import java.util.regex.*;
class RegExpr5 
You might be surprised by the output produced by the program, which is shown here:
Match: extend cup end
Only one match is found, and it is the longest sequence that begins with e and ends with d.
You might have expected two matches: “extend” and “end”. The reason that the longer
sequence is found is that by default, find( ) matches the longest sequence that fits the
pattern. This is called greedy behavior. You can specify reluctant behavior by adding the ?
quantifier to the pattern, as shown in this version of the program. It causes the shortest
matching pattern to be obtained.
// Use the ? quantifier.
import java.util.regex.*;
class RegExpr6 
The output from the program is shown here:
Match: extend
Match: endChapter 27:
NIO, Regular Expressions, and Other Packages
As the output shows, the pattern “e.+?d” will match the shortest sequence that begins with
e and ends with d. Thus, two matches are found.
Working with Classes of Characters
Sometimes you will want to match any sequence that contains one or more characters, in
any order, that are part of a set of characters. For example, to match whole words, you want
to match any sequence of the letters of the alphabet. One of the easiest ways to do this is to
use a character class, which defines a set of characters. Recall that a character class is created
by putting the characters you want to match between brackets. For example, to match the
lowercase characters a through z, use [a-z]. The following program demonstrates this technique:
// Use a character class.
import java.util.regex.*;
class RegExpr7 
The output is shown here:
Match:
Match:
Match:
Match:
this
is
a
test
Using replaceAll( )
The replaceAll( ) method supplied by Matcher lets you perform powerful search and replace
operations that use regular expressions. For example, the following program replaces all
occurrences of sequences that begin with “Jon” with “Eric”:
// Use replaceAll().
import java.util.regex.*;
class RegExpr8 
The output is shown here:
Original sequence: Jon Jonathan Frank Ken Todd
Modified sequence: Eric Eric Frank Ken Todd
Because the regular expression “Jon.*? “ matches any string that begins with Jon followed
by zero or more characters, ending in a space, it can be used to match and replace both Jon
and Jonathan with the name Eric. Such a substitution is not possible without pattern matching
capabilities.
Using split( )
You can reduce an input sequence into its individual tokens by using the split( ) method
defined by Pattern. One form of the split( ) method is shown here:
String[ ] split(CharSequence str)
It processes the input sequence passed in str, reducing it into tokens based on the delimiters
specified by the pattern.
For example, the following program finds tokens that are separated by spaces, commas,
periods, and exclamation points:
// Use split().
import java.util.regex.*;
class RegExpr9 
The output is shown here:
Next
Next
Next
Next
Next
token:
token:
token:
token:
token:
one
two
alpha9
12
done
As the output shows, the input sequence is reduced to its individual tokens. Notice that the
delimiters are not included.Chapter 27:
NIO, Regular Expressions, and Other Packages
Two Pattern-Matching Options
Although the pattern-matching techniques described in the foregoing offer the greatest
flexibility and power, there are two alternatives which you might find useful in some
circumstances. If you only need to perform a one-time pattern match, you can use the
matches( ) method defined by Pattern. It is shown here:
static boolean matches(String pattern, CharSequence str)
It returns true if pattern matches str and false otherwise. This method automatically compiles
pattern and then looks for a match. If you will be using the same pattern repeatedly, then
using matches( ) is less efficient than compiling the pattern and using the pattern-matching
methods defined by Matcher, as described previously.
You can also perform a pattern match by using the matches( ) method implemented by
String. It is shown here:
boolean matches(String pattern)
If the invoking string matches the regular expression in pattern, then matches( ) returns true.
Otherwise, it returns false.
Exploring Regular Expressions
The overview of regular expressions presented in this section only hints at their power. Since
text parsing, manipulation, and tokenization are a large part of programming, you will likely
find Java’s regular expression subsystem a powerful tool that you can use to your advantage.
It is, therefore, wise to explore the capabilities of regular expressions. Experiment with several
different types of patterns and input sequences. Once you understand how regular expression
pattern matching works, you will find it useful in many of your programming endeavors.
Reflection
Reflection is the ability of software to analyze itself. This is provided by the java.lang.reflect
package and elements in Class. Reflection is an important capability, especially when using
components called Java Beans. It allows you to analyze a software component and describe
its capabilities dynamically, at run time rather than at compile time. For example, by using
reflection, you can determine what methods, constructors, and fields a class supports. Reflection
was introduced in Chapter 12. It is examined further here.
The package java.lang.reflect includes several interfaces. Of special interest is Member,
which defines methods that allow you to get information about a field, constructor, or
method of a class. There are also eight classes in this package. These are listed in Table 27-4.
The following application illustrates a simple use of the Java reflection capabilities. It
prints the constructors, fields, and methods of the class java.awt.Dimension. The program
begins by using the forName( ) method of Class to get a class object for java.awt.Dimension.
Once this is obtained, getConstructors( ), getFields( ), and getMethods( ) are used to analyze
this class object. They return arrays of Constructor, Field, and Method objects that provide
the information about the object. The Constructor, Field, and Method classes define
833834
Part II:
The Java Library
Class Primary Function
AccessibleObject Allows you to bypass the default access control checks.
Array Allows you to dynamically create and manipulate arrays.
Constructor Provides information about a constructor.
Field Provides information about a field.
Method Provides information about a method.
Modifier Provides information about class and member access modifiers.
Proxy Supports dynamic proxy classes.
ReflectPermission Allows reflection of private or protected members of a class.
T ABLE 27-4
Classes Defined in java.lang.reflect
several methods that can be used to obtain information about an object. You will want to
explore these on your own. However, each supports the toString( ) method. Therefore,
using Constructor, Field, and Method objects as arguments to the println( ) method is
straightforward, as shown in the program.
// Demonstrate reflection.
import java.lang.reflect.*;
public class ReflectionDemo1 Chapter 27:
NIO, Regular Expressions, and Other Packages
Here is the output from this program. (The precise order may differ slightly from that shown.)
Constructors:
public java.awt.Dimension(int,int)
public java.awt.Dimension()
public java.awt.Dimension(java.awt.Dimension)
Fields:
public int java.awt.Dimension.width
public int java.awt.Dimension.height
Methods:
public int java.awt.Dimension.hashCode()
public boolean java.awt.Dimension.equals(java.lang.Object)
public java.lang.String java.awt.Dimension.toString()
public java.awt.Dimension java.awt.Dimension.getSize()
public void java.awt.Dimension.setSize(double,double)
public void java.awt.Dimension.setSize(java.awt.Dimension)
public void java.awt.Dimension.setSize(int,int)
public double java.awt.Dimension.getHeight()
public double java.awt.Dimension.getWidth()
public java.lang.Object java.awt.geom.Dimension2D.clone()
public void java.awt.geom.
Dimension2D.setSize(java.awt.geom.Dimension2D)
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.wait(long)
throws java.lang.InterruptedException
public final void java.lang.Object.wait()
throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int)
throws java.lang.InterruptedException
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
The next example uses Java’s reflection capabilities to obtain the public methods of a
class. The program begins by instantiating class A. The getClass( ) method is applied to
this object reference, and it returns the Class object for class A. The getDeclaredMethods( )
method returns an array of Method objects that describe only the methods declared by
this class. Methods inherited from superclasses such as Object are not included.
Each element of the methods array is then processed. The getModifiers( ) method returns
an int containing flags that describe which modifiers apply for this element. The Modifier
class provides a set of methods, shown in Table 27-5, that can be used to examine this value.
For example, the static method isPublic( ) returns true if its argument includes the public
modifier. Otherwise, it returns false. In the following program, if the method supports
public access, its name is obtained by the getName( ) method and is then printed.
// Show public methods.
import java.lang.reflect.*;
public class ReflectionDemo2 
class A 
Here is the output from this program:
Public Methods:
a1
a2
Method
Description
static boolean isAbstract(int val) Returns true if val has the abstract flag set and false otherwise.
static boolean isFinal(int val) Returns true if val has the final flag set and false otherwise.
static boolean isInterface(int val) Returns true if val has the interface flag set and false otherwise.
static boolean isNative(int val) Returns true if val has the native flag set and false otherwise.
static boolean isPrivate(int val) Returns true if val has the private flag set and false otherwise.
static boolean isProtected(int val) Returns true if val has the protected flag set and false otherwise.
static boolean isPublic(int val) Returns true if val has the public flag set and false otherwise.
static boolean isStatic(int val) Returns true if val has the static flag set and false otherwise.
static boolean isStrict(int val) Returns true if val has the strict flag set and false otherwise.
static boolean isSynchronized(int val) Returns true if val has the synchronized flag set and false otherwise.
static boolean isTransient(int val) Returns true if val has the transient flag set and false otherwise.
static boolean isVolatile(int val) Returns true if val has the volatile flag set and false otherwise.
T ABLE 27-5
Methods Defined by Modifier That Determine ModifiersChapter 27:
NIO, Regular Expressions, and Other Packages
Remote Method Invocation (RMI)
Remote Method Invocation (RMI) allows a Java object that executes on one machine to invoke
a method of a Java object that executes on another machine. This is an important feature,
because it allows you to build distributed applications. While a complete discussion of RMI is
outside the scope of this book, the following example describes the basic principles involved.
A Simple Client/Server Application Using RMI
This section provides step-by-step directions for building a simple client/server application
by using RMI. The server receives a request from a client, processes it, and returns a result.
In this example, the request specifies two numbers. The server adds these together and
returns the sum.
Step One: Enter and Compile the Source Code
This application uses four source files. The first file, AddServerIntf.java, defines the remote
interface that is provided by the server. It contains one method that accepts two double
arguments and returns their sum. All remote interfaces must extend the Remote interface,
which is part of java.rmi. Remote defines no members. Its purpose is simply to indicate that
an interface uses remote methods. All remote methods can throw a RemoteException.
import java.rmi.*;
public interface AddServerIntf extends Remote 
The second source file, AddServerImpl.java, implements the remote interface. The
implementation of the add( ) method is straightforward. All remote objects must extend
UnicastRemoteObject, which provides functionality that is needed to make objects
available from remote machines.
import java.rmi.*;
import java.rmi.server.*;
public class AddServerImpl extends UnicastRemoteObject
implements AddServerIntf 
The third source file, AddServer.java, contains the main program for the server machine.
Its primary function is to update the RMI registry on that machine. This is done by using the
rebind( ) method of the Naming class (found in java.rmi). That method associates a name
with an object reference. The first argument to the rebind( ) method is a string that names the
server as “AddServer”. Its second argument is a reference to an instance of AddServerImpl.
import java.net.*;
import java.rmi.*;
public class AddServer 
The fourth source file, AddClient.java, implements the client side of this distributed
application. AddClient.java requires three command-line arguments. The first is the IP
address or name of the server machine. The second and third arguments are the two numbers
that are to be summed.
The application begins by forming a string that follows the URL syntax. This URL uses
the rmi protocol. The string includes the IP address or name of the server and the string
“AddServer”. The program then invokes the lookup( ) method of the Naming class. This
method accepts one argument, the rmi URL, and returns a reference to an object of type
AddServerIntf. All remote method invocations can then be directed to this object.
The program continues by displaying its arguments and then invokes the remote add( )
method. The sum is returned from this method and is then printed.
import java.rmi.*;
public class AddClient 
After you enter all the code, use javac to compile the four source files that you created.
Step Two: Generate a Stub
Before you can use the client and server, you must generate the necessary stub. In the context
of RMI, a stub is a Java object that resides on the client machine. Its function is to present the
same interfaces as the remote server. Remote method calls initiated by the client are actually
directed to the stub. The stub works with the other parts of the RMI system to formulate a
request that is sent to the remote machine.
A remote method may accept arguments that are simple types or objects. In the latter
case, the object may have references to other objects. All of this information must be sent toChapter 27:
NIO, Regular Expressions, and Other Packages
the remote machine. That is, an object passed as an argument to a remote method call must
be serialized and sent to the remote machine. Recall from Chapter 19 that the serialization
facilities also recursively process all referenced objects.
If a response must be returned to the client, the process works in reverse. Note that the
serialization and deserialization facilities are also used if objects are returned to a client.
To generate a stub, you use a tool called the RMI compiler, which is invoked from the
command line, as shown here:
rmic AddServerImpl
This command generates the file AddServerImpl_Stub.class. When using rmic, be sure that
CLASSPATH is set to include the current directory.
Step Three: Install Files on the Client and Server Machines
Copy AddClient.class, AddServerImpl_Stub.class, and AddServerIntf.class to a directory
on the client machine. Copy AddServerIntf.class, AddServerImpl.class, AddServerImpl_
Stub.class, and AddServer.class to a directory on the server machine.
N OTE RMI has techniques for dynamic class loading, but they are not used by the example at
hand. Instead, all of the files that are used by the client and server applications must be installed
manually on those machines.
Step Four: Start the RMI Registry on the Server Machine
Java SE 6 provides a program called rmiregistry, which executes on the server machine. It
maps names to object references. First, check that the CLASSPATH environment variable
includes the directory in which your files are located. Then, start the RMI Registry from the
command line, as shown here:
start rmiregistry
When this command returns, you should see that a new window has been created. You
need to leave this window open until you are done experimenting with the RMI example.
Step Five: Start the Server
The server code is started from the command line, as shown here:
java AddServer
Recall that the AddServer code instantiates AddServerImpl and registers that object with
the name “AddServer”.
Step Six: Start the Client
The AddClient software requires three arguments: the name or IP address of the server
machine and the two numbers that are to be summed together. You may invoke it from
the command line by using one of the two formats shown here:
java AddClient server1 8 9
java AddClient 11.12.13.14 8 9
In the first line, the name of the server is provided. The second line uses its IP address
(11.12.13.14).
839840
Part II:
The Java Library
You can try this example without actually having a remote server. To do so, simply
install all of the programs on the same machine, start rmiregistry, start AddServer, and
then execute AddClient using this command line:
java AddClient 127.0.0.1 8 9
Here, the address 127.0.0.1 is the “loop back” address for the local machine. Using this
address allows you to exercise the entire RMI mechanism without actually having to install
the server on a remote computer.
In either case, sample output from this program is shown here:
The first number is: 8
The second number is: 9
The sum is: 17.0
Text Formatting
The package java.text allows you to format, search, and manipulate text. Chapter 32 illustrates
its NumberFormat class, which is used to format numeric data. This section examines two
more of its most commonly used classes: those that format date and time information.
DateFormat Class
DateFormat is an abstract class that provides the ability to format and parse dates and
times. The getDateInstance( ) method returns an instance of DateFormat that can format
date information. It is available in these forms:
static final DateFormat getDateInstance( )
static final DateFormat getDateInstance(int style)
static final DateFormat getDateInstance(int style, Locale locale)
The argument style is one of the following values: DEFAULT, SHORT, MEDIUM, LONG,
or FULL. These are int constants defined by DateFormat. They cause different details about
the date to be presented. The argument locale is one of the static references defined by Locale
(refer to Chapter 18 for details). If the style and/or locale is not specified, defaults are used.
One of the most commonly used methods in this class is format( ). It has several
overloaded forms, one of which is shown here:
final String format(Date d)
The argument is a Date object that is to be displayed. The method returns a string containing
the formatted information.
The following listing illustrates how to format date information. It begins by creating
a Date object. This captures the current date and time information. Then it outputs the date
information by using different styles and locales.
// Demonstrate date formats.
import java.text.*;
import java.util.*;
public class DateFormatDemo 
Sample output from this program is shown here:
Japan: 06/07/12
Korea: 2006. 7. 12
United Kingdom: 12 July 2006
United States: Wednesday, July 12, 2006
The getTimeInstance( ) method returns an instance of DateFormat that can format time
information. It is available in these versions:
static final DateFormat getTimeInstance( )
static final DateFormat getTimeInstance(int style)
static final DateFormat getTimeInstance(int style, Locale locale)
The argument style is one of the following values: DEFAULT, SHORT, MEDIUM, LONG,
or FULL. These are int constants defined by DateFormat. They cause different details about
the time to be presented. The argument locale is one of the static references defined by Locale.
If the style and/or locale is not specified, defaults are used.
The following listing illustrates how to format time information. It begins by creating a
Date object. This captures the current date and time information and then outputs the time
information by using different styles and locales.
// Demonstrate time formats.
import java.text.*;
import java.util.*;
public class TimeFormatDemo 
Sample output from this program is shown here:
Japan: 20:25
United Kingdom: 20:25:14 CDT
Canada: 8:25:14 o’clock PM CDT
The DateFormat class also has a getDateTimeInstance( ) method that can format both
date and time information. You may wish to experiment with it on your own.
SimpleDateFormat Class
SimpleDateFormat is a concrete subclass of DateFormat. It allows you to define your own
formatting patterns that are used to display date and time information.
One of its constructors is shown here:
SimpleDateFormat(String formatString)
The argument formatString describes how date and time information is displayed. An example
of its use is given here:
SimpleDateFormat sdf = SimpleDateFormat("dd MMM yyyy hh:mm:ss zzz");
The symbols used in the formatting string determine the information that is displayed.
Table 27-6 lists these symbols and gives a description of each.
In most cases, the number of times a symbol is repeated determines how that data is
presented. Text information is displayed in an abbreviated form if the pattern letter is repeated
less than four times. Otherwise, the unabbreviated form is used. For example, a zzzz pattern
can display Pacific Daylight Time, and a zzz pattern can display PDT.
For numbers, the number of times a pattern letter is repeated determines how many digits
are presented. For example, hh:mm:ss can present 01:51:15, but h:m:s displays the same time
value as 1:51:15.
Finally, M or MM causes the month to be displayed as one or two digits. However, three
or more repetitions of M cause the month to be displayed as a text string.
The following program shows how this class is used:
// Demonstrate SimpleDateFormat.
import java.text.*;
import java.util.*;
public class SimpleDateFormatDemo 
Sample output from this program is shown here:
10:25:03
12 Jul 2006 10:25:03 CDT
Wed Jul 12 2006
T ABLE 27-6
Formatting String
Symbols for
SimpleDateFormat
Symbol Description
a AM
d Day of month (1–31)
h Hour in AM / PM (1–12)
k Hour in day (1–24)
m Minute in hour (0–59)
s Second in minute (0–59)
w Week of year (1–52)
y Year
z Time zone
D Day of year (1–366)
E Day of week (for example, Thursday)
F Day of week in month
G Era (that is, AD or BC)
H Hour in day (0–23)
K Hour in AM / PM (0–11)
M Month
S Millisecond in second
W Week of month (1–5)
Z Time zone in RFC822 format
or PM
843This page intentionally left blankIII
Software Development
Using Java
C HAPTER 28
Java Beans
C HAPTER 29
Introducing Swing
C HAPTER 30
Exploring Swing
C HAPTER 31
ServletsThis page intentionally left blank28
Java Beans
T
his chapter provides an overview of Java Beans. Beans are important because they allow
you to build complex systems from software components. These components may be
provided by you or supplied by one or more different vendors. Java Beans defines an
architecture that specifies how these building blocks can operate together.
To better understand the value of Beans, consider the following. Hardware designers have
a wide variety of components that can be integrated together to construct a system. Resistors,
capacitors, and inductors are examples of simple building blocks. Integrated circuits provide
more advanced functionality. All of these different parts can be reused. It is not necessary
or possible to rebuild these capabilities each time a new system is needed. Also, the same
pieces can be used in different types of circuits. This is possible because the behavior of these
components is understood and documented.
The software industry has also been seeking the benefits of reusability and interoperability
of a component-based approach. To realize these benefits, a component architecture is needed
that allows programs to be assembled from software building blocks, perhaps provided by
different vendors. It must also be possible for a designer to select a component, understand
its capabilities, and incorporate it into an application. When a new version of a component
becomes available, it should be easy to incorporate this functionality into existing code.
Fortunately, Java Beans provides just such an architecture.
What Is a Java Bean?
A Java Bean is a software component that has been designed to be reusable in a variety of
different environments. There is no restriction on the capability of a Bean. It may perform
a simple function, such as obtaining an inventory value, or a complex function, such as
forecasting the performance of a stock portfolio. A Bean may be visible to an end user. One
example of this is a button on a graphical user interface. A Bean may also be invisible to a
user. Software to decode a stream of multimedia information in real time is an example of
this type of building block. Finally, a Bean may be designed to work autonomously on a user’s
workstation or to work in cooperation with a set of other distributed components. Software
to generate a pie chart from a set of data points is an example of a Bean that can execute locally.
However, a Bean that provides real-time price information from a stock or commodities
exchange would need to work in cooperation with other distributed software to obtain its data.
847848
Part III:
Software Development Using Java
Advantages of Java Beans
The following list enumerates some of the benefits that Java Bean technology provides for
a component developer:
• A Bean obtains all the benefits of Java’s “write-once, run-anywhere” paradigm.
• The properties, events, and methods of a Bean that are exposed to another application
can be controlled.
• Auxiliary software can be provided to help configure a Bean. This software is only
needed when the design-time parameters for that component are being set. It does
not need to be included in the run-time environment.
• The configuration settings of a Bean can be saved in persistent storage and restored
at a later time.
• A Bean may register to receive events from other objects and can generate events
that are sent to other objects.
Introspection
At the core of Java Beans is introspection. This is the process of analyzing a Bean to determine
its capabilities. This is an essential feature of the Java Beans API because it allows another
application, such as a design tool, to obtain information about a component. Without
introspection, the Java Beans technology could not operate.
There are two ways in which the developer of a Bean can indicate which of its properties,
events, and methods should be exposed. With the first method, simple naming conventions
are used. These allow the introspection mechanisms to infer information about a Bean. In
the second way, an additional class that extends the BeanInfo interface is provided that
explicitly supplies this information. Both approaches are examined here.
Design Patterns for Properties
A property is a subset of a Bean’s state. The values assigned to the properties determine the
behavior and appearance of that component. A property is set through a setter method. A
property is obtained by a getter method. There are two types of properties: simple and indexed.
Simple Properties
A simple property has a single value. It can be identified by the following design patterns,
where N is the name of the property and T is its type:
public T getN( )
public void setN(T arg)
A read/write property has both of these methods to access its values. A read-only property
has only a get method. A write-only property has only a set method.
Here are three read/write simple properties along with their getter and setter methods:
private double depth, height, width;
public double getDepth( ) Chapter 28:
Java Beans
public void setDepth(double d) 
public double getHeight( ) 
public void setHeight(double h) 
public double getWidth( ) 
public void setWidth(double w) 
Indexed Properties
An indexed property consists of multiple values. It can be identified by the following design
patterns, where N is the name of the property and T is its type:
public T getN(int index);
public void setN(int index, T value);
public T[ ] getN( );
public void setN(T values[ ]);
Here is an indexed property called data along with its getter and setter methods:
private double data[ ];
public double getData(int index) 
public void setData(int index, double value) 
public double[ ] getData( ) 
public void setData(double[ ] values) 
Design Patterns for Events
Beans use the delegation event model that was discussed earlier in this book. Beans can
generate events and send them to other objects. These can be identified by the following
design patterns, where T is the type of the event:
public void addTListener(TListener eventListener)
public void addTListener(TListener eventListener)
throws java.util.TooManyListenersException
public void removeTListener(TListener eventListener)
849850
Part III:
Software Development Using Java
These methods are used to add or remove a listener for the specified event. The version of
AddTListener( ) that does not throw an exception can be used to multicast an event, which
means that more than one listener can register for the event notification. The version that
throws TooManyListenersException unicasts the event, which means that the number of
listeners is restricted to one. In either case, removeTListener( ) is used to remove the listener.
For example, assuming an event interface type called TemperatureListener, a Bean that monitors
temperature might supply the following methods:
public void addTemperatureListener(TemperatureListener tl) 
public void removeTemperatureListener(TemperatureListener tl) 
Methods and Design Patterns
Design patterns are not used for naming nonproperty methods. The introspection mechanism
finds all of the public methods of a Bean. Protected and private methods are not presented.
Using the BeanInfo Interface
As the preceding discussion shows, design patterns implicitly determine what information is
available to the user of a Bean. The BeanInfo interface enables you to explicitly control what
information is available. The BeanInfo interface defines several methods, including these:
PropertyDescriptor[ ] getPropertyDescriptors( )
EventSetDescriptor[ ] getEventSetDescriptors( )
MethodDescriptor[ ] getMethodDescriptors( )
They return arrays of objects that provide information about the properties, events, and methods
of a Bean. The classes PropertyDescriptor, EventSetDescriptor, and MethodDescriptor
are defined within the java.beans package, and they describe the indicated elements. By
implementing these methods, a developer can designate exactly what is presented to a user,
bypassing introspection based on design patterns.
When creating a class that implements BeanInfo, you must call that class bnameBeanInfo,
where bname is the name of the Bean. For example, if the Bean is called MyBean, then the
information class must be called MyBeanBeanInfo.
To simplify the use of BeanInfo, JavaBeans supplies the SimpleBeanInfo class. It provides
default implementations of the BeanInfo interface, including the three methods just shown.
You can extend this class and override one or more of the methods to explicitly control what
aspects of a Bean are exposed. If you don’t override a method, then design-pattern introspection
will be used. For example, if you don’t override getPropertyDescriptors( ), then design
patterns are used to discover a Bean’s properties. You will see SimpleBeanInfo in action later
in this chapter.
Bound and Constrained Properties
A Bean that has a bound property generates an event when the property is changed. The
event is of type PropertyChangeEvent and is sent to objects that previously registered anChapter 28:
Java Beans
interest in receiving such notifications. A class that handles this event must implement the
PropertyChangeListener interface.
A Bean that has a constrained property generates an event when an attempt is made to
change its value. It also generates an event of type PropertyChangeEvent. It too is sent to objects
that previously registered an interest in receiving such notifications. However, those other
objects have the ability to veto the proposed change by throwing a PropertyVetoException.
This capability allows a Bean to operate differently according to its run-time environment.
A class that handles this event must implement the VetoableChangeListener interface.
Persistence
Persistence is the ability to save the current state of a Bean, including the values of a Bean’s
properties and instance variables, to nonvolatile storage and to retrieve them at a later time.
The object serialization capabilities provided by the Java class libraries are used to provide
persistence for Beans.
The easiest way to serialize a Bean is to have it implement the java.io.Serializable interface,
which is simply a marker interface. Implementing java.io.Serializable makes serialization
automatic. Your Bean need take no other action. Automatic serialization can also be inherited.
Therefore, if any superclass of a Bean implements java.io.Serializable, then automatic
serialization is obtained. There is one important restriction: any class that implements
java.io.Serializable must supply a parameterless constructor.
When using automatic serialization, you can selectively prevent a field from being saved
through the use of the transient keyword. Thus, data members of a Bean specified as transient
will not be serialized.
If a Bean does not implement java.io.Serializable, you must provide serialization yourself,
such as by implementing java.io.Externalizable. Otherwise, containers cannot save the
configuration of your component.
Customizers
A Bean developer can provide a customizer that helps another developer configure the Bean. A
customizer can provide a step-by-step guide through the process that must be followed to use
the component in a specific context. Online documentation can also be provided. A Bean
developer has great flexibility to develop a customizer that can differentiate his or her product
in the marketplace.
The Java Beans API
The Java Beans functionality is provided by a set of classes and interfaces in the java.beans
package. This section provides a brief overview of its contents. Table 28-1 lists the interfaces in
java.beans and provides a brief description of their functionality. Table 28-2 lists the classes
in java.beans.
Although it is beyond the scope of this chapter to discuss all of the classes, four are
of particular interest: Introspector, PropertyDescriptor, EventSetDescriptor, and
MethodDescriptor. Each is briefly examined here.
851852
Part III:
Software Development Using Java
Interface Description
AppletInitializer Methods in this interface are used to initialize Beans that are also
applets.
BeanInfo This interface allows a designer to specify information about the
properties, events, and methods of a Bean.
Customizer This interface allows a designer to provide a graphical user interface
through which a Bean may be configured.
DesignMode Methods in this interface determine if a Bean is executing in design
mode.
ExceptionListener A method in this interface is invoked when an exception has occurred.
PropertyChangeListener A method in this interface is invoked when a bound property is changed.
PropertyEditor Objects that implement this interface allow designers to change and
display property values.
VetoableChangeListener A method in this interface is invoked when a constrained property is
changed.
Visibility
T ABLE 28-1
Methods in this interface allow a Bean to execute in environments
where a graphical user interface is not available.
The Interfaces in java.beans
Class Description
BeanDescriptor This class provides information about a Bean. It also allows you
to associate a customizer with a Bean.
Beans This class is used to obtain information about a Bean.
DefaultPersistenceDelegate A concrete subclass of PersistenceDelegate.
Encoder Encodes the state of a set of Beans. Can be used to write this
information to a stream.
EventHandler Supports dynamic event listener creation.
EventSetDescriptor Instances of this class describe an event that can be generated
by a Bean.
Expression Encapsulates a call to a method that returns a result.
FeatureDescriptor This is the superclass of the PropertyDescriptor,
EventSetDescriptor, and MethodDescriptor classes.
IndexedPropertyChangeEvent A subclass of PropertyChangeEvent that represents a change
to an indexed property.
IndexedPropertyDescriptor Instances of this class describe an indexed property of a Bean.
IntrospectionException An exception of this type is generated if a problem occurs when
analyzing a Bean.
Introspector This class analyzes a Bean and constructs a BeanInfo object that
describes the component.
T ABLE 28-2
The Classes in java.beansChapter 28:
Java Beans
Class Description
MethodDescriptor Instances of this class describe a method of a Bean.
ParameterDescriptor Instances of this class describe a method parameter.
PersistenceDelegate Handles the state information of an object.
PropertyChangeEvent This event is generated when bound or constrained properties are
changed. It is sent to objects that registered an interest in these
events and that implement either the PropertyChangeListener or
VetoableChangeListener interfaces.
PropertyChangeListenerProxy Extends EventListenerProxy and implements
PropertyChangeListener.
PropertyChangeSupport Beans that support bound properties can use this class to notify
PropertyChangeListener objects.
PropertyDescriptor Instances of this class describe a property of a Bean.
PropertyEditorManager This class locates a PropertyEditor object for a given type.
PropertyEditorSupport This class provides functionality that can be used when writing
property editors.
PropertyVetoException An exception of this type is generated if a change to a constrained
property is vetoed.
SimpleBeanInfo This class provides functionality that can be used when writing
BeanInfo classes.
Statement Encapsulates a call to a method.
VetoableChangeListenerProxy Extends EventListenerProxy and implements
VetoableChangeListener.
VetoableChangeSupport Beans that support constrained properties can use this class
to notify VetoableChangeListener objects.
XMLDecoder Used to read a Bean from an XML document.
XMLEncoder Used to write a Bean to an XML document.
T ABLE 28-2
The Classes in java.beans (continued)
Introspector
The Introspector class provides several static methods that support introspection. Of most
interest is getBeanInfo( ). This method returns a BeanInfo object that can be used to obtain
information about the Bean. The getBeanInfo( ) method has several forms, including the
one shown here:
static BeanInfo getBeanInfo(Class<?> bean) throws IntrospectionException
The returned object contains information about the Bean specified by bean.
853854
Part III:
Software Development Using Java
PropertyDescriptor
The PropertyDescriptor class describes a Bean property. It supports several methods that
manage and describe properties. For example, you can determine if a property is bound by
calling isBound( ). To determine if a property is constrained, call isConstrained( ). You can
obtain the name of property by calling getName( ).
EventSetDescriptor
The EventSetDescriptor class represents a Bean event. It supports several methods that
obtain the methods that a Bean uses to add or remove event listeners, and to otherwise manage
events. For example, to obtain the method used to add listeners, call getAddListenerMethod( ).
To obtain the method used to remove listeners, call getRemoveListenerMethod( ). To obtain
the type of a listener, call getListenerType( ). You can obtain the name of an event by calling
getName( ).
MethodDescriptor
The MethodDescriptor class represents a Bean method. To obtain the name of the method,
call getName( ). You can obtain information about the method by calling getMethod( ),
shown here:
Method getMethod( )
An object of type Method that describes the method is returned.
A Bean Example
This chapter concludes with an example that illustrates various aspects of Bean programming,
including introspection and using a BeanInfo class. It also makes use of the Introspector,
PropertyDescriptor, and EventSetDescriptor classes. The example uses three classes. The
first is a Bean called Colors, shown here:
// A simple Bean.
import java.awt.*;
import java.awt.event.*;
import java.io.Serializable;
public class Colors extends Canvas implements Serializable 
The Colors Bean displays a colored object within a frame. The color of the component is
determined by the private Color variable color, and its shape is determined by the private
boolean variable rectangular. The constructor defines an anonymous inner class that extends
MouseAdapter and overrides its mousePressed( ) method. The change( ) method is invoked
in response to mouse presses. It selects a random color and then repaints the component. The
getRectangular( ) and setRectangular( ) methods provide access to the one property of this
Bean. The change( ) method calls randomColor( ) to choose a color and then calls repaint( )
to make the change visible. Notice that the paint( ) method uses the rectangular and color
variables to determine how to present the Bean.
The next class is ColorsBeanInfo. It is a subclass of SimpleBeanInfo that provides explicit
information about Colors. It overrides getPropertyDescriptors( ) in order to designate which
properties are presented to a Bean user. In this case, the only property exposed is rectangular.
The method creates and returns a PropertyDescriptor object for the rectangular property. The
PropertyDescriptor constructor that is used is shown here:
PropertyDescriptor(String property, Class<?> beanCls)
throws IntrospectionException
855856
Part III:
Software Development Using Java
Here, the first argument is the name of the property, and the second argument is the class of
the Bean.
// A Bean information class.
import java.beans.*;
public class ColorsBeanInfo extends SimpleBeanInfo 
The final class is called IntrospectorDemo. It uses introspection to display the properties
and events that are available within the Colors Bean.
// Show properties and events.
import java.awt.*;
import java.beans.*;
public class IntrospectorDemo Chapter 28:
Java Beans
The output from this program is the following:
Properties:
rectangular
Events:
mouseWheel
mouse
mouseMotion
component
hierarchyBounds
focus
hierarchy
propertyChange
inputMethod
key
Notice two things in the output. First, because ColorsBeanInfo overrides
getPropertyDescriptors( ) such that the only property returned is rectangular, only
the rectangular property is displayed. However, because getEventSetDescriptors( ) is
not overridden by ColorsBeanInfo, design-pattern introspection is used, and all events
are found, including those in Colors’ superclass, Canvas. Remember, if you don’t override
one of the “get” methods defined by SimpleBeanInfo, then the default, design-pattern
introspection is used. To observe the difference that ColorsBeanInfo makes, erase its class
file and then run IntrospectorDemo again. This time it will report more properties.
857This page intentionally left blank29
Introducing Swing
I
n Part II, you saw how to build user interfaces with the AWT classes. Although the AWT
is still a crucial part of Java, its component set is no longer widely used to create graphic
user interfaces. Today, most programmers use Swing for this purpose. Swing is a set of
classes that provides more powerful and flexible GUI components than does the AWT. Simply
put, Swing provides the look and feel of the modern Java GUI.
Coverage of Swing is divided between two chapters. This chapter introduces Swing.
It begins by describing Swing’s core concepts. It then shows the general form of a Swing
program, including both applications and applets. It concludes by explaining how painting
is accomplished in Swing. The following chapter presents several commonly used Swing
components. It is important to understand that the number of classes and interfaces in the
Swing packages is quite large, and they can’t all be covered in this book. (In fact, full
coverage of Swing requires an entire book of its own.) However, these two chapters will
give you a basic understanding of this important topic.
N OTE For a comprehensive introduction to Swing, see my book Swing: A Beginner’s Guide
published by McGraw-Hill/Osborne (2007).
The Origins of Swing
Swing did not exist in the early days of Java. Rather, it was a response to deficiencies present
in Java’s original GUI subsystem: the Abstract Window Toolkit. The AWT defines a basic set
of controls, windows, and dialog boxes that support a usable, but limited graphical interface.
One reason for the limited nature of the AWT is that it translates its various visual components
into their corresponding, platform-specific equivalents, or peers. This means that the look
and feel of a component is defined by the platform, not by Java. Because the AWT components
use native code resources, they are referred to as heavyweight.
The use of native peers led to several problems. First, because of variations between
operating systems, a component might look, or even act, differently on different platforms.
This potential variability threatened the overarching philosophy of Java: write once, run
anywhere. Second, the look and feel of each component was fixed (because it is defined by
the platform) and could not be (easily) changed. Third, the use of heavyweight components
caused some frustrating restrictions. For example, a heavyweight component is always
rectangular and opaque.
859860
Part III:
Software Development Using Java
Not long after Java’s original release, it became apparent that the limitations and
restrictions present in the AWT were sufficiently serious that a better approach was needed.
The solution was Swing. Introduced in 1997, Swing was included as part of the Java
Foundation Classes (JFC). Swing was initially available for use with Java 1.1 as a separate
library. However, beginning with Java 1.2, Swing (and the rest of the JFC) was fully
integrated into Java.
Swing Is Built on the AWT
Before moving on, it is necessary to make one important point: although Swing eliminates
a number of the limitations inherent in the AWT, Swing does not replace it. Instead, Swing
is built on the foundation of the AWT. This is why the AWT is still a crucial part of Java.
Swing also uses the same event handling mechanism as the AWT. Therefore, a basic
understanding of the AWT and of event handling is required to use Swing. (The AWT
is covered in Chapters 23 and 24. Event handling is described in Chapter 22.)
Two Key Swing Features
As just explained, Swing was created to address the limitations present in the AWT. It does
this through two key features: lightweight components and a pluggable look and feel.
Together they provide an elegant, yet easy-to-use solution to the problems of the AWT.
More than anything else, it is these two features that define the essence of Swing. Each
is examined here.
Swing Components Are Lightweight
With very few exceptions, Swing components are lightweight. This means that they are written
entirely in Java and do not map directly to platform-specific peers. Because lightweight
components are rendered using graphics primitives, they can be transparent, which enables
nonrectangular shapes. Thus, lightweight components are more efficient and more flexible.
Furthermore, because lightweight components do not translate into native peers, the look and
feel of each component is determined by Swing, not by the underlying operating system. This
means that each component will work in a consistent manner across all platforms.
Swing Supports a Pluggable Look and Feel
Swing supports a pluggable look and feel (PLAF). Because each Swing component is rendered
by Java code rather than by native peers, the look and feel of a component is under the
control of Swing. This fact means that it is possible to separate the look and feel of a
component from the logic of the component, and this is what Swing does. Separating out
the look and feel provides a significant advantage: it becomes possible to change the way
that a component is rendered without affecting any of its other aspects. In other words, it is
possible to “plug in” a new look and feel for any given component without creating any
side effects in the code that uses that component. Moreover, it becomes possible to define
entire sets of look-and-feels that represent different GUI styles. To use a specific style, its
look and feel is simply “plugged in.” Once this is done, all components are automatically
rendered using that style.
Pluggable look-and-feels offer several important advantages. It is possible to define a
look and feel that is consistent across all platforms. Conversely, it is possible to create a lookChapter 29:
Introducing Swing
and feel that acts like a specific platform. For example, if you know that an application will
be running only in a Windows environment, it is possible to specify the Windows look and
feel. It is also possible to design a custom look and feel. Finally, the look and feel can be
changed dynamically at run time.
Java SE 6 provides look-and-feels, such as metal and Motif, that are available to all Swing
users. The metal look and feel is also called the Java look and feel. It is platform-independent and
available in all Java execution environments. It is also the default look and feel. Windows
environments also have access to the Windows and Windows Classic look and feel. This
book uses the default Java look and feel (metal) because it is platform independent.
The MVC Connection
In general, a visual component is a composite of three distinct aspects:
• The way that the component looks when rendered on the screen
• The way that the component reacts to the user
• The state information associated with the component
No matter what architecture is used to implement a component, it must implicitly contain
these three parts. Over the years, one component architecture has proven itself to be
exceptionally effective: Model-View-Controller, or MVC for short.
The MVC architecture is successful because each piece of the design corresponds to an
aspect of a component. In MVC terminology, the model corresponds to the state information
associated with the component. For example, in the case of a check box, the model contains
a field that indicates if the box is checked or unchecked. The view determines how the
component is displayed on the screen, including any aspects of the view that are affected
by the current state of the model. The controller determines how the component reacts to the
user. For example, when the user clicks a check box, the controller reacts by changing the
model to reflect the user’s choice (checked or unchecked). This then results in the view
being updated. By separating a component into a model, a view, and a controller, the
specific implementation of each can be changed without affecting the other two. For instance,
different view implementations can render the same component in different ways without
affecting the model or the controller.
Although the MVC architecture and the principles behind it are conceptually sound,
the high level of separation between the view and the controller is not beneficial for Swing
components. Instead, Swing uses a modified version of MVC that combines the view and
the controller into a single logical entity called the UI delegate. For this reason, Swing’s
approach is called either the Model-Delegate architecture or the Separable Model architecture.
Therefore, although Swing’s component architecture is based on MVC, it does not use a
classical implementation of it.
Swing’s pluggable look and feel is made possible by its Model-Delegate architecture.
Because the view (look) and controller (feel) are separate from the model, the look and feel
can be changed without affecting how the component is used within a program.
Conversely, it is possible to customize the model without affecting the way that the
component appears on the screen or responds to user input.
To support the Model-Delegate architecture, most Swing components contain two objects.
The first represents the model. The second represents the UI delegate. Models are defined
861862
Part III:
Software Development Using Java
by interfaces. For example, the model for a button is defined by the ButtonModel interface.
UI delegates are classes that inherit ComponentUI. For example, the UI delegate for a button
is ButtonUI. Normally, your programs will not interact directly with the UI delegate.
Components and Containers
A Swing GUI consists of two key items: components and containers. However, this distinction
is mostly conceptual because all containers are also components. The difference between the
two is found in their intended purpose: As the term is commonly used, a component is an
independent visual control, such as a push button or slider. A container holds a group of
components. Thus, a container is a special type of component that is designed to hold other
components. Furthermore, in order for a component to be displayed, it must be held within
a container. Thus, all Swing GUIs will have at least one container. Because containers are
components, a container can also hold other containers. This enables Swing to define what
is called a containment hierarchy, at the top of which must be a top-level container.
Let’s look a bit more closely at components and containers.
Components
In general, Swing components are derived from the JComponent class. (The only exceptions
to this are the four top-level containers, described in the next section.) JComponent provides
the functionality that is common to all components. For example, JComponent supports the
pluggable look and feel. JComponent inherits the AWT classes Container and Component.
Thus, a Swing component is built on and compatible with an AWT component.
All of Swing’s components are represented by classes defined within the package
javax.swing. The following table shows the class names for Swing components (including
those used as containers).
JApplet JButton JCheckBox JCheckBoxMenuItem
JColorChooser JComboBox JComponent JDesktopPane
JDialog JEditorPane JFileChooser JFormattedTextField
JFrame JInternalFrame JLabel JLayeredPane
JList JMenu JMenuBar JMenuItem
JOptionPane JPanel JPasswordField JPopupMenu
JProgressBar JRadioButton JRadioButtonMenuItem JRootPane
JScrollBar JScrollPane JSeparator JSlider
JSpinner JSplitPane JTabbedPane JTable
JTextArea JTextField JTextPane JTogglebutton
JToolBar JToolTip JTree JViewport
JWindowChapter 29:
Introducing Swing
Notice that all component classes begin with the letter J. For example, the class for a label
is JLabel; the class for a push button is JButton; and the class for a scroll bar is JScrollBar.
Containers
Swing defines two types of containers. The first are top-level containers: JFrame, JApplet,
JWindow, and JDialog. These containers do not inherit JComponent. They do, however,
inherit the AWT classes Component and Container. Unlike Swing’s other components,
which are lightweight, the top-level containers are heavyweight. This makes the top-level
containers a special case in the Swing component library.
As the name implies, a top-level container must be at the top of a containment hierarchy.
A top-level container is not contained within any other container. Furthermore, every
containment hierarchy must begin with a top-level container. The one most commonly used
for applications is JFrame. The one used for applets is JApplet.
The second type of containers supported by Swing are lightweight containers. Lightweight
containers do inherit JComponent. An example of a lightweight container is JPanel, which
is a general-purpose container. Lightweight containers are often used to organize and
manage groups of related components because a lightweight container can be contained
within another container. Thus, you can use lightweight containers such as JPanel to create
subgroups of related controls that are contained within an outer container.
The Top-Level Container Panes
Each top-level container defines a set of panes. At the top of the hierarchy is an instance of
JRootPane. JRootPane is a lightweight container whose purpose is to manage the other
panes. It also helps manage the optional menu bar. The panes that comprise the root pane
are called the glass pane, the content pane, and the layered pane.
The glass pane is the top-level pane. It sits above and completely covers all other panes.
By default, it is a transparent instance of JPanel. The glass pane enables you to manage
mouse events that affect the entire container (rather than an individual control) or to paint
over any other component, for example. In most cases, you won’t need to use the glass pane
directly, but it is there if you need it.
The layered pane is an instance of JLayeredPane. The layered pane allows components
to be given a depth value. This value determines which component overlays another. (Thus,
the layered pane lets you specify a Z-order for a component, although this is not something
that you will usually need to do.) The layered pane holds the content pane and the (optional)
menu bar.
Although the glass pane and the layered panes are integral to the operation of a top-level
container and serve important purposes, much of what they provide occurs behind the
scene. The pane with which your application will interact the most is the content pane,
because this is the pane to which you will add visual components. In other words, when
you add a component, such as a button, to a top-level container, you will add it to the
content pane. By default, the content pane is an opaque instance of JPanel.
The Swing Packages
Swing is a very large subsystem and makes use of many packages. These are the packages
used by Swing that are defined by Java SE 6.
863864
Part III:
Software Development Using Java
javax.swing javax.swing.border javax.swing.colorchooser
javax.swing.event javax.swing.filechooser javax.swing.plaf
javax.swing.plaf.basic javax.swing.plaf.metal javax.swing.plaf.multi
javax.swing.plaf.synth javax.swing.table javax.swing.text
javax.swing.text.html javax.swing.text.html.parser javax.swing.text.rtf
javax.swing.tree javax.swing.undo
The main package is javax.swing. This package must be imported into any program
that uses Swing. It contains the classes that implement the basic Swing components, such as
push buttons, labels, and check boxes.
A Simple Swing Application
Swing programs differ from both the console-based programs and the AWT-based programs
shown earlier in this book. For example, they use a different set of components and a
different container hierarchy than does the AWT. Swing programs also have special
requirements that relate to threading. The best way to understand the structure of a Swing
program is to work through an example. There are two types of Java programs in which
Swing is typically used. The first is a desktop application. The second is the applet. This
section shows how to create a Swing application. The creation of a Swing applet is described
later in this chapter.
Although quite short, the following program shows one way to write a Swing application.
In the process, it demonstrates several key features of Swing. It uses two Swing components:
JFrame and JLabel. JFrame is the top-level container that is commonly used for Swing
applications. JLabel is the Swing component that creates a label, which is a component that
displays information. The label is Swing’s simplest component because it is passive. That is,
a label does not respond to user input. It just displays output. The program uses a JFrame
container to hold an instance of a JLabel. The label displays a short text message.
// A simple Swing application.
import javax.swing.*;
class SwingDemo 
Swing programs are compiled and run in the same way as other Java applications. Thus,
to compile this program, you can use this command line:
javac SwingDemo.java
To run the program, use this command line:
java SwingDemo
When the program is run, it will produce the window shown in Figure 29-1.
Because the SwingDemo program illustrates several core Swing concepts, we will
examine it carefully, line by line. The program begins by importing javax.swing. As
mentioned, this package contains the components and models defined by Swing. For
example, javax.swing defines classes that implement labels, buttons, text controls, and
menus. It will be included in all programs that use Swing.
Next, the program declares the SwingDemo class and a constructor for that class. The
constructor is where most of the action of the program occurs. It begins by creating a JFrame,
using this line of code:
JFrame jfrm = new JFrame("A Simple Swing Application");
This creates a container called jfrm that defines a rectangular window complete with a title
bar; close, minimize, maximize, and restore buttons; and a system menu. Thus, it creates a
standard, top-level window. The title of the window is passed to the constructor.
F IGURE 29-1
The window produced by the SwingDemo program
865866
Part III:
Software Development Using Java
Next, the window is sized using this statement:
jfrm.setSize(275, 100);
The setSize( ) method (which is inherited by JFrame from the AWT class Component) sets
the dimensions of the window, which are specified in pixels. Its general form is shown here:
void setSize(int width, int height)
In this example, the width of the window is set to 275 and the height is set to 100.
By default, when a top-level window is closed (such as when the user clicks the close
box), the window is removed from the screen, but the application is not terminated. While
this default behavior is useful in some situations, it is not what is needed for most applications.
Instead, you will usually want the entire application to terminate when its top-level
window is closed. There are a couple of ways to achieve this. The easiest way is to call
setDefaultCloseOperation( ), as the program does:
jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
After this call executes, closing the window causes the entire application to terminate. The
general form of setDefaultCloseOperation( ) is shown here:
void setDefaultCloseOperation(int what)
The value passed in what determines what happens when the window is closed. There are
several other options in addition to JFrame.EXIT_ON_CLOSE. They are shown here:
JFrame.DISPOSE_ON_CLOSE
JFrame.HIDE_ON_CLOSE
JFrame.DO_NOTHING_ON_CLOSE
Their names reflect their actions. These constants are declared in WindowConstants, which
is an interface declared in javax.swing that is implemented by JFrame.
The next line of code creates a Swing JLabel component:
JLabel jlab = new JLabel(" Swing means powerful GUIs.");
JLabel is the simplest and easiest-to-use component because it does not accept user input. It
simply displays information, which can consist of text, an icon, or a combination of the two.
The label created by the program contains only text, which is passed to its constructor.
The next line of code adds the label to the content pane of the frame:
jfrm.add(jlab);
As explained earlier, all top-level containers have a content pane in which components are
stored. Thus, to add a component to a frame, you must add it to the frame’s content pane.
This is accomplished by calling add( ) on the JFrame reference (jfrm in this case). The
general form of add( ) is shown here:
Component add(Component comp)Chapter 29:
Introducing Swing
The add( ) method is inherited by JFrame from the AWT class Container.
By default, the content pane associated with a JFrame uses border layout. The version
of add( ) just shown adds the label to the center location. Other versions of add( ) enable
you to specify one of the border regions. When a component is added to the center, its size
is adjusted automatically to fit the size of the center.
Before continuing, an important historical point needs to be made. Prior to JDK 5, when
adding a component to the content pane, you could not invoke the add( ) method directly
on a JFrame instance. Instead, you needed to call add( ) on the content pane of the JFrame
object. The content pane can be obtained by calling getContentPane( ) on a JFrame instance.
The getContentPane( ) method is shown here:
Container getContentPane( )
It returns a Container reference to the content pane. The add( ) method was then called on
that reference to add a component to a content pane. Thus, in the past, you had to use the
following statement to add jlab to jfrm:
jfrm.getContentPane().add(jlab); // old-style
Here, getContentPane( ) first obtains a reference to content pane, and then add( ) adds the
component to the container linked to this pane. This same procedure was also required to
invoke remove( ) to remove a component and setLayout( ) to set the layout manager for the
content pane. You will see explicit calls to getContentPane( ) frequently throughout pre-5.0
code. Today, the use of getContentPane( ) is no longer necessary. You can simply call add( ),
remove( ), and setLayout( ) directly on JFrame because these methods have been changed
so that they operate on the content pane automatically.
The last statement in the SwingDemo constructor causes the window to become visible:
jfrm.setVisible(true);
The setVisible( ) method is inherited from the AWT Component class. If its argument is
true, the window will be displayed. Otherwise, it will be hidden. By default, a JFrame is
invisible, so setVisible(true) must be called to show it.
Inside main( ), a SwingDemo object is created, which causes the window and the label to
be displayed. Notice that the SwingDemo constructor is invoked using these lines of code:
SwingUtilities.invokeLater(new Runnable() );
This sequence causes a SwingDemo object to be created on the event dispatching thread
rather than on the main thread of the application. Here’s why. In general, Swing programs
are event-driven. For example, when a user interacts with a component, an event is
generated. An event is passed to the application by calling an event handler defined by the
application. However, the handler is executed on the event dispatching thread provided by
Swing and not on the main thread of the application. Thus, although event handlers are
defined by your program, they are called on a thread that was not created by your program.
867868
Part III:
Software Development Using Java
To avoid problems (including the potential for deadlock), all Swing GUI components must
be created and updated from the event dispatching thread, not the main thread of the
application. However, main( ) is executed on the main thread. Thus, main( ) cannot directly
instantiate a SwingDemo object. Instead, it must create a Runnable object that executes on
the event dispatching thread and have this object create the GUI.
To enable the GUI code to be created on the event dispatching thread, you must use one of
two methods that are defined by the SwingUtilities class. These methods are invokeLater( )
and invokeAndWait( ). They are shown here:
static void invokeLater(Runnable obj)
static void invokeAndWait(Runnable obj)
throws InterruptedException, InvocationTargetException
Here, obj is a Runnable object that will have its run( ) method called by the event dispatching
thread. The difference between the two methods is that invokeLater( ) returns immediately,
but invokeAndWait( ) waits until obj.run( ) returns. You can use one of these methods to
call a method that constructs the GUI for your Swing application, or whenever you need to
modify the state of the GUI from code not executed by the event dispatching thread. You
will normally want to use invokeLater( ), as the preceding program does. However, when
constructing the initial GUI for an applet, you will need to use invokeAndWait( ).
Event Handling
The preceding example showed the basic form of a Swing program, but it left out one
important part: event handling. Because JLabel does not take input from the user, it does
not generate events, so no event handling was needed. However, the other Swing components
do respond to user input and the events generated by those interactions need to be handled.
Events can also be generated in ways not directly related to user input. For example, an
event is generated when a timer goes off. Whatever the case, event handling is a large part
of any Swing-based application.
The event handling mechanism used by Swing is the same as that used by the AWT.
This approach is called the delegation event model, and it is described in Chapter 22. In many
cases, Swing uses the same events as does the AWT, and these events are packaged in
java.awt.event. Events specific to Swing are stored in javax.swing.event.
Although events are handled in Swing in the same way as they are with the AWT, it is
still useful to work through a simple example. The following program handles the event
generated by a Swing push button. Sample output is shown in Figure 29-2.
F IGURE 29-2
Output from the EventDemo programChapter 29:
Introducing Swing
// Handle an event in a Swing program.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
class EventDemo 
First, notice that the program now imports both the java.awt and java.awt.event
packages. The java.awt package is needed because it contains the FlowLayout class, which
supports the standard flow layout manager used to lay out components in a frame. (See
Chapter 24 for coverage of layout managers.) The java.awt.event package is needed because
it defines the ActionListener interface and the ActionEvent class.
The EventDemo constructor begins by creating a JFrame called jfrm. It then sets the
layout manager for the content pane of jfrm to FlowLayout. Recall that, by default, the content
pane uses BorderLayout as its layout manager. However, for this example, FlowLayout is
more convenient. Notice that FlowLayout is assigned using this statement:
jfrm.setLayout(new FlowLayout());
As explained, in the past you had to explicitly call getContentPane( ) to set the layout
manager for the content pane. This requirement was removed as of JDK 5.
After setting the size and default close operation, EventDemo( ) creates two push
buttons, as shown here:
JButton jbtnAlpha = new JButton("Alpha");
JButton jbtnBeta = new JButton("Beta");
The first button will contain the text “Alpha” and the second will contain the text “Beta.”
Swing push buttons are instances of JButton. JButton supplies several constructors. The
one used here is
JButton(String msg)
The msg parameter specifies the string that will be displayed inside the button.
When a push button is pressed, it generates an ActionEvent. Thus, JButton provides
the addActionListener( ) method, which is used to add an action listener. (JButton also
provides removeActionListener( ) to remove a listener, but this method is not used by
the program.) As explained in Chapter 22, the ActionListener interface defines only one
method: actionPerformed( ). It is shown again here for your convenience:
void actionPerformed(ActionEvent ae)
This method is called when a button is pressed. In other words, it is the event handler that
is called when a button press event has occurred.Chapter 29:
Introducing Swing
Next, event listeners for the button’s action events are added by the code shown here:
// Add action listener for Alpha.
jbtnAlpha.addActionListener(new ActionListener() );
// Add action listener for Beta.
jbtnBeta.addActionListener(new ActionListener() );
Here, anonymous inner classes are used to provide the event handlers for the two buttons.
Each time a button is pressed, the string displayed in jlab is changed to reflect which button
was pressed.
Next, the buttons are added to the content pane of jfrm:
jfrm.add(jbtnAlpha);
jfrm.add(jbtnBeta);
Finally, jlab is added to the content pane and window is made visible. When you run the
program, each time you press a button, a message is displayed in the label that indicates
which button was pressed.
One last point: Remember that all event handlers, such as actionPerformed( ), are called
on the event dispatching thread. Therefore, an event handler must return quickly in order to
avoid slowing down the application. If your application needs to do something time
consuming as the result of an event, it must use a separate thread.
Create a Swing Applet
The second type of program that commonly uses Swing is the applet. Swing-based applets
are similar to AWT-based applets, but with an important difference: A Swing applet extends
JApplet rather than Applet. JApplet is derived from Applet. Thus, JApplet includes all of
the functionality found in Applet and adds support for Swing. JApplet is a top-level Swing
container, which means that it is not derived from JComponent. Because JApplet is a
top-level container, it includes the various panes described earlier. This means that all
components are added to JApplet’s content pane in the same way that components are
added to JFrame’s content pane.
Swing applets use the same four lifecycle methods as described in Chapter 21: init( ),
start( ), stop( ), and destroy( ). Of course, you need override only those methods that are
needed by your applet. Painting is accomplished differently in Swing than it is in the AWT,
and a Swing applet will not normally override the paint( ) method. (Painting in Swing is
described later in this chapter.)
One other point: All interaction with components in a Swing applet must take place on
the event dispatching thread, as described in the previous section. This threading issue
applies to all Swing programs.
871872
Part III:
F IGURE 29-3
Software Development Using Java
Output from the example Swing applet
Here is an example of a Swing applet. It provides the same functionality as the previous
application, but does so in applet form. Figure 29-3 shows the program when executed by
appletviewer.
// A simple Swing-based applet
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
/*
This HTML can be used to launch the applet:
<object code="MySwingApplet" width=220 height=90>
</object>
*/
public class MySwingApplet extends JApplet 
There are two important things to notice about this applet. First, MySwingApplet
extends JApplet. As explained, all Swing-based applets extend JApplet rather than Applet.
Second, the init( ) method initializes the Swing components on the event dispatching thread
by setting up a call to makeGUI( ). Notice that this is accomplished through the use of
invokeAndWait( ) rather than invokeLater( ). Applets must use invokeAndWait( ) because
the init( ) method must not return until the entire initialization process has been completed.
In essence, the start( ) method cannot be called until after initialization, which means that
the GUI must be fully constructed.
Inside makeGUI( ), the two buttons and label are created, and the action listeners are
added to the buttons. Finally, the components are added to the content pane. Although
this example is quite simple, this same general approach must be used when building any
Swing GUI that will be used by an applet.
Painting in Swing
Although the Swing component set is quite powerful, you are not limited to using it
because Swing also lets you write directly into the display area of a frame, panel, or one of
Swing’s other components, such as JLabel. Although many (perhaps most) uses of Swing
will not involve drawing directly to the surface of a component, it is available for those
873874
Part III:
Software Development Using Java
applications that need this capability. To write output directly to the surface of a component,
you will use one or more drawing methods defined by the AWT, such as drawLine( ) or
drawRect( ). Thus, most of the techniques and methods described in Chapter 23 also apply
to Swing. However, there are also some very important differences, and the process is
discussed in detail in this section.
Painting Fundamentals
Swing’s approach to painting is built on the original AWT-based mechanism, but Swing’s
implementation offers more finally grained control. Before examining the specifics of
Swing-based painting, it is useful to review the AWT-based mechanism that underlies it.
The AWT class Component defines a method called paint( ) that is used to draw output
directly to the surface of a component. For the most part, paint( ) is not called by your program.
(In fact, only in the most unusual cases should it ever be called by your program.) Rather,
paint( ) is called by the run-time system whenever a component must be rendered. This
situation can occur for several reasons. For example, the window in which the component
is displayed can be overwritten by another window and then uncovered. Or, the window
might be minimized and then restored. The paint( ) method is also called when a program
begins running. When writing AWT-based code, an application will override paint( ) when
it needs to write output directly to the surface of the component.
Because JComponent inherits Component, all Swing’s lightweight components inherit
the paint( ) method. However, you will not override it to paint directly to the surface of a
component. The reason is that Swing uses a bit more sophisticated approach to painting that
involves three distinct methods: paintComponent( ), paintBorder( ), and paintChildren( ).
These methods paint the indicated portion of a component and divide the painting process
into its three distinct, logical actions. In a lightweight component, the original AWT method
paint( ) simply executes calls to these methods, in the order just shown.
To paint to the surface of a Swing component, you will create a subclass of the component
and then override its paintComponent( ) method. This is the method that paints the interior
of the component. You will not normally override the other two painting methods. When
overriding paintComponent( ), the first thing you must do is call super.paintComponent( ), so
that the superclass portion of the painting process takes place. (The only time this is
not required is when you are taking complete, manual control over how a component is
displayed.) After that, write the output that you want to display. The paintComponent( )
method is shown here:
protected void paintComponent(Graphics g)
The parameter g is the graphics context to which output is written.
To cause a component to be painted under program control, call repaint( ). It works in
Swing just as it does for the AWT. The repaint( ) method is defined by Component. Calling
it causes the system to call paint( ) as soon as it is possible to do so. Because painting is a
time-consuming operation, this mechanism allows the run-time system to defer painting
momentarily until some higher-priority task has completed, for example. Of course, in
Swing the call to paint( ) results in a call to paintComponent( ). Therefore, to output to the
surface of a component, your program will store the output until paintComponent( ) is
called. Inside the overridden paintComponent( ), you will draw the stored output.Chapter 29:
Introducing Swing
Compute the Paintable Area
When drawing to the surface of a component, you must be careful to restrict your output
to the area that is inside the border. Although Swing automatically clips any output that
will exceed the boundaries of a component, it is still possible to paint into the border, which
will then get overwritten when the border is drawn. To avoid this, you must compute the
paintable area of the component. This is the area defined by the current size of the component
minus the space used by the border. Therefore, before you paint to a component, you must
obtain the width of the border and then adjust your drawing accordingly.
To obtain the border width, call getInsets( ), shown here:
Insets getInsets( )
This method is defined by Container and overridden by JComponent. It returns an Insets
object that contains the dimensions of the border. The inset values can be obtained by using
these fields:
int top;
int bottom;
int left;
int right;
These values are then used to compute the drawing area given the width and the height of
the component. You can obtain the width and height of the component by calling getWidth( )
and getHeight( ) on the component. They are shown here:
int getWidth( )
int getHeight( )
By subtracting the value of the insets, you can compute the usable width and height of the
component.
A Paint Example
Here is a program that puts into action the preceding discussion. It creates a class called
PaintPanel that extends JPanel. The program then uses an object of that class to display lines
whose endpoints have been generated randomly. Sample output is shown in Figure 10-4.
F IGURE 29-4
Sample output from the PaintPanel program
875876
Part III:
Software Development Using Java
// Paint lines to a panel.
import
import
import
import
java.awt.*;
java.awt.event.*;
javax.swing.*;
java.util.*;
// This class extends JPanel. It overrides
// the paintComponent() method so that random
// lines are plotted in the panel.
class PaintPanel extends JPanel Chapter 29:
Introducing Swing
// Demonstrate painting directly onto a panel.
class PaintDemo 
Let’s examine this program closely. The PaintPanel class extends JPanel. JPanel is one
of Swing’s lightweight containers, which means that it is a component that can be added to
the content pane of a JFrame. To handle painting, PaintPanel overrides the paintComponent( )
method. This enables PaintPanel to write directly to the surface of the component when
painting takes place. The size of the panel is not specified because the program uses the
default border layout and the panel is added to the center. This results in the panel being
sized to fill the center. If you change the size of the window, the size of the panel will be
adjusted accordingly.
Notice that the constructor also specifies a 5-pixel wide, red border. This is
accomplished by setting the border by using the setBorder( ) method, shown here:
void setBorder(Border border)
877878
Part III:
Software Development Using Java
Border is the Swing interface that encapsulates a border. You can obtain a border by calling
one of the factory methods defined by the BorderFactory class. The one used in the
program is createLineBorder( ), which creates a simple line border. It is shown here:
static Border createLineBorder(Color clr, int width)
Here, clr specifies the color of the border and width specifies its width in pixels.
Inside the override of paintComponent( ), notice that it first calls super.paintComponent( ).
As explained, this is necessary to ensure that the component is properly drawn. Next the width
and height of the panel are obtained along with the insets. These values are used to ensure the
lines lie within the drawing area of the panel. The drawing area is the overall width and height
of a component less the border width. The computations are designed to work with differently
sized PaintPanels and borders. To prove this, try changing the size of the window. The lines will
still all lie within the borders of the panel.
The PaintDemo class creates a PaintPanel and then adds the panel to the content pane.
When the application is first displayed, the overridden paintComponent( ) method is
called, and the lines are drawn. Each time you resize or hide and restore the window, a
new set of lines are drawn. In all cases, the lines fall within the paintable area.30
Exploring Swing
T
he previous chapter described several of the core concepts relating to Swing and
showed the general form of both a Swing application and a Swing applet. This
chapter continues the discussion of Swing by presenting an overview of several
Swing components, such as buttons, check boxes, trees, and tables. The Swing components
provide rich functionality and allow a high level of customization. Because of space
limitations, it is not possible to describe all of their features and attributes. Rather, the
purpose of this overview is to give you a feel for the capabilities of the Swing component set.
The Swing component classes described in this chapter are shown here:
JButton JCheckBox JComboBox JLabel
JList JRadioButton JScrollPane JTabbedPane
JTable JTextField JToggleButton JTree
These components are all lightweight, which means that they are all derived from
JComponent.
Also discussed is the ButtonGroup class, which encapsulates a mutually exclusive set
of Swing buttons, and ImageIcon, which encapsulates a graphics image. Both are defined
by Swing and packaged in javax.swing.
One other point: The Swing components are demonstrated in applets because the code
for an applet is more compact than it is for a desktop application. However, the same
techniques apply to both applets and applications.
JLabel and ImageIcon
JLabel is Swing’s easiest-to-use component. It creates a label and was introduced in the
preceding chapter. Here, we will look at JLabel a bit more closely. JLabel can be used to
display text and/or an icon. It is a passive component in that it does not respond to user
input. JLabel defines several constructors. Here are three of them:
JLabel(Icon icon)
JLabel(String str)
JLabel(String str, Icon icon, int align)
879880
Part III:
Software Development Using Java
Here, str and icon are the text and icon used for the label. The align argument specifies the
horizontal alignment of the text and/or icon within the dimensions of the label. It must be
one of the following values: LEFT, RIGHT, CENTER, LEADING, or TRAILING. These
constants are defined in the SwingConstants interface, along with several others used by
the Swing classes.
Notice that icons are specified by objects of type Icon, which is an interface defined
by Swing. The easiest way to obtain an icon is to use the ImageIcon class. ImageIcon
implements Icon and encapsulates an image. Thus, an object of type ImageIcon can be
passed as an argument to the Icon parameter of JLabel’s constructor. There are several ways
to provide the image, including reading it from a file or downloading it from a URL. Here is
the ImageIcon constructor used by the example in this section:
ImageIcon(String filename)
It obtains the image in the file named filename.
The icon and text associated with the label can be obtained by the following methods:
Icon getIcon( )
String getText( )
The icon and text associated with a label can be set by these methods:
void setIcon(Icon icon)
void setText(String str)
Here, icon and str are the icon and text, respectively. Therefore, using setText( ) it is possible
to change the text inside a label during program execution.
The following applet illustrates how to create and display a label containing both an
icon and a string. It begins by creating an ImageIcon object for the file france.gif, which
depicts the flag for France. This is used as the second argument to the JLabel constructor.
The first and last arguments for the JLabel constructor are the label text and the alignment.
Finally, the label is added to the content pane.
// Demonstrate JLabel and ImageIcon.
import java.awt.*;
import javax.swing.*;
/*
<applet code="JLabelDemo" width=250 height=150>
</applet>
*/
public class JLabelDemo extends JApplet 
Output from the label example is shown here:
JTextField
JTextField is the simplest Swing text component. It is also probably its most widely used text
component. JTextField allows you to edit one line of text. It is derived from JTextComponent,
which provides the basic functionality common to Swing text components. JTextField uses
the Document interface for its model.
Three of JTextField’s constructors are shown here:
JTextField(int cols)
JTextField(String str, int cols)
JTextField(String str)
Here, str is the string to be initially presented, and cols is the number of columns in the text
field. If no string is specified, the text field is initially empty. If the number of columns is not
specified, the text field is sized to fit the specified string.
JTextField generates events in response to user interaction. For example, an ActionEvent
is fired when the user presses ENTER . A CaretEvent is fired each time the caret (i.e., the
cursor) changes position. (CaretEvent is packaged in javax.swing.event.) Other events are
881882
Part III:
Software Development Using Java
also possible. In many cases, your program will not need to handle these events. Instead,
you will simply obtain the string currently in the text field when it is needed. To obtain the
text currently in the text field, call getText( ).
The following example illustrates JTextField. It creates a JTextField and adds it to the
content pane. When the user presses ENTER , an action event is generated. This is handled
by displaying the text in the status window.
// Demonstrate JTextField.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JTextFieldDemo" width=300 height=50>
</applet>
*/
public class JTextFieldDemo extends JApplet 
Output from the text field example is shown here:Chapter 30:
Exploring Swing
The Swing Buttons
Swing defines four types of buttons: JButton, JToggleButton, JCheckBox, and JRadioButton.
All are subclasses of the AbstractButton class, which extends JComponent. Thus, all
buttons share a set of common traits.
AbstractButton contains many methods that allow you to control the behavior of buttons.
For example, you can define different icons that are displayed for the button when it is
disabled, pressed, or selected. Another icon can be used as a rollover icon, which is displayed
when the mouse is positioned over a button. The following methods set these icons:
void setDisabledIcon(Icon di)
void setPressedIcon(Icon pi)
void setSelectedIcon(Icon si)
void setRolloverIcon(Icon ri)
Here, di, pi, si, and ri are the icons to be used for the indicated purpose.
The text associated with a button can be read and written via the following methods:
String getText( )
void setText(String str)
Here, str is the text to be associated with the button.
The model used by all buttons is defined by the ButtonModel interface. A button
generates an action event when it is pressed. Other events are possible. Each of the concrete
button classes is examined next.
JButton
The JButton class provides the functionality of a push button. You have already seen a
simple form of it in the preceding chapter. JButton allows an icon, a string, or both to be
associated with the push button. Three of its constructors are shown here:
JButton(Icon icon)
JButton(String str)
JButton(String str, Icon icon)
Here, str and icon are the string and icon used for the button.
When the button is pressed, an ActionEvent is generated. Using the ActionEvent object
passed to the actionPerformed( ) method of the registered ActionListener, you can obtain
the action command string associated with the button. By default, this is the string displayed
inside the button. However, you can set the action command by calling setActionCommand( )
on the button. You can obtain the action command by calling getActionCommand( ) on the
event object. It is declared like this:
String getActionCommand( )
The action command identifies the button. Thus, when using two or more buttons within
the same application, the action command gives you an easy way to determine which
button was pressed.
883884
Part III:
Software Development Using Java
In the preceding chapter, you saw an example of a text-based button. The following
demonstrates an icon-based button. It displays four push buttons and a label. Each button
displays an icon that represents the flag of a country. When a button is pressed, the name
of that country is displayed in the label.
// Demonstrate an icon-based JButton.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JButtonDemo" width=250 height=450>
</applet>
*/
public class JButtonDemo extends JApplet
implements ActionListener 
Output from the button example is shown here:
JToggleButton
A useful variation on the push button is called a
toggle button. A toggle button looks just like a push
button, but it acts differently because it has two
states: pushed and released. That is, when you press
a toggle button, it stays pressed rather than popping
back up as a regular push button does. When you
press the toggle button a second time, it releases
(pops up). Therefore, each time a toggle button is
pushed, it toggles between its two states.
Toggle buttons are objects of the JToggleButton
class. JToggleButton implements AbstractButton.
In addition to creating standard toggle buttons,
JToggleButton is a superclass for two other Swing
components that also represent two-state controls.
These are JCheckBox and JRadioButton, which are
described later in this chapter. Thus, JToggleButton
defines the basic functionality of all two-state
components.
JToggleButton defines several constructors. The
one used by the example in this section is shown here:
JToggleButton(String str)
This creates a toggle button that contains the text passed in str. By default, the button is in
the off position. Other constructors enable you to create toggle buttons that contain images,
or images and text.
885886
Part III:
Software Development Using Java
JToggleButton uses a model defined by a nested class called JToggleButton
.ToggleButtonModel. Normally, you won’t need to interact directly with the model
to use a standard toggle button.
Like JButton, JToggleButton generates an action event each time it is pressed. Unlike
JButton, however, JToggleButton also generates an item event. This event is used by those
components that support the concept of selection. When a JToggleButton is pressed in, it is
selected. When it is popped out, it is deselected.
To handle item events, you must implement the ItemListener interface. Recall from
Chapter 22, that each time an item event is generated, it is passed to the itemStateChanged( )
method defined by ItemListener. Inside itemStateChanged( ), the getItem( ) method can
be called on the ItemEvent object to obtain a reference to the JToggleButton instance that
generated the event. It is shown here:
Object getItem( )
A reference to the button is returned. You will need to cast this reference to JToggleButton.
The easiest way to determine a toggle button’s state is by calling the isSelected( ) method
(inherited from AbstractButton) on the button that generated the event. It is shown here:
boolean isSelected( )
It returns true if the button is selected and false otherwise.
Here is an example that uses a toggle button. Notice how the item listener works.
It simply calls isSelected( ) to determine the button’s state.
// Demonstrate JToggleButton.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JToggleButtonDemo" width=200 height=80>
</applet>
*/
public class JToggleButtonDemo extends JApplet 
The output from the toggle button example is shown here:
Check Boxes
The JCheckBox class provides the functionality of a check box. Its immediate superclass is
JToggleButton, which provides support for two-state buttons, as just described. JCheckBox
defines several constructors. The one used here is
JCheckBox(String str)
It creates a check box that has the text specified by str as a label. Other constructors let you
specify the initial selection state of the button and specify an icon.
887888
Part III:
Software Development Using Java
When the user selects or deselects a check box, an ItemEvent is generated. You can
obtain a reference to the JCheckBox that generated the event by calling getItem( ) on the
ItemEvent passed to the itemStateChanged( ) method defined by ItemListener. The easiest
way to determine the selected state of a check box is to call isSelected( ) on the JCheckBox
instance.
In addition to supporting the normal check box operation, JCheckBox lets you specify
the icons that indicate when a check box is selected, cleared, and rolled-over. We won’t be
using this capability here, but it is available for use in your own programs.
The following example illustrates check boxes. It displays four check boxes and a label.
When the user clicks a check box, an ItemEvent is generated. Inside the itemStateChanged( )
method, getItem( ) is called to obtain a reference to the JCheckBox object that generated the
event. Next, a call to isSelected( ) determines if the box was selected or cleared. The getText( )
method gets the text for that check box and uses it to set the text inside the label.
// Demonstrate JCheckbox.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JCheckBoxDemo" width=270 height=50>
</applet>
*/
public class JCheckBoxDemo extends JApplet
implements ItemListener 
Output from this example is shown here:
Radio Buttons
Radio buttons are a group of mutually exclusive
buttons, in which only one button can be selected at
any one time. They are supported by the JRadioButton class, which extends JToggleButton.
JRadioButton provides several constructors. The one used in the example is shown here:
JRadioButton(String str)
Here, str is the label for the button. Other constructors let you specify the initial selection
state of the button and specify an icon.
In order for their mutually exclusive nature to be activated, radio buttons must be
configured into a group. Only one of the buttons in the group can be selected at any time.
For example, if a user presses a radio button that is in a group, any previously selected
button in that group is automatically deselected. A button group is created by the ButtonGroup
class. Its default constructor is invoked for this purpose. Elements are then added to the
button group via the following method:
void add(AbstractButton ab)
Here, ab is a reference to the button to be added to the group.
A JRadioButton generates action events, item events, and change events each time the
button selection changes. Most often, it is the action event that is handled, which means
889890
Part III:
Software Development Using Java
that you will normally implement the ActionListener interface. Recall that the only method
defined by ActionListener is actionPerformed( ). Inside this method, you can use a number
of different ways to determine which button was selected. First, you can check its action
command by calling getActionCommand( ). By default, the action command is the same
as the button label, but you can set the action command to something else by calling
setActionCommand( ) on the radio button. Second, you can call getSource( ) on the
ActionEvent object and check that reference against the buttons. Finally, you can simply
check each radio button to find out which one is currently selected by calling isSelected( )
on each button. Remember, each time an action event occurs, it means that the button being
selected has changed and that one and only one button will be selected.
The following example illustrates how to use radio buttons. Three radio buttons are
created. The buttons are then added to a button group. As explained, this is necessary to cause
their mutually exclusive behavior. Pressing a radio button generates an action event, which is
handled by actionPerformed( ). Within that handler, the getActionCommand( ) method gets
the text that is associated with the radio button and uses it to set the text within a label.
// Demonstrate JRadioButton
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JRadioButtonDemo" width=300 height=50>
</applet>
*/
public class JRadioButtonDemo extends JApplet
implements ActionListener 
Output from the radio button example is shown here:
JTabbedPane
JTabbedPane encapsulates a tabbed pane. It manages a set of components by linking them
with tabs. Selecting a tab causes the component associated with that tab to come to the
forefront. Tabbed panes are very common in the modern GUI, and you have no doubt used
them many times. Given the complex nature of a tabbed pane, they are surprisingly easy to
create and use.
JTabbedPane defines three constructors. We will use its default constructor, which
creates an empty control with the tabs positioned across the top of the pane. The other two
constructors let you specify the location of the tabs, which can be along any of the four
sides. JTabbedPane uses the SingleSelectionModel model.
Tabs are added by calling addTab( ). Here is one of its forms:
void addTab(String name, Component comp)
Here, name is the name for the tab, and comp is the component that should be added to
the tab. Often, the component added to a tab is a JPanel that contains a group of related
components. This technique allows a tab to hold a set of components.
891892
Part III:
Software Development Using Java
The general procedure to use a tabbed pane is outlined here:
1. Create an instance of JTabbedPane.
2. Add each tab by calling addTab( ).
3. Add the tabbed pane to the content pane.
The following example illustrates a tabbed pane. The first tab is titled “Cities” and
contains four buttons. Each button displays the name of a city. The second tab is titled
“Colors” and contains three check boxes. Each check box displays the name of a color. The
third tab is titled “Flavors” and contains one combo box. This enables the user to select one
of three flavors.
// Demonstrate JTabbedPane.
import javax.swing.*;
/*
<applet code="JTabbedPaneDemo" width=400 height=100>
</applet>
*/
public class JTabbedPaneDemo extends JApplet 
// Make the panels that will be added to the tabbed pane.
class CitiesPanel extends JPanel 
class ColorsPanel extends JPanel 
class FlavorsPanel extends JPanel 
Output from the tabbed pane example is shown in the following three illustrations:
JScrollPane
JScrollPane is a lightweight container that automatically handles the scrolling of another
component. The component being scrolled can either be an individual component, such as
893894
Part III:
Software Development Using Java
a table, or a group of components contained within another lightweight container, such as a
JPanel. In either case, if the object being scrolled is larger than the viewable area, horizontal
and/or vertical scroll bars are automatically provided, and the component can be scrolled
through the pane. Because JScrollPane automates scrolling, it usually eliminates the need
to manage individual scroll bars.
The viewable area of a scroll pane is called the viewport. It is a window in which the
component being scrolled is displayed. Thus, the viewport displays the visible portion of the
component being scrolled. The scroll bars scroll the component through the viewport. In its
default behavior, a JScrollPane will dynamically add or remove a scroll bar as needed. For
example, if the component is taller than the viewport, a vertical scroll bar is added. If the
component will completely fit within the viewport, the scroll bars are removed.
JScrollPane defines several constructors. The one used in this chapter is shown here:
JScrollPane(Component comp)
The component to be scrolled is specified by comp. Scroll bars are automatically displayed
when the content of the pane exceeds the dimensions of the viewport.
Here are the steps to follow to use a scroll pane:
1. Create the component to be scrolled.
2. Create an instance of JScrollPane, passing to it the object to scroll.
3. Add the scroll pane to the content pane.
The following example illustrates a scroll pane. First, a JPanel object is created, and 400
buttons are added to it, arranged into 20 columns. This panel is then added to a scroll pane,
and the scroll pane is added to the content pane. Because the panel is larger than the
viewport, vertical and horizontal scroll bars appear automatically. You can use the scroll
bars to scroll the buttons into view.
// Demonstrate JScrollPane.
import java.awt.*;
import javax.swing.*;
/*
<applet code="JScrollPaneDemo" width=300 height=250>
</applet>
*/
public class JScrollPaneDemo extends JApplet 
Output from the scroll pane example is shown here:
JList
In Swing, the basic list class is called JList. It supports the selection of one or more items
from a list. Although the list often consists of strings, it is possible to create a list of just
about any object that can be displayed. JList is so widely used in Java that it is highly
unlikely that you have not seen one before.
895896
Part III:
Software Development Using Java
JList provides several constructors. The one used here is
JList(Object[ ] items)
This creates a JList that contains the items in the array specified by items.
JList is based on two models. The first is ListModel. This interface defines how access
to the list data is achieved. The second model is the ListSelectionModel interface, which
defines methods that determine what list item or items are selected.
Although a JList will work properly by itself, most of the time you will wrap a JList
inside a JScrollPane. This way, long lists will automatically be scrollable, which simplifies
GUI design. It also makes it easy to change the number of entries in a list without having to
change the size of the JList component.
A JList generates a ListSelectionEvent when the user makes or changes a selection.
This event is also generated when the user deselects an item. It is handled by implementing
ListSelectionListener. This listener specifies only one method, called valueChanged( ),
which is shown here:
void valueChanged(ListSelectionEvent le)
Here, le is a reference to the object that generated the event. Although ListSelectionEvent
does provide some methods of its own, normally you will interrogate the JList object itself
to determine what has occurred. Both ListSelectionEvent and ListSelectionListener are
packaged in javax.swing.event.
By default, a JList allows the user to select multiple ranges of items within the list, but
you can change this behavior by calling setSelectionMode( ), which is defined by JList. It is
shown here:
void setSelectionMode(int mode)
Here, mode specifies the selection mode. It must be one of these values defined by
ListSelectionModel:
SINGLE_SELECTION
SINGLE_INTERVAL_SELECTION
MULTIPLE_INTERVAL_SELECTION
The default, multiple-interval selection, lets the user select multiple ranges of items within a
list. With single-interval selection, the user can select one range of items. With single selection,
the user can select only a single item. Of course, a single item can be selected in the other
two modes, too. It’s just that they also allow a range to be selected.
You can obtain the index of the first item selected, which will also be the index of the only
selected item when using single-selection mode, by calling getSelectedIndex( ), shown here:
int getSelectedIndex( )
Indexing begins at zero. So, if the first item is selected, this method will return 0. If no item
is selected, –1 is returned.Chapter 30:
Exploring Swing
Instead of obtaining the index of a selection, you can obtain the value associated with
the selection by calling getSelectedValue( ):
Object getSelectedValue( )
It returns a reference to the first selected value. If no value has been selected, it returns null.
The following applet demonstrates a simple JList, which holds a list of cities. Each time
a city is selected in the list, a ListSelectionEvent is generated, which is handled by the
valueChanged( ) method defined by ListSelectionListener. It responds by obtaining the
index of the selected item and displaying the name of the selected city in a label.
// Demonstrate JList.
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
/*
<applet code="JListDemo" width=200 height=120>
</applet>
*/
public class JListDemo extends JApplet 
Output from the list example is shown here:
JComboBox
Swing provides a combo box (a combination of a text field and a drop-down list) through
the JComboBox class. A combo box normally displays one entry, but it will also display a
drop-down list that allows a user to select a different entry. You can also create a combo boxChapter 30:
Exploring Swing
that lets the user enter a selection into the text field. The JComboBox constructor used by
the example is shown here:
JComboBox(Object[ ] items)
Here, items is an array that initializes the combo box. Other constructors are available.
JComboBox uses the ComboBoxModel. Mutable combo boxes (those whose entries can
be changed) use the MutableComboBoxModel.
In addition to passing an array of items to be displayed in the drop-down list, items can
be dynamically added to the list of choices via the addItem( ) method, shown here:
void addItem(Object obj)
Here, obj is the object to be added to the combo box. This method must be used only with
mutable combo boxes.
JComboBox generates an action event when the user selects an item from the list.
JComboBox also generates an item event when the state of selection changes, which occurs
when an item is selected or deselected. Thus, changing a selection means that two item
events will occur: one for the deselected item and another for the selected item. Often, it is
sufficient to simply listen for action events, but both event types are available for your use.
One way to obtain the item selected in the list is to call getSelectedItem( ) on the combo
box. It is shown here:
Object getSelectedItem( )
You will need to cast the returned value into the type of object stored in the list.
The following example demonstrates the combo box. The combo box contains entries
for “France,” “Germany,” “Italy,” and “Japan.” When a country is selected, an icon-based
label is updated to display the flag for that country. You can see how little code is required
to use this powerful component.
// Demonstrate JComboBox.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
/*
<applet code="JComboBoxDemo" width=300 height=100>
</applet>
*/
public class JComboBoxDemo extends JApplet 
Output from the combo box example is shown here:
Trees
A tree is a component that presents a hierarchical view of data. The user has the ability to
expand or collapse individual subtrees in this display. Trees are implemented in Swing by
the JTree class. A sampling of its constructors is shown here:
JTree(Object obj[ ])
JTree(Vector<?> v)
JTree(TreeNode tn)Chapter 30:
Exploring Swing
In the first form, the tree is constructed from the elements in the array obj. The second form
constructs the tree from the elements of vector v. In the third form, the tree whose root node
is specified by tn specifies the tree.
Although JTree is packaged in javax.swing, its support classes and interfaces are
packaged in javax.swing.tree. This is because the number of classes and interfaces needed
to support JTree is quite large.
JTree relies on two models: TreeModel and TreeSelectionModel. A JTree generates a
variety of events, but three relate specifically to trees: TreeExpansionEvent,
TreeSelectionEvent, and TreeModelEvent. TreeExpansionEvent events occur when a node
is expanded or collapsed. A TreeSelectionEvent is generated when the user selects or
deselects a node within the tree. A TreeModelEvent is fired when the data or structure of the
tree changes. The listeners for these events are TreeExpansionListener, TreeSelectionListener,
and TreeModelListener, respectively. The tree event classes and listener interfaces are
packaged in javax.swing.event.
The event handled by the sample program shown in this section is TreeSelectionEvent.
To listen for this event, implement TreeSelectionListener. It defines only one method, called
valueChanged( ), which receives the TreeSelectionEvent object. You can obtain the path to
the selected object by calling getPath( ), shown here, on the event object.
TreePath getPath( )
It returns a TreePath object that describes the path to the changed node. The TreePath class
encapsulates information about a path to a particular node in a tree. It provides several
constructors and methods. In this book, only the toString( ) method is used. It returns a
string that describes the path.
The TreeNode interface declares methods that obtain information about a tree node.
For example, it is possible to obtain a reference to the parent node or an enumeration of the
child nodes. The MutableTreeNode interface extends TreeNode. It declares methods that
can insert and remove child nodes or change the parent node.
The DefaultMutableTreeNode class implements the MutableTreeNode interface. It
represents a node in a tree. One of its constructors is shown here:
DefaultMutableTreeNode(Object obj)
Here, obj is the object to be enclosed in this tree node. The new tree node doesn’t have a
parent or children.
To create a hierarchy of tree nodes, the add( ) method of DefaultMutableTreeNode can
be used. Its signature is shown here:
void add(MutableTreeNode child)
Here, child is a mutable tree node that is to be added as a child to the current node.
JTree does not provide any scrolling capabilities of its own. Instead, a JTree is typically
placed within a JScrollPane. This way, a large tree can be scrolled through a smaller viewport.
Here are the steps to follow to use a tree:
1. Create an instance of JTree.
2. Create a JScrollPane and specify the tree as the object to be scrolled.
3. Add the tree to the scroll pane.
4. Add the scroll pane to the content pane.
901902
Part III:
Software Development Using Java
The following example illustrates how to create a tree and handle selections. The
program creates a DefaultMutableTreeNode instance labeled “Options.” This is the top
node of the tree hierarchy. Additional tree nodes are then created, and the add( ) method is
called to connect these nodes to the tree. A reference to the top node in the tree is provided
as the argument to the JTree constructor. The tree is then provided as the argument to the
JScrollPane constructor. This scroll pane is then added to the content pane. Next, a label
is created and added to the content pane. The tree selection is displayed in this label. To
receive selection events from the tree, a TreeSelectionListener is registered for the tree.
Inside the valueChanged( ) method, the path to the current selection is obtained and
displayed.
// Demonstrate JTree.
import java.awt.*;
import javax.swing.event.*;
import javax.swing.*;
import javax.swing.tree.*;
/*
<applet code="JTreeDemo" width=400 height=200>
</applet>
*/
public class JTreeDemo extends JApplet 
Output from the tree example is shown here:
The string presented in the text field describes the path from the top tree node to the
selected node.
903904
Part III:
Software Development Using Java
JTable
JTable is a component that displays rows and columns of data. You can drag the cursor
on column boundaries to resize columns. You can also drag a column to a new position.
Depending on its configuration, it is also possible to select a row, column, or cell within the
table, and to change the data within a cell. JTable is a sophisticated component that offers
many more options and features than can be discussed here. (It is perhaps Swing’s most
complicated component.) However, in its default configuration, JTable still offers
substantial functionality that is easy to use—especially if you simply want to use the
table to present data in a tabular format. The brief overview presented here will give
you a general understanding of this powerful component.
Like JTree, JTable has many classes and interfaces associated with it. These are
packaged in javax.swing.table.
At its core, JTable is conceptually simple. It is a component that consists of one or more
columns of information. At the top of each column is a heading. In addition to describing
the data in a column, the heading also provides the mechanism by which the user can
change the size of a column or change the location of a column within the table. JTable does
not provide any scrolling capabilities of its own. Instead, you will normally wrap a JTable
inside a JScrollPane.
JTable supplies several constructors. The one used here is
JTable(Object data[ ][ ], Object colHeads[ ])
Here, data is a two-dimensional array of the information to be presented, and colHeads is a
one-dimensional array with the column headings.
JTable relies on three models. The first is the table model, which is defined by the
TableModel interface. This model defines those things related to displaying data in a
two-dimensional format. The second is the table column model, which is represented by
TableColumnModel. JTable is defined in terms of columns, and it is TableColumnModel that
specifies the characteristics of a column. These two models are packaged in javax.swing.table.
The third model determines how items are selected, and it is specified by the
ListSelectionModel, which was described when JList was discussed.
A JTable can generate several different events. The two most fundamental to a table’s
operation are ListSelectionEvent and TableModelEvent. A ListSelectionEvent is generated
when the user selects something in the table. By default, JTable allows you to select one or
more complete rows, but you can change this behavior to allow one or more columns, or
one or more individual cells to be selected. A TableModelEvent is fired when that table’s
data changes in some way. Handling these events requires a bit more work than it does to
handle the events generated by the previously described components and is beyond the
scope of this book. However, if you simply want to use JTable to display data (as the
following example does), then you don’t need to handle any events.
Here are the steps required to set up a simple JTable that can be used to display data:
1. Create an instance of JTable.
2. Create a JScrollPane object, specifying the table as the object to scroll.
3. Add the table to the scroll pane.
4. Add the scroll pane to the content pane.Chapter 30:
Exploring Swing
The following example illustrates how to create and use a simple table. A one-dimensional
array of strings called colHeads is created for the column headings. A two-dimensional array
of strings called data is created for the table cells. You can see that each element in the array
is an array of three strings. These arrays are passed to the JTable constructor. The table is
added to a scroll pane, and then the scroll pane is added to the content pane. The table
displays the data in the data array. The default table configuration also allows the contents
of a cell to be edited. Changes affect the underlying array, which is data in this case.
// Demonstrate JTable.
import java.awt.*;
import javax.swing.*;
/*
<applet code="JTableDemo" width=400 height=200>
</applet>
*/
public class JTableDemo extends JApplet 
Output from this example is shown here:
Continuing Your Exploration of Swing
Swing defines a very large GUI toolkit. It has many more features that you will want to
explore on your own. For example, Swing provides toolbars, tooltips, and progress bars.
It also provides a complete menu subsystem. Swing’s pluggable look and feel lets you
substitute another appearance and behavior for an element. You can define your own
models for the various components, and you can change the way that cells are edited
and rendered when working with tables and trees. The best way to become familiar with
Swing’s capabilities is to experiment with it.31
Servlets
T
his chapter presents an overview of servlets. Servlets are small programs that execute on
the server side of a web connection. Just as applets dynamically extend the functionality
of a web browser, servlets dynamically extend the functionality of a web server. The
topic of servlets is quite large, and it is beyond the scope of this chapter to cover it all. Instead,
we will focus on the core concepts, interfaces, and classes, and develop several examples.
Background
In order to understand the advantages of servlets, you must have a basic understanding of
how web browsers and servers cooperate to provide content to a user. Consider a request
for a static web page. A user enters a Uniform Resource Locator (URL) into a browser. The
browser generates an HTTP request to the appropriate web server. The web server maps
this request to a specific file. That file is returned in an HTTP response to the browser. The
HTTP header in the response indicates the type of the content. The Multipurpose Internet
Mail Extensions (MIME) are used for this purpose. For example, ordinary ASCII text has a
MIME type of text/plain. The Hypertext Markup Language (HTML) source code of a web
page has a MIME type of text/html.
Now consider dynamic content. Assume that an online store uses a database to store
information about its business. This would include items for sale, prices, availability, orders,
and so forth. It wishes to make this information accessible to customers via web pages. The
contents of those web pages must be dynamically generated to reflect the latest information
in the database.
In the early days of the Web, a server could dynamically construct a page by creating a
separate process to handle each client request. The process would open connections to one
or more databases in order to obtain the necessary information. It communicated with the
web server via an interface known as the Common Gateway Interface (CGI). CGI allowed
the separate process to read data from the HTTP request and write data to the HTTP response.
A variety of different languages were used to build CGI programs. These included C, C++,
and Perl.
However, CGI suffered serious performance problems. It was expensive in terms of
processor and memory resources to create a separate process for each client request. It was
also expensive to open and close database connections for each client request. In addition,
907908
Part III:
Software Development Using Java
the CGI programs were not platform-independent. Therefore, other techniques were
introduced. Among these are servlets.
Servlets offer several advantages in comparison with CGI. First, performance is significantly
better. Servlets execute within the address space of a web server. It is not necessary to create
a separate process to handle each client request. Second, servlets are platform-independent
because they are written in Java. Third, the Java security manager on the server enforces a
set of restrictions to protect the resources on a server machine. Finally, the full functionality
of the Java class libraries is available to a servlet. It can communicate with applets, databases,
or other software via the sockets and RMI mechanisms that you have seen already.
The Life Cycle of a Servlet
Three methods are central to the life cycle of a servlet. These are init( ), service( ), and destroy( ).
They are implemented by every servlet and are invoked at specific times by the server. Let
us consider a typical user scenario to understand when these methods are called.
First, assume that a user enters a Uniform Resource Locator (URL) to a web browser.
The browser then generates an HTTP request for this URL. This request is then sent to the
appropriate server.
Second, this HTTP request is received by the web server. The server maps this request to
a particular servlet. The servlet is dynamically retrieved and loaded into the address space
of the server.
Third, the server invokes the init( ) method of the servlet. This method is invoked only
when the servlet is first loaded into memory. It is possible to pass initialization parameters
to the servlet so it may configure itself.
Fourth, the server invokes the service( ) method of the servlet. This method is called to
process the HTTP request. You will see that it is possible for the servlet to read data that has
been provided in the HTTP request. It may also formulate an HTTP response for the client.
The servlet remains in the server’s address space and is available to process any other
HTTP requests received from clients. The service( ) method is called for each HTTP request.
Finally, the server may decide to unload the servlet from its memory. The algorithms by
which this determination is made are specific to each server. The server calls the destroy( )
method to relinquish any resources such as file handles that are allocated for the servlet.
Important data may be saved to a persistent store. The memory allocated for the servlet and
its objects can then be garbage collected.
Using Tomcat for Servlet Development
To create servlets, you will need access to a servlet development environment. The one used
by this chapter is Tomcat. Tomcat is an open-source product maintained by the Jakarta Project
of the Apache Software Foundation. It contains the class libraries, documentation, and run-
time support that you will need to create and test servlets. At the time of this writing, the
current version is 5.5.17, which supports servlet specification 2.4. You can download Tomcat
from jakarta.apache.org.
The examples in this chapter assume a Windows environment. The default location for
Tomcat 5.5.17 is
C:\Program Files\Apache Software Foundation\Tomcat 5.5\Chapter 31:
Servlets
This is the location assumed by the examples in this book. If you load Tomcat in a different
location, you will need to make appropriate changes to the examples. You may need to set
the environmental variable JAVA_HOME to the top-level directory in which the Java
Development Kit is installed.
To start Tomcat, select Configure Tomcat in the Start | Programs menu, and then press
Start in the Tomcat Properties dialog.
When you are done testing servlets, you can stop Tomcat by pressing Stop in the Tomcat
Properties dialog.
The directory
C:\Program Files\Apache Software Foundation\Tomcat 5.5\common\lib\
contains servlet-api.jar. This JAR file contains the classes and interfaces that are needed to
build servlets. To make this file accessible, update your CLASSPATH environment
variable so that it includes
C:\Program Files\Apache Software Foundation\Tomcat 5.5\common\lib\servlet-api.jar
Alternatively, you can specify this file when you compile the servlets. For example, the
following command compiles the first servlet example:
javac HelloServlet.java -classpath "C:\Program Files\Apache Software Foundation\
Tomcat 5.5\common\lib\servlet-api.jar"
Once you have compiled a servlet, you must enable Tomcat to find it. This means putting
it into a directory under Tomcat’s webapps directory and entering its name into a web.xml
file. To keep things simple, the examples in this chapter use the directory and web.xml file
that Tomcat supplies for its own example servlets. Here is the procedure that you will follow.
First, copy the servlet’s class file into the following directory:
C:\Program Files\Apache Software Foundation\Tomcat 5.5\webapps\servlets-examples\WEB-INF\classes
Next, add the servlet’s name and mapping to the web.xml file in the following directory:
C:\Program Files\Apache Software Foundation\Tomcat 5.5\webapps\servlets-examples\WEB-INF
For instance, assuming the first example, called HelloServlet, you will add the following
lines in the section that defines the servlets:
<servlet>
<servlet-name>HelloServlet</servlet-name>
<servlet-class>HelloServlet</servlet-class>
</servlet>
Next, you will add the following lines to the section that defines the servlet mappings.
<servlet-mapping>
<servlet-name>HelloServlet</servlet-name>
<url-pattern>/servlet/HelloServlet</url-pattern>
</servlet-mapping>
Follow this same general procedure for all of the examples.
909910
Part III:
Software Development Using Java
A Simple Servlet
To become familiar with the key servlet concepts, we will begin by building and testing
a simple servlet. The basic steps are the following:
1. Create and compile the servlet source code. Then, copy the servlet’s class file to the
proper directory, and add the servlet’s name and mappings to the proper web.xml file.
2. Start Tomcat.
3. Start a web browser and request the servlet.
Let us examine each of these steps in detail.
Create and Compile the Servlet Source Code
To begin, create a file named HelloServlet.java that contains the following program:
import java.io.*;
import javax.servlet.*;
public class HelloServlet extends GenericServlet 
Let’s look closely at this program. First, note that it imports the javax.servlet package.
This package contains the classes and interfaces required to build servlets. You will learn
more about these later in this chapter. Next, the program defines HelloServlet as a subclass of
GenericServlet. The GenericServlet class provides functionality that simplifies the creation
of a servlet. For example, it provides versions of init( ) and destroy( ), which may be used
as is. You need supply only the service( ) method.
Inside HelloServlet, the service( ) method (which is inherited from GenericServlet) is
overridden. This method handles requests from a client. Notice that the first argument is a
ServletRequest object. This enables the servlet to read data that is provided via the client
request. The second argument is a ServletResponse object. This enables the servlet to formulate
a response for the client.
The call to setContentType( ) establishes the MIME type of the HTTP response. In this
program, the MIME type is text/html. This indicates that the browser should interpret the
content as HTML source code.
Next, the getWriter( ) method obtains a PrintWriter. Anything written to this stream is
sent to the client as part of the HTTP response. Then println( ) is used to write some simple
HTML source code as the HTTP response.
Compile this source code and place the HelloServlet.class file in the proper Tomcat
directory as described in the previous section. Also, add HelloServlet to the web.xml file,
as described earlier.Chapter 31:
Servlets
Start Tomcat
Start Tomcat as explained earlier. Tomcat must be running before you try to execute a servlet.
Start a Web Browser and Request the Servlet
Start a web browser and enter the URL shown here:
http://localhost:8080/servlets-examples/servlet/HelloServlet
Alternatively, you may enter the URL shown here:
http://127.0.0.1:8080/servlets-examples/servlet/HelloServlet
This can be done because 127.0.0.1 is defined as the IP address of the local machine.
You will observe the output of the servlet in the browser display area. It will contain the
string Hello! in bold type.
The Servlet API
Two packages contain the classes and interfaces that are required to build servlets. These are
javax.servlet and javax.servlet.http. They constitute the Servlet API. Keep in mind that these
packages are not part of the Java core packages. Instead, they are standard extensions provided
by Tomcat. Therefore, they are not included with Java SE 6.
The Servlet API has been in a process of ongoing development and enhancement. The
current servlet specification is version 2.4, and that is the one used in this book. However,
because changes happen fast in the world of Java, you will want to check for any additions
or alterations. This chapter discusses the core of the Servlet API, which will be available to
most readers.
The javax.servlet Package
The javax.servlet package contains a number of interfaces and classes that establish the
framework in which servlets operate. The following table summarizes the core interfaces
that are provided in this package. The most significant of these is Servlet. All servlets must
implement this interface or extend a class that implements the interface. The ServletRequest
and ServletResponse interfaces are also very important.
Interface Description
Servlet Declares life cycle methods for a servlet.
ServletConfig Allows servlets to get initialization parameters.
ServletContext Enables servlets to log events and access information about their
environment.
ServletRequest Used to read data from a client request.
ServletResponse Used to write data to a client response.
911912
Part III:
Software Development Using Java
The following table summarizes the core classes that are provided in the javax.servlet
package:
Class Description
GenericServlet Implements the Servlet and ServletConfig interfaces.
ServletInputStream Provides an input stream for reading requests from a client.
ServletOutputStream Provides an output stream for writing responses to a client.
ServletException Indicates a servlet error occurred.
UnavailableException Indicates a servlet is unavailable.
Let us examine these interfaces and classes in more detail.
The Servlet Interface
All servlets must implement the Servlet interface. It declares the init( ), service( ), and destroy( )
methods that are called by the server during the life cycle of a servlet. A method is also provided
that allows a servlet to obtain any initialization parameters. The methods defined by Servlet
are shown in Table 31-1.
The init( ), service( ), and destroy( ) methods are the life cycle methods of the servlet.
These are invoked by the server. The getServletConfig( ) method is called by the servlet to
obtain initialization parameters. A servlet developer overrides the getServletInfo( ) method
to provide a string with useful information (for example, author, version, date, copyright).
This method is also invoked by the server.
The ServletConfig Interface
The ServletConfig interface allows a servlet to obtain configuration data when it is loaded.
The methods declared by this interface are summarized here:
Method
Description
ServletContext getServletContext( ) Returns the context for this servlet.
String getInitParameter(String param) Returns the value of the initialization parameter
named param.
Enumeration getInitParameterNames( ) Returns an enumeration of all initialization parameter
names.
String getServletName( ) Returns the name of the invoking servlet.
The ServletContext Interface
The ServletContext interface enables servlets to obtain information about their environment.
Several of its methods are summarized in Table 31-2.Chapter 31:
Servlets
Method Description
void destroy( ) Called when the servlet is unloaded.
ServletConfig getServletConfig( ) Returns a ServletConfig object that contains any initialization
parameters.
String getServletInfo( ) Returns a string describing the servlet.
void init(ServletConfig sc)
throws ServletException Called when the servlet is initialized. Initialization
parameters for the servlet can be obtained from sc.
An UnavailableException should be thrown if the
servlet cannot be initialized.
void service(ServletRequest req,
ServletResponse res)
throws ServletException,
IOException Called to process a request from a client. The request from
the client can be read from req. The response to the client
can be written to res. An exception is generated if a servlet
or IO problem occurs.
T ABLE 31-1
The Methods Defined by Servlet
The ServletRequest Interface
The ServletRequest interface enables a servlet to obtain information about a client request.
Several of its methods are summarized in Table 31-3.
The ServletResponse Interface
The ServletResponse interface enables a servlet to formulate a response for a client. Several
of its methods are summarized in Table 31-4.
Method Description
Object getAttribute(String attr) Returns the value of the server attribute named attr.
String getMimeType(String file) Returns the MIME type of file.
String getRealPath(String vpath) Returns the real path that corresponds to the virtual
path vpath.
String getServerInfo( ) Returns information about the server.
void log(String s) Writes s to the servlet log.
void log(String s, Throwable e) Writes s and the stack trace for e to the servlet log.
void setAttribute(String attr, Object val) Sets the attribute specified by attr to the value
passed in val.
T ABLE 31-2
Various Methods Defined by ServletContext
913914
Part III:
Software Development Using Java
Method
Description
Object getAttribute(String attr) Returns the value of the attribute named attr.
String getCharacterEncoding( ) Returns the character encoding of the request.
int getContentLength( ) Returns the size of the request. The value –1 is returned if the
size is unavailable.
String getContentType( ) Returns the type of the request. A null value is returned if the
type cannot be determined.
ServletInputStream getInputStream( )
throws IOException Returns a ServletInputStream that can be used to read binary
data from the request. An IllegalStateException is thrown if
getReader( ) has already been invoked for this request.
String getParameter(String pname) Returns the value of the parameter named pname.
Enumeration getParameterNames( ) Returns an enumeration of the parameter names for this request.
String[ ] getParameterValues(String name) Returns an array containing values associated with the parameter
specified by name.
String getProtocol( ) Returns a description of the protocol.
BufferedReader getReader( )
throws IOException Returns a buffered reader that can be used to read text from the
request. An IllegalStateException is thrown if getInputStream( )
has already been invoked for this request.
String getRemoteAddr( ) Returns the string equivalent of the client IP address.
String getRemoteHost( ) Returns the string equivalent of the client host name.
String getScheme( ) Returns the transmission scheme of the URL used for the request
(for example, “http”, “ftp”).
String getServerName( ) Returns the name of the server.
int getServerPort( ) Returns the port number.
T ABLE 31-3
Various Methods Defined by ServletRequest
The GenericServlet Class
The GenericServlet class provides implementations of the basic life cycle methods for a servlet.
GenericServlet implements the Servlet and ServletConfig interfaces. In addition, a method to
append a string to the server log file is available. The signatures of this method are shown here:
void log(String s)
void log(String s, Throwable e)
Here, s is the string to be appended to the log, and e is an exception that occurred.
Method Description
String getCharacterEncoding( ) Returns the character encoding for the response.
ServletOutputStream
getOutputStream( )
throws IOException Returns a ServletOutputStream that can be used to write binary data to the
response. An IllegalStateException is thrown if getWriter( ) has already
been invoked for this request.
PrintWriter getWriter( )
throws IOException Returns a PrintWriter that can be used to write character data to the
response. An IllegalStateException is thrown if getOutputStream( )
has already been invoked for this request.
void setContentLength(int size) Sets the content length for the response to size.
void setContentType(String type) Sets the content type for the response to type.
T ABLE 31-4
Various Methods Defined by ServletResponseChapter 31:
Servlets
The ServletInputStream Class
The ServletInputStream class extends InputStream. It is implemented by the servlet container
and provides an input stream that a servlet developer can use to read the data from a client
request. It defines the default constructor. In addition, a method is provided to read bytes
from the stream. It is shown here:
int readLine(byte[ ] buffer, int offset, int size) throws IOException
Here, buffer is the array into which size bytes are placed starting at offset. The method returns
the actual number of bytes read or –1 if an end-of-stream condition is encountered.
The ServletOutputStream Class
The ServletOutputStream class extends OutputStream. It is implemented by the servlet
container and provides an output stream that a servlet developer can use to write data to a
client response. A default constructor is defined. It also defines the print( ) and println( )
methods, which output data to the stream.
The Servlet Exception Classes
javax.servlet defines two exceptions. The first is ServletException, which indicates that a servlet
problem has occurred. The second is UnavailableException, which extends ServletException.
It indicates that a servlet is unavailable.
Reading Servlet Parameters
The ServletRequest interface includes methods that allow you to read the names and values
of parameters that are included in a client request. We will develop a servlet that illustrates
their use. The example contains two files. A web page is defined in PostParameters.htm, and
a servlet is defined in PostParametersServlet.java.
The HTML source code for PostParameters.htm is shown in the following listing. It defines
a table that contains two labels and two text fields. One of the labels is Employee and the
other is Phone. There is also a submit button. Notice that the action parameter of the form
tag specifies a URL. The URL identifies the servlet to process the HTTP POST request.
<html>
<body>
<center>
<form name="Form1"
method="post"
action="http://localhost:8080/servlets-examples/
servlet/PostParametersServlet">
<table>
<tr>
<td><B>Employee</td>
<td><input type=textbox name="e" size="25" value=""></td>
</tr>
<tr>
<td><B>Phone</td>
<td><input type=textbox name="p" size="25" value=""></td>
</tr>
</table>
915916
Part III:
Software Development Using Java
<input type=submit value="Submit">
</body>
</html>
The source code for PostParametersServlet.java is shown in the following listing. The
service( ) method is overridden to process client requests. The getParameterNames( ) method
returns an enumeration of the parameter names. These are processed in a loop. You can see
that the parameter name and value are output to the client. The parameter value is obtained
via the getParameter( ) method.
import java.io.*;
import java.util.*;
import javax.servlet.*;
public class PostParametersServlet
extends GenericServlet 
Compile the servlet. Next, copy it to the appropriate directory, and update the web.xml
file, as previously described. Then, perform these steps to test this example:
1. Start Tomcat (if it is not already running).
2. Display the web page in a browser.
3. Enter an employee name and phone number in the text fields.
4. Submit the web page.
After following these steps, the browser will display a response that is dynamically generated
by the servlet.Chapter 31:
Servlets
The javax.servlet.http Package
The javax.servlet.http package contains a number of interfaces and classes that are commonly
used by servlet developers. You will see that its functionality makes it easy to build servlets
that work with HTTP requests and responses.
The following table summarizes the core interfaces that are provided in this package:
Interface Description
HttpServletRequest Enables servlets to read data from an HTTP request.
HttpServletResponse Enables servlets to write data to an HTTP response.
HttpSession Allows session data to be read and written.
HttpSessionBindingListener Informs an object that it is bound to or unbound from a session.
The following table summarizes the core classes that are provided in this package. The
most important of these is HttpServlet. Servlet developers typically extend this class in
order to process HTTP requests.
Class Description
Cookie Allows state information to be stored on a client machine.
HttpServlet Provides methods to handle HTTP requests and responses.
HttpSessionEvent Encapsulates a session-changed event.
HttpSessionBindingEvent Indicates when a listener is bound to or unbound from a session
value, or that a session attribute changed.
The HttpServletRequest Interface
The HttpServletRequest interface enables a servlet to obtain information about a client
request. Several of its methods are shown in Table 31-5.
The HttpServletResponse Interface
The HttpServletResponse interface enables a servlet to formulate an HTTP response to a
client. Several constants are defined. These correspond to the different status codes that can
be assigned to an HTTP response. For example, SC_OK indicates that the HTTP request
succeeded, and SC_NOT_FOUND indicates that the requested resource is not available.
Several methods of this interface are summarized in Table 31-6.
The HttpSession Interface
The HttpSession interface enables a servlet to read and write the state information that is
associated with an HTTP session. Several of its methods are summarized in Table 31-7. All of
these methods throw an IllegalStateException if the session has already been invalidated.
917918
Part III:
Software Development Using Java
Method
Description
String getAuthType( ) Returns authentication scheme.
Cookie[ ] getCookies( ) Returns an array of the cookies in this request.
long getDateHeader(String field) Returns the value of the date header field named field.
String getHeader(String field) Returns the value of the header field named field.
Enumeration getHeaderNames( ) Returns an enumeration of the header names.
int getIntHeader(String field) Returns the int equivalent of the header field named field.
String getMethod( ) Returns the HTTP method for this request.
String getPathInfo( ) Returns any path information that is located after the servlet path
and before a query string of the URL.
String getPathTranslated( ) Returns any path information that is located after the servlet path
and before a query string of the URL after translating it to a real
path.
String getQueryString( ) Returns any query string in the URL.
String getRemoteUser( ) Returns the name of the user who issued this request.
String getRequestedSessionId( ) Returns the ID of the session.
String getRequestURI( ) Returns the URI.
StringBuffer getRequestURL( ) Returns the URL.
String getServletPath( ) Returns that part of the URL that identifies the servlet.
HttpSession getSession( ) Returns the session for this request. If a session does not exist,
one is created and then returned.
HttpSession getSession(boolean new) If new is true and no session exists, creates and returns a session
for this request. Otherwise, returns the existing session for this
request.
boolean
Returns true if a cookie contains the session ID. Otherwise, returns
isRequestedSessionIdFromCookie( ) false.
boolean
isRequestedSessionIdFromURL( ) Returns true if the URL contains the session ID. Otherwise, returns
false.
boolean isRequestedSessionIdValid( ) Returns true if the requested session ID is valid in the current
session context.
T ABLE 31-5
Various Methods Defined by HttpServletRequest
Method Description
void addCookie(Cookie cookie) Adds cookie to the HTTP response.
boolean containsHeader(String field) Returns true if the HTTP response header contains a field
named field.
String encodeURL(String url) Determines if the session ID must be encoded in the URL
identified as url. If so, returns the modified version of url.
Otherwise, returns url. All URLs generated by a servlet should
be processed by this method.
String encodeRedirectURL(String url) Determines if the session ID must be encoded in the URL
identified as url. If so, returns the modified version of url.
Otherwise, returns url. All URLs passed to sendRedirect( )
should be processed by this method.
T ABLE 31-6
Various Methods Defined by HttpServletResponseChapter 31:
Servlets
Method Description
void sendError(int c)
throws IOException Sends the error code c to the client.
void sendError(int c, String s)
throws IOException Sends the error code c and message s to the client.
void sendRedirect(String url)
throws IOException Redirects the client to url.
void setDateHeader(String field, long msec) Adds field to the header with date value equal to msec
(milliseconds since midnight, January 1, 1970, GMT).
void setHeader(String field, String value) Adds field to the header with value equal to value.
void setIntHeader(String field, int value) Adds field to the header with value equal to value.
void setStatus(int code) Sets the status code for this response to code.
T ABLE 31-6
Various Methods Defined by HttpServletResponse (continued)
The HttpSessionBindingListener Interface
The HttpSessionBindingListener interface is implemented by objects that need to be
notified when they are bound to or unbound from an HTTP session. The methods that are
invoked when an object is bound or unbound are
void valueBound(HttpSessionBindingEvent e)
void valueUnbound(HttpSessionBindingEvent e)
Here, e is the event object that describes the binding.
The Cookie Class
The Cookie class encapsulates a cookie. A cookie is stored on a client and contains state
information. Cookies are valuable for tracking user activities. For example, assume that a
Method Description
Object getAttribute(String attr) Returns the value associated with the name passed in attr. Returns
null if attr is not found.
Enumeration getAttributeNames( ) Returns an enumeration of the attribute names associated with the
session.
long getCreationTime( ) Returns the time (in milliseconds since midnight, January 1, 1970,
GMT) when this session was created.
String getId( ) Returns the session ID.
long getLastAccessedTime( ) Returns the time (in milliseconds since midnight, January 1, 1970,
GMT) when the client last made a request for this session.
void invalidate( ) Invalidates this session and removes it from the context.
boolean isNew( ) Returns true if the server created the session and it has not yet
been accessed by the client.
void removeAttribute(String attr) Removes the attribute specified by attr from the session.
void setAttribute(String attr, Object val) Associates the value passed in val with the attribute name passed
in attr.
T ABLE 31-7
The Methods Defined by HttpSession
919920
Part III:
Software Development Using Java
user visits an online store. A cookie can save the user’s name, address, and other information.
The user does not need to enter this data each time he or she visits the store.
A servlet can write a cookie to a user’s machine via the addCookie( ) method of the
HttpServletResponse interface. The data for that cookie is then included in the header of
the HTTP response that is sent to the browser.
The names and values of cookies are stored on the user’s machine. Some of the information
that is saved for each cookie includes the following:
•
•
•
•
The name of the cookie
The value of the cookie
The expiration date of the cookie
The domain and path of the cookie
The expiration date determines when this cookie is deleted from the user’s machine. If
an expiration date is not explicitly assigned to a cookie, it is deleted when the current browser
session ends. Otherwise, the cookie is saved in a file on the user’s machine.
The domain and path of the cookie determine when it is included in the header of an
HTTP request. If the user enters a URL whose domain and path match these values, the cookie
is then supplied to the Web server. Otherwise, it is not.
There is one constructor for Cookie. It has the signature shown here:
Cookie(String name, String value)
Here, the name and value of the cookie are supplied as arguments to the constructor. The
methods of the Cookie class are summarized in Table 31-8.
Method Description
Object clone( ) Returns a copy of this object.
String getComment( ) Returns the comment.
String getDomain( ) Returns the domain.
int getMaxAge( ) Returns the maximum age (in seconds).
String getName( ) Returns the name.
String getPath( ) Returns the path.
boolean getSecure( ) Returns true if the cookie is secure. Otherwise, returns false.
String getValue( ) Returns the value.
int getVersion( ) Returns the version.
void setComment(String c) Sets the comment to c.
void setDomain(String d) Sets the domain to d.
void setMaxAge(int secs) Sets the maximum age of the cookie to secs. This is the
number of seconds after which the cookie is deleted.
void setPath(String p) Sets the path to p.
void setSecure(boolean secure) Sets the security flag to secure.
void setValue(String v) Sets the value to v.
void setVersion(int v) Sets the version to v.
T ABLE 31-8
The Methods Defined by CookieChapter 31:
Servlets
The HttpServlet Class
The HttpServlet class extends GenericServlet. It is commonly used when developing servlets
that receive and process HTTP requests. The methods of the HttpServlet class are summarized
in Table 31-9.
The HttpSessionEvent Class
HttpSessionEvent encapsulates session events. It extends EventObject and is generated when
a change occurs to the session. It defines this constructor:
HttpSessionEvent(HttpSession session)
Here, session is the source of the event.
HttpSessionEvent defines one method, getSession( ), which is shown here:
HttpSession getSession( )
It returns the session in which the event occurred.
Method Description
void doDelete(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException Handles an HTTP DELETE request.
void doGet(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException Handles an HTTP GET request.
void doHead(HttpServletRequest req,
HttpServletResponse res)
throws IOException,
ServletException Handles an HTTP HEAD request.
void doOptions(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException Handles an HTTP OPTIONS request.
void doPost(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException Handles an HTTP POST request.
void doPut(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException Handles an HTTP PUT request.
void doTrace(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException Handles an HTTP TRACE request.
long
Returns the time (in milliseconds since midnight, January 1,
getLastModified(HttpServletRequest req) 1970, GMT) when the requested resource was last modified.
void service(HttpServletRequest req,
HttpServletResponse res)
throws IOException, ServletException
T ABLE 31-9
Called by the server when an HTTP request arrives for this
servlet. The arguments provide access to the HTTP request and
response, respectively.
The Methods Defined by HttpServlet
921922
Part III:
Software Development Using Java
The HttpSessionBindingEvent Class
The HttpSessionBindingEvent class extends HttpSessionEvent. It is generated when a listener
is bound to or unbound from a value in an HttpSession object. It is also generated when an
attribute is bound or unbound. Here are its constructors:
HttpSessionBindingEvent(HttpSession session, String name)
HttpSessionBindingEvent(HttpSession session, String name, Object val)
Here, session is the source of the event, and name is the name associated with the object that is
being bound or unbound. If an attribute is being bound or unbound, its value is passed in val.
The getName( ) method obtains the name that is being bound or unbound. It is shown
here:
String getName( )
The getSession( ) method, shown next, obtains the session to which the listener is being
bound or unbound:
HttpSession getSession( )
The getValue( ) method obtains the value of the attribute that is being bound or unbound.
It is shown here:
Object getValue( )
Handling HTTP Requests and Responses
The HttpServlet class provides specialized methods that handle the various types of HTTP
requests. A servlet developer typically overrides one of these methods. These methods are
doDelete( ), doGet( ), doHead( ), doOptions( ), doPost( ), doPut( ), and doTrace( ). A complete
description of the different types of HTTP requests is beyond the scope of this book. However,
the GET and POST requests are commonly used when handling form input. Therefore, this
section presents examples of these cases.
Handling HTTP GET Requests
Here we will develop a servlet that handles an HTTP GET request. The servlet is invoked when
a form on a web page is submitted. The example contains two files. A web page is defined
in ColorGet.htm, and a servlet is defined in ColorGetServlet.java. The HTML source code
for ColorGet.htm is shown in the following listing. It defines a form that contains a select
element and a submit button. Notice that the action parameter of the form tag specifies a URL.
The URL identifies a servlet to process the HTTP GET request.
<html>
<body>
<center>
<form name="Form1"
action="http://localhost:8080/servlets-examples/servlet/ColorGetServlet">
<B>Color:</B>
<select name="color" size="1">Chapter 31:
Servlets
<option value="Red">Red</option>
<option value="Green">Green</option>
<option value="Blue">Blue</option>
</select>
<br><br>
<input type=submit value="Submit">
</form>
</body>
</html>
The source code for ColorGetServlet.java is shown in the following listing. The doGet( )
method is overridden to process any HTTP GET requests that are sent to this servlet. It uses
the getParameter( ) method of HttpServletRequest to obtain the selection that was made
by the user. A response is then formulated.
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class ColorGetServlet extends HttpServlet 
Compile the servlet. Next, copy it to the appropriate directory, and update the web.xml
file, as previously described. Then, perform these steps to test this example:
1. Start Tomcat, if it is not already running.
2. Display the web page in a browser.
3. Select a color.
4. Submit the web page.
After completing these steps, the browser will display the response that is dynamically
generated by the servlet.
One other point: Parameters for an HTTP GET request are included as part of the URL that
is sent to the web server. Assume that the user selects the red option and submits the form.
The URL sent from the browser to the server is
http://localhost:8080/servlets-examples/servlet/ColorGetServlet?color=Red
The characters to the right of the question mark are known as the query string.
923924
Part III:
Software Development Using Java
Handling HTTP POST Requests
Here we will develop a servlet that handles an HTTP POST request. The servlet is invoked
when a form on a web page is submitted. The example contains two files. A web page is
defined in ColorPost.htm, and a servlet is defined in ColorPostServlet.java.
The HTML source code for ColorPost.htm is shown in the following listing. It is identical
to ColorGet.htm except that the method parameter for the form tag explicitly specifies that
the POST method should be used, and the action parameter for the form tag specifies a
different servlet.
<html>
<body>
<center>
<form name="Form1"
method="post"
action="http://localhost:8080/servlets-examples/servlet/ColorPostServlet">
<B>Color:</B>
<select name="color" size="1">
<option value="Red">Red</option>
<option value="Green">Green</option>
<option value="Blue">Blue</option>
</select>
<br><br>
<input type=submit value="Submit">
</form>
</body>
</html>
The source code for ColorPostServlet.java is shown in the following listing. The doPost( )
method is overridden to process any HTTP POST requests that are sent to this servlet. It uses
the getParameter( ) method of HttpServletRequest to obtain the selection that was made
by the user. A response is then formulated.
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class ColorPostServlet extends HttpServlet Chapter 31:
Servlets
Compile the servlet and perform the same steps as described in the previous section
to test it.
N OTE Parameters for an HTTP POST request are not included as part of the URL that
is sent to the web server. In this example, the URL sent from the browser to the server is
http://localhost:8080/servlets-examples/servlet/ColorPostServlet.
The parameter names and values are sent in the body of the HTTP request.
Using Cookies
Now, let’s develop a servlet that illustrates how to use cookies. The servlet is invoked when
a form on a web page is submitted. The example contains three files as summarized here:
File Description
AddCookie.htm Allows a user to specify a value for the cookie named MyCookie.
AddCookieServlet.java Processes the submission of AddCookie.htm.
GetCookiesServlet.java Displays cookie values.
The HTML source code for AddCookie.htm is shown in the following listing. This page
contains a text field in which a value can be entered. There is also a submit button on the
page. When this button is pressed, the value in the text field is sent to AddCookieServlet
via an HTTP POST request.
<html>
<body>
<center>
<form name="Form1"
method="post"
action="http://localhost:8080/servlets-examples/servlet/AddCookieServlet">
<B>Enter a value for MyCookie:</B>
<input type=textbox name="data" size=25 value="">
<input type=submit value="Submit">
</form>
</body>
</html>
The source code for AddCookieServlet.java is shown in the following listing. It gets the
value of the parameter named “data”. It then creates a Cookie object that has the name
“MyCookie” and contains the value of the “data” parameter. The cookie is then added to
the header of the HTTP response via the addCookie( ) method. A feedback message is then
written to the browser.
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class AddCookieServlet extends HttpServlet 
The source code for GetCookiesServlet.java is shown in the following listing. It invokes
the getCookies( ) method to read any cookies that are included in the HTTP GET request. The
names and values of these cookies are then written to the HTTP response. Observe that the
getName( ) and getValue( ) methods are called to obtain this information.
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class GetCookiesServlet extends HttpServlet Chapter 31:
Servlets
Compile the servlets. Next, copy them to the appropriate directory, and update the web.xml
file, as previously described. Then, perform these steps to test this example:
1. Start Tomcat, if it is not already running.
2. Display AddCookie.htm in a browser.
3. Enter a value for MyCookie.
4. Submit the web page.
After completing these steps, you will observe that a feedback message is displayed by the
browser.
Next, request the following URL via the browser:
http://localhost:8080/servlets-examples/servlet/GetCookiesServlet
Observe that the name and value of the cookie are displayed in the browser.
In this example, an expiration date is not explicitly assigned to the cookie via the setMaxAge( )
method of Cookie. Therefore, the cookie expires when the browser session ends. You can
experiment by using setMaxAge( ) and observe that the cookie is then saved to the disk on
the client machine.
Session Tracking
HTTP is a stateless protocol. Each request is independent of the previous one. However, in
some applications, it is necessary to save state information so that information can be collected
from several interactions between a browser and a server. Sessions provide such a mechanism.
A session can be created via the getSession( ) method of HttpServletRequest. An
HttpSession object is returned. This object can store a set of bindings that associate names with
objects. The setAttribute( ), getAttribute( ), getAttributeNames( ), and removeAttribute( )
methods of HttpSession manage these bindings. It is important to note that session state is
shared among all the servlets that are associated with a particular client.
The following servlet illustrates how to use session state. The getSession( ) method gets the
current session. A new session is created if one does not already exist. The getAttribute( )
method is called to obtain the object that is bound to the name “date”. That object is a Date
object that encapsulates the date and time when this page was last accessed. (Of course, there
is no such binding when the page is first accessed.) A Date object encapsulating the current
date and time is then created. The setAttribute( ) method is called to bind the name “date”
to this object.
import
import
import
import
java.io.*;
java.util.*;
javax.servlet.*;
javax.servlet.http.*;
public class DateServlet extends HttpServlet 
When you first request this servlet, the browser displays one line with the current date
and time information. On subsequent invocations, two lines are displayed. The first line shows
the date and time when the servlet was last accessed. The second line shows the current date
and time.IV
Applying Java
C HAPTER 32
Financial Applets and
Servlets
C HAPTER 33
Creating a Download
Manager in Java
A PPENDIX
Using Java's Documentation
CommentsThis page intentionally left blank32
Financial Applets
and Servlets
D
espite all the large, sophisticated applications, such as word processors, databases,
and accounting packages, that dominate much of the computing landscape, there
has remained a class of programs that are both popular and small. These perform
various financial calculations, such as the regular payments on a loan, the future value
of an investment, or the remaining balance on a loan. None of these calculations are very
complicated or require much code, yet they yield information that is quite useful.
As you know, Java was initially designed to support the creation of small, portable
programs. Originally, these programs took the form of applets, but a few years later, servlets
were added. (Recall that applets run on the local machine, inside the browser, and servlets
execute on the server.) Because of their small size, many of the common financial calculations
are right-sized for applets and servlets. Furthermore, including a financial applet/servlet in a
web page is an amenity that many users will appreciate. A user will return again and again to
a page that offers the calculation that he or she desires.
This chapter develops a number of applets that perform the financial calculations
shown here:
• Regular payments on a loan
• Remaining balance on a loan
• Future value of an investment
• Initial investment needed to attain a desired future value
• Annuity from an investment
• Investment necessary for a desired annuity
The chapter ends by showing how to convert the financial applets into servlets.
931932
Part IV:
Applying Java
Finding the Payments for a Loan
Perhaps the most popular financial calculation is the one that computes the regular payments
on a loan, such as a car or house loan. The payments on a loan are found by using the
following formula:
Payment = (intRate * (principal / payPerYear)) /
(1 – ((intRate / payPerYear) + 1) – payPerYear * numYears )
where intRate specifies the interest rate, principal contains the starting balance, payPerYear
specifies the number of payments per year, and numYears specifies the length of the loan
in years.
The following applet called RegPay uses the preceding formula to compute the
payments on a loan given the information entered by the user. Like all of the applets in
this chapter, RegPay is a Swing-based applet. This means that it extends the JApplet class
and uses the Swing classes to provide the user interface. Notice that it also implements the
ActionListener interface.
// A simple loan calculator applet.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.text.*;
/*
<applet code="RegPay" width=320 height=200>
</applet>
*/
public class RegPay extends JApplet
implements ActionListener 
The applet produced by this program is shown in Figure 32-1. To use the applet, simply
enter the loan principal, the length of the loan in years, and the interest rate. The payments
are assumed to be monthly. Once the information is entered, press Compute to calculate the
monthly payment.
The following sections examine the code to RegPay in detail. Because all the applets in
this chapter use the same basic framework, much of the explanation presented here also
applies to the other applets.
The RegPay Fields
RegPay begins by declaring a number of instance variables that hold references to the text
fields into which the user will enter the loan information. Next, it declares the doIt variable
that will hold a reference to the Compute button.
F IGURE 32-1
The RegPay applet
935936
Part IV:
Applying Java
RegPay then declares three double variables that hold the loan values. The original
principal is stored in principal, the interest rate is stored in intRate, and the length of the
loan in years is stored in numYears. These values are entered by the user through the text
fields. Next, the final integer variable payPerYear is declared and initialized to 12. Thus, the
number of payments per year is hard-coded to monthly because this is the way that most
loans are paid. As the comments suggest, you could allow the user to enter this value, but
doing so will require another text field.
The last instance variable declared by RegPay is nf, a reference to an object of type
NumberFormat, which will describe the number format used for output. NumberFormat
is stored in the java.text package. Although there are other ways to format numeric output,
such as by using the Formatter class, NumberFormat is a good choice in this case, because
the same format is used repeatedly, and this format can be set once, at the start of the
program. The financial applets also offer a good opportunity to demonstrate its use.
The init( ) Method
Like all applets, the init( ) method is called when the applet first starts execution. This
method simply invokes the makeGUI( ) method on the event-dispatching thread. As
explained in Chapter 29, Swing-based applets must construct and interact with GUI
components only through the event-dispatching thread.
The makeGUI( ) Method
The makeGUI( ) method sets up the user interface for the applet. It performs the following jobs:
1. It changes the layout manager to GridBagLayout.
2. It instantiates the various GUI components.
3. It adds the components to the grid bag.
4. It adds action listeners for the components.
Let’s now look at makeGUI( ) line by line. The method begins with these lines of code:
// Use a grid bag layout.
GridBagLayout gbag = new GridBagLayout();
GridBagConstraints gbc = new GridBagConstraints();
setLayout(gbag);
This sequence creates a GridBagLayout layout manager that will be used by the applet. (For
details on using GridBagLayout, see Chapter 24.) GrigBagLayout is used because it allows
detailed control over the placement of controls within an applet.
Next, makeGUI( ) creates the label components, text fields, and Compute button, as
shown here:
JLabel heading = new
JLabel("Compute Monthly Loan Payments");
JLabel
JLabel
JLabel
JLabel
amountLab = new JLabel("Principal ");
periodLab = new JLabel("Years ");
rateLab = new JLabel("Interest Rate ");
paymentLab = new JLabel("Monthly Payments ");Chapter 32:
Financial Applets and Servlets
amountText = new JTextField(10);
periodText = new JTextField(10);
paymentText = new JTextField(10);
rateText = new JTextField(10);
// Payment field for display only.
paymentText.setEditable(false);
doIt = new JButton("Compute");
Notice that the text field that displays the monthly payment is set to read-only by calling
setEditable(false). This causes the field to be grayed and no text can be entered into the
field by the user. However, the contents of the text field can still be set by calling setText( ).
Thus, when editing is disabled in a JTextField, the field can be used to display text, but the
text cannot be changed by the user.
Next, the grid bag constraints for each component are set by the following code sequence:
// Define the grid bag.
gbc.weighty = 1.0; // use a row weight of 1
gbc.gridwidth = GridBagConstraints.REMAINDER;
gbc.anchor = GridBagConstraints.NORTH;
gbag.setConstraints(heading, gbc);
// Anchor most components to the right.
gbc.anchor = GridBagConstraints.EAST;
gbc.gridwidth = GridBagConstraints.RELATIVE;
gbag.setConstraints(amountLab, gbc);
gbc.gridwidth = GridBagConstraints.REMAINDER;
gbag.setConstraints(amountText, gbc);
gbc.gridwidth = GridBagConstraints.RELATIVE;
gbag.setConstraints(periodLab, gbc);
gbc.gridwidth = GridBagConstraints.REMAINDER;
gbag.setConstraints(periodText, gbc);
gbc.gridwidth = GridBagConstraints.RELATIVE;
gbag.setConstraints(rateLab, gbc);
gbc.gridwidth = GridBagConstraints.REMAINDER;
gbag.setConstraints(rateText, gbc);
gbc.gridwidth = GridBagConstraints.RELATIVE;
gbag.setConstraints(paymentLab, gbc);
gbc.gridwidth = GridBagConstraints.REMAINDER;
gbag.setConstraints(paymentText, gbc);
gbc.anchor = GridBagConstraints.CENTER;
gbag.setConstraints(doIt, gbc);
Although this seems a bit complicated at first glance, it really isn’t. Just remember that
each row in the grid is specified separately. Here is how the sequence works. First, the
weight of each row, contained in gbc.weighty, is set to 1. This tells the grid bag to distribute
extra space evenly when there is more vertical space than needed to hold the components.
937938
Part IV:
Applying Java
Next, the gbc.gridwidth is set to REMAINDER, and gbc.anchor is set to NORTH. The label
referred to by heading is added by calling setConstraints( ) on gbag. This sequence sets the
location of heading to the top of the grid (north) and gives it the remainder of the row.
Thus, after this sequence executes, the heading will be at the top of the window and on a
row by itself.
Next, the four text fields and their labels are added. First, gbc.anchor is set to EAST.
This causes each component to be aligned to the right. Next, gbc.gridWidth is set to
RELATIVE, and the label is added. Then, gbc.gridWidth is set to REMAINDER, and the
text field is added. Thus, each text field and label pair occupies one row. This process
repeats until all four text field and label pairs have been added. Finally, the Compute button
is added in the center.
After the grid bag constraints have been set, the components are actually added to the
window by the following code:
// Add all the components.
add(heading);
add(amountLab);
add(amountText);
add(periodLab);
add(periodText);
add(rateLab);
add(rateText);
add(paymentLab);
add(paymentText);
add(doIt);
Next, action listeners are registered for the three input text fields and the Compute
button, as shown here:
// Register to receive action events.
amountText.addActionListener(this);
periodText.addActionListener(this);
rateText.addActionListener(this);
doIt.addActionListener(this);
Finally, a NumberFormat object is obtained and the format is set to two decimal digits:
// Create a number format.
nf = NumberFormat.getInstance();
nf.setMinimumFractionDigits(2);
nf.setMaximumFractionDigits(2);
The call to the factory method getInstance( ) obtains a NumberFormat object suitable for the
default locale. The calls to setMinimumFractionDigits( ) and setMaximumFractionDigits( )
set the minimum and maximum number of decimal digits to be displayed. Because both are set
to two, this ensures that two decimal places will always be visible.
The actionPerformed( ) Method
The actionPerformed( ) method is called whenever the user presses ENTER when in a text
field or clicks the Compute button. This method performs three main functions: it obtains
the loan information entered by the user, it calls compute( ) to find the loan payments, and
it displays the result. Let’s now examine actionPerformed( ) line by line.Chapter 32:
Financial Applets and Servlets
After declaring the result variable, actionperformed( ) begins by obtaining the strings
from the three user-input text fields using the following sequence:
String amountStr = amountText.getText();
String periodStr = periodText.getText();
String rateStr = rateText.getText();
Next, it begins a try block and then verifies that all three fields actually contain
information, as shown here:
try {
if(amountStr.length() != 0 &&
periodStr.length() != 0 &&
rateStr.length() != 0)  catch (NumberFormatException exc) 
Otherwise, any previously reported error is removed.
The compute( ) Method
The calculation of the loan payment takes place in compute( ). It implements the formula
shown earlier and operates on the values in principal, intRate, numYears, and payPerYear.
It returns the result.
N OTE The basic skeleton used by RegPay is used by all the applets shown in this chapter.
939940
Part IV:
Applying Java
F IGURE 32-2
The FutVal applet
Finding the Future Value of an Investment
Another popular financial calculation finds the future value of an investment given the
initial investment, the rate of return, the number of compounding periods per year, and the
number of years the investment is held. For example, you might want to know what your
retirement account will be worth in 12 years if it currently contains $98,000 and has an
average annual rate of return of 6 percent. The FutVal applet developed here will supply
the answer.
To compute the future value, use the following formula:
Future Value = principal * ((rateOfRet / compPerYear) + 1) compPerYear * numYears
where rateOfRet specifies the rate of return, principal contains the initial value of the
investment, compPerYear specifies the number of compounding periods per year, and
numYears specifies the length of the investment in years. If you use an annualized rate
of return for rateOfRet, then the number of compounding periods is 1.
The following applet called FutVal uses the preceding formula to compute the future
value of an investment. The applet produced by this program is shown in Figure 32-2.
Aside from the computational differences within the compute( ) method, the applet is
similar in operation to the RegPay applet described in the preceding section.
// Compute the future value of an investment.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.text.*;
/*
<applet code="FutVal" width=380 height=240>
</applet>
*/
public class FutVal extends JApplet
implements ActionListener 
Finding the Initial Investment Required to Achieve a Future Value
Sometimes you will want to know how large an initial investment is required to achieve
some future value. For example, if you are saving for your child’s college education and
you know that you will need $75,000 in five years, how much money do you need to invest
at 7 percent to reach that goal? The InitInv applet developed here can answer that question.
943944
Part IV:
Applying Java
F IGURE 32-3
The InitInv applet
The formula to compute an initial investment is shown here:
Initial Investment = targetValue / (((rateOfRet / compPerYear) + 1) compPerYear * numYears )
where rateOfRet specifies the rate of return, targetValue contains the starting balance, compPerYear
specifies the number of compounding periods per year, and numYears specifies the length of
the investment in years. If you use an annualized rate of return for rateOfRet, then the
number of compounding periods is 1.
The following applet called InitInv uses the preceding formula to compute the initial
investment required to reach a desired future value. The applet produced by this program
is shown in Figure 32-3.
/* Compute the initial investment necessary for
a specified future value. */
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.text.*;
/*
<applet code="InitInv" width=340 height=240>
</applet>
*/
public class InitInv extends JApplet
implements ActionListener 
Finding the Initial Investment Needed for a Desired Annuity
Another common financial calculation computes the amount of money that you must invest
so that a desired annuity, in terms of a regular withdrawal, can be paid. For example, you
might decide that you need $5,000 per month at retirement and that you will need that
amount for 20 years. The question is how much will you need to invest to secure that
annuity? The answer can be found using the following formula:
Initial Investment = ((regWD * wdPerYear) / rateOfRet) *
(1 – (1 / (rateOfRet / wdPerYear + 1) wdPerYear * numYears ))
947948
Part IV:
Applying Java
F IGURE 32-4
The Annuity applet
where rateOfRet specifies the rate of return, regWD contains the desired regular withdrawal,
wdPerYear specifies the number of withdrawals per year, and numYears specifies the length
of the annuity in years.
The Annuity applet shown here computes the initial investment required to produce
the desired annuity. The applet produced by this program is shown in Figure 32-4.
/* Compute the initial investment necessary for
a desired annuity. In other words, it finds
the initial amount needed to allow the regular
withdrawals of a desired amount over a period
of time. */
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.text.*;
/*
<applet code="Annuity" width=340 height=260>
</applet>
*/
public class Annuity extends JApplet
implements ActionListener 
Finding the Maximum Annuity for a Given Investment
Another annuity calculation computes the maximum annuity (in terms of a regular withdrawal)
available from a given investment over a specified period of time. For example, if you have
951952
Part IV:
Applying Java
F IGURE 32-5
The MaxWD
applet
$500,000 in a retirement account, how much can you take out each month for 20 years, assuming
a 6 percent rate of return? The formula that computes the maximum withdrawal is shown here:
Maximum Withdrawal = principal * ( ( (rateOfRet / wdPerYear) /
(–1 + ((rateOfRet / wdPerYear) + 1) wdPerYear * numYears ) ) +
(rateOfRet / wdPerYear) )
where rateOfRet specifies the rate of return, principal contains the value of the initial
investment, wdPerYear specifies the number of withdrawals per year, and numYears
specifies the length of the annuity in years.
The MaxWD applet shown next computes the maximum periodic withdrawals that can
be made over a specified length of time for an assumed rate of return. The applet produced
by this program is shown in Figure 32-5.
/* Compute the maximum annuity that can
be withdrawn from an investment over
a period of time. */
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.text.*;
/*
<applet code="MaxWD" width=340 height=260>
</applet>
*/
public class MaxWD extends JApplet
implements ActionListener 
Finding the Remaining Balance on a Loan
Often, you will want to know the remaining balance on a loan. This is easily calculated if you
know the original principal, the interest rate, the loan length, and the number of payments
made. To find the remaining balance, you must sum the payments, subtracting from each
payment the amount allocated to interest, and then subtract that result from the principal.
The RemBal applet, shown next, finds the remaining balance of a loan. The applet
produced by this program is shown in Figure 32-6.
955956
Part IV:
Applying Java
F IGURE 32-6
The RemBal
applet
// Find the remaining balance on a loan.
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.text.*;
/*
<applet code="RemBal" width=340 height=260>
</applet>
*/
public class RemBal extends JApplet
implements ActionListener 
Creating Financial Servlets
Although applets are easy to create and use, they are only one half of the Java Internet
equation. The other half is servlets. Servlets execute on the server side of the connection,
and they are more appropriate for some applications. Because many readers may want to
use servlets rather than applets in their commercial applications, the remainder of this
chapter shows how to convert the financial applets into servlets.
Because all the financial applets use the same basic skeleton, we will walk through
the conversion of only one applet: RegPay. You can then apply the same basic process to
convert any of the other applets into servlets on your own. As you will see, it’s not hard to do.
N OTE For information on creating, testing, and running servlets, see Chapter 31.
959960
Part IV:
Applying Java
Converting the RegPay Applet into a Servlet
It is fairly easy to convert the RegPay loan calculating applet into a servlet. First, the servlet
must import the javax.servlet and javax.servlet.http packages. It must also extend HttpServlet,
not JApplet. Next, you must remove all the GUI code. Then, you must add the code that obtains
the parameters passed to the servlet by the HTML that calls the servlet. Finally, the servlet must
send the HTML that displays the results. The basic financial calculations remain the same. It is
only the way data is obtained and displayed that changes.
The RegPayS Servlet
The following RegPayS class is the servlet version of the RegPay applet. As the code is
written, it assumes that RegPayS.class will be stored in Tomcat’s example servlets directory,
as described in Chapter 31. Remember to enter its name into the web.xml file, also as
described in Chapter 31.
// A simple loan calculator servlet.
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.text.*;
public class RegPayS extends HttpServlet 
The first thing to notice about RegPayS is that it has only two methods: doGet( ) and
compute( ). The compute( ) method is the same as that used by the applet. The doGet( )
method is defined by the HttpServlet class, which RegPayS extends. This method is called by
the server when the servlet must respond to a GET request. Notice that it is passed a reference
to the HttpServletRequest and HttpServletResponse objects associated with the request.
From the request parameter, the servlet obtains the arguments associated with the
request. It does this by calling getParameter( ). The parameter is returned in its string form.
Thus, a numeric value must be manually converted into its binary format. If no parameter
is available, a null is returned.
From the response object, the servlet obtains a stream to which response information
can be written. The response is then returned to the browser by outputting to that stream.
Prior to obtaining a PrintWriter to the response stream, the output type should be set to
text/html by calling setContentType( ).
RegPayS can be called with or without parameters. If called without parameters, the
servlet responds with the necessary HTML to display an empty loan calculator form.
Otherwise, if called with all needed parameters, RegPayS calculates the loan payment and
redisplays the form, with the payment field filled in. Figure 32-7 shows the RegPayS servlet
in action.
F IGURE 32-7
The RegPayS
servlet in actionChapter 32:
Financial Applets and Servlets
The simplest way to invoke RegPayS is to link to its URL without passing any parameters.
For example, assuming that you are using Tomcat, you can use this line to execute it:
<A HREF = "http://localhost:8080/servlets-examples/servlet/RegPayS">
Loan Calculator</A>
This displays a link called Loan Calculator that links to the RegPayS servlet in the Tomcat
example servlets directory. Notice that no parameters are passed. This causes RegPayS to
return the complete HTML that displays an empty loan calculator page.
You can also invoke RegPayS by first displaying an empty form manually, if you like.
This approach is shown here, again using Tomcat’s example servlets directory:
<html>
<body>
<form name="Form1"
action="http://localhost:8080/servlets-examples/servlet/RegPayS">
<B>Enter amount to finance:</B>
<input type=textbox name="amount" size=12 value="">
<BR>
<B>Enter term in years:</B>
<input type=textbox name="period" size=12 value="">
<BR>
<B>Enter interest rate:</B>
<input type=textbox name="rate" size=12 value="">
<BR>
<B>Monthly Payment:</B>
<input READONLY type=textbox name="payment"
size=12 value="">
<BR><P>
<input type=submit value="Submit">
</form>
</body>
</html>
Some Things to Try
The first thing you might want to try is converting the other financial applets into servlets.
Because all the financial applets are built on the same skeleton, simply follow the same
approach as used by RegPayS. There are many other financial calculations that you might
find useful to implement as applets or servlets, such as the rate of return of an investment
or the amount of a regular deposit needed over time to reach a future value. You could also
print a loan amortization chart. You might want to try creating a larger application that
offers all the calculations presented in this chapter, allowing the user to select the desired
calculation from a menu.
963This page intentionally left blank33
Creating a Download
Manager in Java
H
ave you ever had an Internet download interrupted, putting you back at square
one? If you connect to the Internet with a dialup connection, it’s very likely that
you’ve run into this all too common nuisance. Everything from call-waiting
disconnects to computer crashes can leave a download dead in its tracks. To say the
least, restarting a download from scratch over and over can be a very time-consuming
and frustrating experience.
A sometimes overlooked fact is that many interrupted downloads can be resumed.
This allows you to recommence downloading from the point at which a download terminates
instead of having to begin anew. In this chapter a tool called Download Manager is
developed that manages Internet downloads for you and makes simple work of resuming
interrupted downloads. It also lets you pause and then resume a download, and manage
multiple downloads, simultaneously.
At the core of the Download Manager’s usefulness is its ability to take advantage of
downloading only specific portions of a file. In a classic download scenario, a whole file
is downloaded from beginning to end. If the transmission of the file is interrupted for
any reason, the progress made toward completing the downloading of the file is lost. The
Download Manager, however, can pick up from where an interruption occurs and then
download only the file’s remaining fragment. Not all downloads are created equal, though,
and there are some that simply cannot be restarted. Details on which files are and aren’t
resumable are explained in the following section.
Not only is the Download Manager a useful utility, it is an excellent illustration of the
power and succinctness of Java’s built-in APIs—especially as they apply to interfacing to
the Internet. Because the Internet was a driving force behind the creation of Java, it should
come as no surprise that Java’s networking capabilities are unsurpassed. For example,
attempting to create the Download Manager in another language, such as C++, would
entail significantly more trouble and effort.
965966
Part IV:
Applying Java
Understanding Internet Downloads
To understand and appreciate the Download Manager, it’s necessary to shed some light on
how Internet downloads really work.
Internet downloads in their simplest form are merely client/server transactions. The
client, your browser, requests to download a file from a server on the Internet. The server
then responds by sending the requested file to your browser. In order for clients to communicate
with servers, they must have an established protocol for doing so. The most common protocols
for downloading files are File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP).
FTP is usually associated generically with exchanging files between computers, whereas
HTTP is usually associated specifically with transferring web pages and their related files
(that is, graphics, sounds, and so on). Over time, as the World Wide Web has grown in
popularity, HTTP has become the dominant protocol for downloading files from the Internet.
FTP is definitely not extinct, though.
For brevity’s sake, the Download Manager developed in this chapter will only support
HTTP downloads. Nonetheless, adding support for FTP would be an excellent exercise
for extending the code. HTTP downloads come in two forms: resumable (HTTP 1.1) and
nonresumable (HTTP 1.0). The difference between these two forms lies in the way files can
be requested from servers. With the antiquated HTTP 1.0, a client can only request that a server
send it a file, whereas with HTTP 1.1, a client can request that a server send it a complete file or
only a specific portion of a file. This is the feature the Download Manager is built on.
An Overview of the Download Manager
The Download Manager uses a simple yet effective GUI interface built with Java’s Swing
libraries. The Download Manager window is shown in Figure 33-1. The use of Swing gives
the interface a crisp, modern look and feel.
The GUI maintains a list of downloads that are currently being managed. Each download
in the list reports its URL, size of the file in bytes, progress as a percentage toward completion,
and current status. The downloads can each be in one of the following different states:
Downloading, Paused, Complete, Error, or Cancelled. The GUI also has controls for adding
downloads to the list and for changing the state of each download in the list. When a download
in the list is selected, depending on its current state, it can be paused, resumed, cancelled,
or removed from the list altogether.
The Download Manager is broken into a few classes for natural separation of functional
components. These are the Download, DownloadsTableModel, ProgressRenderer, and
DownloadManager classes, respectively. The DownloadManager class is responsible for the
GUI interface and makes use of the DownloadsTableModel and ProgressRenderer classes
for displaying the current list of downloads. The Download class represents a “managed”
download and is responsible for performing the actual downloading of a file. In the following
sections, we’ll walk through each of these classes in detail, highlighting their inner workings
and explaining how they relate to each other.Chapter 33:
F IGURE 33-1
Creating a Download Manager in Java
The Download Manager GUI interface
The Download Class
The Download class is the workhorse of the Download Manager. Its primary purpose is to
download a file and save that file’s contents to disk. Each time a new download is added
to the Download Manager, a new Download object is instantiated to handle the download.
The Download Manager has the ability to download multiple files at once. To achieve
this, it’s necessary for each of the simultaneous downloads to run independently. It’s also
necessary for each individual download to manage its own state so that it can be reflected
in the GUI. This is accomplished with the Download class.
The entire code for Download is shown here. Notice that it extends Observable and
implements Runnable. Each part is examined in detail in the sections that follow.
import java.io.*;
import java.net.*;
import java.util.*;
// This class downloads a file from a URL.
class Download extends Observable implements Runnable 
The Download Variables
Download begins by declaring several static final variables that specify the various constants
used by the class. Next, four instance variables are declared. The url variable holds the Internet
URL for the file being downloaded; the size variable holds the size of the download file in
bytes; the downloaded variable holds the number of bytes that have been downloaded thus
far; and the status variable indicates the download’s current status.
The Download Constructor
Download’s constructor is passed a reference to the URL to download in the form of a URL
object, which is assigned to the url instance variable. It then sets the remaining instance
variables to their initial states and calls the download( ) method. Notice that size is set to –1
to indicate there is no size yet.
The download( ) Method
The download( ) method creates a new Thread object, passing it a reference to the invoking
Download instance. As mentioned before, it’s necessary for each download to run
independently. In order for the Download class to act alone, it must execute in its own
thread. Java has excellent built-in support for threads and makes using them a snap. To use
threads, the Download class simply implements the Runnable interface by overriding the
run( ) method. After the download( ) method has instantiated a new Thread instance, passing
its constructor the Runnable Download class, it calls the thread’s start( ) method. Invoking
the start( ) method causes the Runnable instance’s (the Download class’) run( ) method to
be executed.
The run( ) Method
When the run( ) method executes, the actual downloading gets under way. Because of its
size and importance, we will examine it closely, line by line. The run( ) method begins with
these lines:
RandomAccessFile file = null;
InputStream stream = null;
try  catch (Exception e)  finally 
If an exception is thrown during the download process, the catch block captures the
exception and calls the error( ) method. The finally block ensures that if the file and stream
connections have been opened, they get closed whether an exception has been thrown or not.
The stateChanged( ) Method
In order for the Download Manager to display up-to-date information on each of the
downloads it’s managing, it has to know each time a download’s information changes. To
handle this, the Observer software design pattern is used. The Observer pattern is analogous
to an announcement’s mailing list where several people register to receive announcements.
Each time there’s a new announcement, each person on the list receives a message with the
announcement. In the Observer pattern’s case, there’s an observed class with which observer
classes can register themselves to receive change notifications.
The Download class employs the Observer pattern by extending Java’s built-in Observable
utility class. Extending the Observable class allows classes that implement Java’s Observer
interface to register themselves with the Download class to receive change notifications.
Each time the Download class needs to notify its registered Observers of a change, the
stateChanged( ) method is invoked. The stateChanged( ) method first calls the Observable
class’ setChanged( ) method to flag the class as having been changed. Next, the stateChanged( )
method calls Observable’s notifyObservers( ) method, which broadcasts the change
notification to the registered Observers.
Action and Accessor Methods
The Download class has numerous action and accessor methods for controlling a download
and getting data from it. Each of the pause( ), resume( ), and cancel( ) action methods simply
does as its name implies: pauses, resumes, or cancels the download, respectively. Similarly,
the error( ) method marks the download as having an error. The getUrl( ), getSize( ),
getProgress( ), and getStatus( ) accessor methods each return their current respective values.
The ProgressRenderer Class
The ProgressRenderer class is a small utility class that is used to render the current progress
of a download listed in the GUI’s “Downloads” JTable instance. Normally, a JTable instance
renders each cell’s data as text. However, often it’s particularly useful to render a cell’s data
as something other than text. In the Download Manager’s case, we want to render each of
the table’s Progress column cells as progress bars. The ProgressRenderer class shown here
makes that possible. Notice that it extends JProgressBar and implements TableCellRenderer:
import java.awt.*;
import javax.swing.*;
import javax.swing.table.*;
975976
Part IV:
Applying Java
// This class renders a JProgressBar in a table cell.
class ProgressRenderer extends JProgressBar
implements TableCellRenderer

The ProgressRenderer class takes advantage of the fact that Swing’s JTable class
has a rendering system that can accept “plug-ins” for rendering table cells. To plug into
this rendering system, first, the ProgressRenderer class has to implement Swing’s
TableCellRenderer interface. Second, a ProgressRenderer instance has to be registered
with a JTable instance; doing so instructs the JTable instance as to which cells should be
rendered with the “plug-in.”
Implementing the TableCellRenderer interface requires the class to override the
getTableCellRendererComponent( ) method. The getTableCellRendererComponent( )
method is invoked each time a JTable instance goes to render a cell for which this class has
been registered. This method is passed several variables, but in this case, only the value
variable is used. The value variable holds the data for the cell being rendered and is passed
to JProgressBar’s setValue( ) method. The getTableCellRendererComponent( ) method
wraps up by returning a reference to its class. This works because the ProgressRenderer
class is a subclass of JProgressBar, which is a descendent of the AWT Component class.
The DownloadsTableModel Class
The DownloadsTableModel class houses the Download Manager’s list of downloads
and is the backing data source for the GUI’s “Downloads” JTable instance.
The DownloadsTableModel class is shown here. Notice that it extends
AbstractTableModel and implements the Observer interface:
import java.util.*;
import javax.swing.*;
import javax.swing.table.*;
// This class manages the download table's data.
class DownloadsTableModel extends AbstractTableModel
implements Observer

The DownloadsTableModel class essentially is a utility class utilized by the “Downloads”
JTable instance for managing data in the table. When the JTable instance is initialized, it is
passed a DownloadsTableModel instance. The JTable then proceeds to call several methods
on the DownloadsTableModel instance to populate itself. The getColumnCount( ) method
is called to retrieve the number of columns in the table. Similarly, getRowCount( ) is used to
retrieve the number of rows in the table. The getColumnName( ) method returns a column’s
name given its ID. The getDownload( ) method takes a row ID and returns the associated
Download object from the list. The rest of the DownloadsTableModel class’ methods, which
are more involved, are detailed in the following sections.
The addDownload( ) Method
The addDownload( ) method, shown here, adds a new Download object to the list of
managed downloads and consequently a row to the table:
// Add a new download to the table.
public void addDownload(Download download) Chapter 33:
Creating a Download Manager in Java
This method first registers itself with the new Download as an Observer interested in
receiving change notifications. Next, the Download is added to the internal list of downloads
being managed. Finally, a table row insertion event notification is fired to alert the table that
a new row has been added.
The clearDownload( ) Method
The clearDownload( ) method, shown next, removes a Download from the list of managed
downloads:
// Remove a download from the list.
public void clearDownload(int row) 
After removing the Download from the internal list, a table row deleted event notification
is fired to alert the table that a row has been deleted.
The getColumnClass( ) Method
The getColumnClass( ) method, shown here, returns the class type for the data displayed
in the specified column:
// Get a column's class.
public Class getColumnClass(int col) 
All columns are displayed as text (that is, String objects) except for the Progress column,
which is displayed as a progress bar (which is an object of type JProgressBar).
The getValueAt( ) Method
The getValueAt( ) method, shown next, is called to get the current value that should be
displayed for each of the table’s cells:
// Get value for a specific row and column combination.
public Object getValueAt(int row, int col) 
This method first looks up the Download corresponding to the row specified. Next, the
column specified is used to determine which one of the Download’s property values to return.
The update( ) Method
The update( ) method is shown here. It fulfills the Observer interface contract allowing the
DownloadsTableModel class to receive notifications from Download objects when they
change.
/* Update is called when a Download notifies its
observers of any changes. */
public void update(Observable o, Object arg) 
This method is passed a reference to the Download that has changed, in the form of an
Observable object. Next, an index to that download is looked up in the list of downloads,
and that index is then used to fire a table row update event notification, which alerts the
table that the given row has been updated. The table will then rerender the row with the
given index, reflecting its new values.
The DownloadManager Class
Now that the foundation has been laid by explaining each of the Download Manager’s helper
classes, we can look closely at the DownloadManager class. The DownloadManager class is
responsible for creating and running the Download Manager’s GUI. This class has a main( )
method declared, so on execution it will be invoked first. The main( ) method instantiates a
new DownloadManager class instance and then calls its show( ) method, which causes it to
be displayed.
The DownloadManager class is shown here. Notice that it extends JFrame and implements
Observer. The following sections examine it in detail.
import
import
import
import
import
import
java.awt.*;
java.awt.event.*;
java.net.*;
java.util.*;
javax.swing.*;
javax.swing.event.*;
// The Download Manager.
public class DownloadManager extends JFrame
implements Observer

The DownloadManager Variables
DownloadManager starts off by declaring several instance variables, most of which hold
references to the GUI controls. The selectedDownload variable holds a reference to the
Download object represented by the selected row in the table. Finally, the clearing instance
variable is a boolean flag that tracks whether or not a download is currently being cleared
from the Downloads table.
The DownloadManager Constructor
When the DownloadManager is instantiated, all of the GUI’s controls are initialized inside
its constructor. The constructor contains a lot of code, but most of it is straightforward.
The following discussion gives an overview.
First, the window’s title is set with a call to setTitle( ). Next, the setSize( ) call establishes
the window’s width and height in pixels. After that, a window listener is added by calling
addWindowListener( ), passing a WindowAdapter object that overrides the windowClosing( )
event handler. This handler calls the actionExit( ) method when the application’s window is
closed. Next, a menu bar with a “File” menu is added to the application’s window. Then the
“Add” panel, which has the Add Text field and button, is set up. An ActionListener is added
to the “Add Download” button so that the actionAdd( ) method is called each time the button
is clicked.
The downloads table is constructed next. A ListSelectionListener is added to the table so
that each time a row is selected in the table, the tableSelectionChanged( ) method is invoked.
The table’s selection mode is also updated to ListSelectionModel.SINGLE_SELECTION so
that only one row at a time can be selected in the table. Limiting row selection to only one
row at a time simplifies the logic for determining which buttons should be enabled in the
GUI when a row in the download table is selected. Next, a ProgressRenderer class is
instantiated and registered with the table to handle the “Progress” column. The table’s row
height is updated to the ProgressRenderer’s height by calling table.setRowHeight( ). After
the table has been assembled and tweaked, it is wrapped in a JScrollPane to make it scrollable
and then added to a panel.
Finally, the buttons panel is created. The buttons panel has Pause, Resume, Cancel, and
Clear buttons. Each of the buttons adds an ActionListener that invokes its respective action
method when it is clicked. After creating the buttons panel, all of the panels that have been
created are added to the window.
The verifyUrl( ) Method
The verifyUrl( ) method is called by the actionAdd( ) method each time a download is added
to the Download Manager. The verifyUrl( ) method is shown here:Chapter 33:
Creating a Download Manager in Java
// Verify download URL.
private URL verifyUrl(String url) 
This method first verifies that the URL entered is an HTTP URL since only HTTP is supported.
Next, the URL being verified is used to construct a new URL class instance. If the URL is
malformed, the URL class constructor will throw an exception. Finally, this method verifies
that a file is actually specified in the URL.
The tableSelectionChanged( ) Method
The tableSelectionChanged( ) method, shown here, is called each time a row is selected
in the downloads table:
// Called when table row selection changes.
private void tableSelectionChanged() 
This method starts by seeing if there is already a row currently selected by checking if
the selectedDownload variable is null. If the selectedDownload variable is not null,
DownloadManager removes itself as an observer of the download so that it no longer
receives change notifications. Next the clearing flag is checked. If the table is not empty
and the clearing flag is false, then first the selectedDownload variable is updated with the
Download corresponding to the row selected. Second, the DownloadManager is registered
987988
Part IV:
Applying Java
as an Observer with the newly selected Download. Finally, updateButtons( ) is called to
update the button states based on the selected Download’s state.
The updateButtons( ) Method
The updateButtons( ) method updates the state of all the buttons on the button panel based
on the state of the selected download. The updateButtons( ) method is shown here:
/* Update each button's state based on the
currently selected download's status. */
private void updateButtons() 
If no download is selected in the downloads table, all of the buttons are disabled, giving
them a grayed-out appearance. However, if there is a selected download, each button’s state
will be set based on whether the Download object has a status of DOWNLOADING, PAUSED,
ERROR, COMPLETE, or CANCELLED.Chapter 33:
Creating a Download Manager in Java
Handling Action Events
Each of DownloadManager’s GUI controls registers an ActionListener that invokes its
respective action method. ActionListeners are triggered each time an action event takes
place on a GUI control. For example, when a button is clicked, an ActionEvent is generated
and each of the button’s registered ActionListeners is notified. You may have noticed
a similarity between the way ActionListeners work and the Observer pattern discussed
earlier. That is because they are the same pattern with two different naming schemes.
Compiling and Running the Download Manager
Compile DownloadManager like this:
javac DownloadManager.java DownloadsTableModel.java ProgressRenderer.java Download.java
Run DownloadManager like this:
javaw DownloadManager
The Download Manager is easy to use. First, enter the URL of a file that you want to
download in the text field at the top of the screen. For example, to download a file called
0072229713_code.zip from the McGraw-Hill web site enter
http://books.mcgraw-hill.com/downloads/products/0072229713/0072229713_code.zip
This is the file that contains the code for my book The Art of Java, which I co-authored with
James Holmes.
After adding a download to the Download Manager, you can manage it by selecting it
in the table. Once selected, you can pause, cancel, resume, and clear a download. Figure 33-2
shows the Download Manager in action.
F IGURE 33-2
The Download Manager in action
989990
Part IV:
Applying Java
Enhancing the Download Manager
The Download Manager as it stands is fully functional, with the ability to pause and
resume downloads as well as download multiple files at once; however, there are several
enhancements that you may want to try on your own. Here are some ideas: proxy server
support, FTP and HTTPS support, and drag-and-drop support. A particularly appealing
enhancement is a scheduling feature that lets you schedule a download at a specific time,
perhaps in the middle of the night when system resources are plentiful.
Note that the techniques illustrated in this chapter are not limited to downloading files
in the typical sense. There are many other practical uses for the code. For example, many
software programs distributed over the Internet come in two pieces. The first piece is a
small, compact application that can be downloaded quickly. This small application contains
a mini download manager for downloading the second piece, which is generally much
larger. This concept is quite useful, especially as the size of applications increases, which
typically leads to an increase in the potential for download interruptions. You might want
to try adapting the Download Manager for this purpose.A
Using Java’s Documentation
Comments
A
s explained in Part I, Java supports three types of comments. The first two are the //
and the /* */. The third type is called a documentation comment. It begins with the
character sequence /**. It ends with */. Documentation comments allow you to embed
information about your program into the program itself. You can then use the javadoc utility
program (supplied with the JDK) to extract the information and put it into an HTML file.
Documentation comments make it convenient to document your programs. You have almost
certainly seen documentation generated with javadoc, because that is the way the Java API
library was documented by Sun.
The javadoc Tags
The javadoc utility recognizes the following tags:
Tag
Meaning
@author Identifies the author of a class.
 Displays information as-is, without processing HTML styles, in code font.
@deprecated Specifies that a class or member is deprecated.
 Specifies the path to the root directory of the current documentation.
@exception Identifies an exception thrown by a method.
 Inherits a comment from the immediate superclass.
 Inserts an in-line link to another topic.
 Inserts an in-line link to another topic, but the link is displayed in a plain-text font.
 Displays information as is, without processing HTML styles.
@param Documents a method’s parameter.
@return Documents a method’s return value.
@see Specifies a link to another topic.
991992
Part IV:
Applying Java
Tag Meaning
@serial Documents a default serializable field.
@serialData Documents the data written by the writeObject( ) or writeExternal( ) methods.
@serialField Documents an ObjectStreamField component.
@since States the release when a specific change was introduced.
@throws Same as @exception.
 Displays the value of a constant, which must be a static field.
@version Specifies the version of a class.
Document tags that begin with an “at” sign (@) are called stand-alone tags, and they must
be used on their own line. Tags that begin with a brace, such as , are called in-line tags,
and they can be used within a larger description. You may also use other, standard HTML tags
in a documentation comment. However, some tags, such as headings, should not be used
because they disrupt the look of the HTML file produced by javadoc.
You can use documentation comments to document classes, interfaces, fields, constructors,
and methods. In all cases, the documentation comment must immediately precede the item
being documented. When you are documenting a variable, the documentation tags you can use
are @see, @serial, @serialField, , and @deprecated. For classes and interfaces, you
can use @see, @author, @deprecated, @param, and @version. Methods can be documented
with @see, @return, @param, @deprecated, @throws, @serialData, , and
@exception. A , , , , @since, or  tag can be
used anywhere. Each tag is examined next.
@author
The @author tag documents the author of a class or interface. It has the following syntax:
@author description
Here, description will usually be the name of the a uthor. You will need to specify the -author
option when executing javadoc in order for the @author field to be included in the HTML
documentation.

The  tag enables you to embed text, such as a snippet of code, into a comment. That
text is then displayed as is in code font, without any further processing, such as HTML
rendering. It has the following syntax:

@deprecated
The @deprecated tag specifies that a class, interface, or a member is deprecated. It is
recommended that you include @see or  tags to inform the programmer about
available alternatives. The syntax is the following:
@deprecated description
Here, description is the message that describes the deprecation. The @deprecated tag can be
used in documentation for variables, methods, classes, and interfaces.Chapter A:
U s i n g J a v a ’s D o c u m e n t a t i o n C o m m e n t s

 specifies the path to the root directory of the current documentation.
@exception
The @exception tag describes an exception to a method. It has the following syntax:
@exception exception-name explanation
Here, the fully qualified name of the exception is specified by exception-name, and explanation
is a string that describes how the exception can occur. The @exception tag can only be used
in documentation for a method.

This tag inherits a comment from the immediate superclass.

The  tag provides an in-line link to additional information. It has the following syntax:

Here, pkg.class#member specifies the name of a class or method to which a link is added, and
text is the string that is displayed.

Inserts an in-line link to another topic. The link is displayed in plain-text font. Otherwise,
it is similar to .

The  tag enables you to embed text into a comment. That text is then displayed as is,
without any further processing, such as HTML rendering. It has the following syntax:

Here, description is the text that is embedded.
@param
The @param tag documents a parameter to a method or a type parameter to a class or
interface. It has the following syntax:
@param parameter-name explanation
Here, parameter-name specifies the name of a parameter. The meaning of that parameter is
described by explanation. The @param tag can be used only in documentation for a method
or constructor, or a generic class or interface.
@return
The @return tag describes the return value of a method. It has the following syntax:
@return explanation
Here, explanation describes the type and meaning of the value returned by a method. The
@return tag can be used only in documentation for a method.
993994
Part IV:
Applying Java
@see
The @see tag provides a reference to additional information. Its most commonly used forms
are shown here:
@see anchor
@see pkg.class#member text
In the first form, anchor is a link to an absolute or relative URL. In the second form,
pkg.class#member specifies the name of the item, and text is the text displayed for that item.
The text parameter is optional, and if not used, then the item specified by pkg.class#member
is displayed. The member name, too, is optional. Thus, you can specify a reference to a
package, class, or interface in addition to a reference to a specific method or field. The name
can be fully qualified or partially qualified. However, the dot that precedes the member name
(if it exists) must be replaced by a hash character.
@serial
The @serial tag defines the comment for a default serializable field. It has the following syntax:
@serial description
Here, description is the comment for that field.
@serialData
The @serialData tag documents the data written by the writeObject( ) and writeExternal( )
methods. It has the following syntax:
@serialData description
Here, description is the comment for that data.
@serialField
For a class that implements Serializable, the @serialField tag provides comments for an
ObjectStreamField component. It has the following syntax:
@serialField name type description
Here, name is the name of the field, type is its type, and description is the comment for that field.
@since
The @since tag states that a class or member was introduced in a specific release. It has the
following syntax:
@since release
Here, release is a string that designates the release or version in which this feature became
available.
@throws
The @throws tag has the same meaning as the @exception tag.Chapter A:
U s i n g J a v a ’s D o c u m e n t a t i o n C o m m e n t s

 has two forms. The first displays the value of the constant that it precedes, which
must be a static field. It has this form:

The second form displays the value of a specified static field. It has this form:

Here, pkg.class#field specifies the name of the static field.
@version
The @version tag specifies the version of a class. It has the following syntax:
@version info
Here, info is a string that contains version information, typically a version number, such as
2.2. You will need to specify the -version option when executing javadoc in order for the
@version field to be included in the HTML documentation.
The General Form of a Documentation Comment
After the beginning /**, the first line or lines become the main description of your class, variable,
or method. After that, you can include one or more of the various @ tags. Each @ tag must
start at the beginning of a new line or follow one or more asterisks (*) that are at the start of
a line. Multiple tags of the same type should be grouped together. For example, if you have
three @see tags, put them one after the other. In-line tags (those that begin with a brace) can
be used within any description.
Here is an example of a documentation comment for a class:
/**
* This class draws a bar chart.
* @author Herbert Schildt
* @version 3.2
*/
What javadoc Outputs
The javadoc program takes as input your Java program’s source file and outputs several
HTML files that contain the program’s documentation. Information about each class will be
in its own HTML file. javadoc will also output an index and a hierarchy tree. Other HTML
files can be generated.
An Example that Uses Documentation Comments
Following is a sample program that uses documentation comments. Notice the way
each comment immediately precedes the item that it describes. After being processed
995996
Part IV:
Applying Java
by javadoc, the documentation about the SquareNum class will be found in
SquareNum.html.
import java.io.*;
/**
* This class demonstrates documentation comments.
* @author Herbert Schildt
* @version 1.2
*/
public class SquareNum Index
Symbols
&
bitwise AND, 62, 63, 64–65
Boolean logical AND, 71, 72
and bounded type declarations, 326
&& (short-circuit AND), 71, 72–73
*
multiplication, 26, 57
regular expression quantifier, 827
used in import statement, 191, 311
@
annotation syntax, 272
tags (javadoc), 991–995
|
bitwise OR, 62, 63, 64–65
Boolean logical OR, 71, 72
|| (short-circuit OR), 71, 72–73
[ ], 31, 48, 51, 55, 74, 75, 827, 831
^
bitwise exclusive OR, 62, 63, 64–65
Boolean logical exclusive OR, 71, 72
: (used with a label), 100
, (comma), 31, 90–91
, 23, 24, 29, 31, 42, 50, 53, 77, 78, 84, 208
=, 25, 73
= = (Boolean operator), 71
= = (relational operator), 26, 70, 256, 262
versus equals( ), 368–369
!, 71, 72
!=, 70, 71
/, 57
/* */, 23
/** */, 31, 991
//, 23
<, 26, 70
< >, 317, 318, 324, 336
<<, 62, 65–66
<=, 70
–, 57
– –, 29, 57, 60–61
%
used in format conversion specifier
syntax, 527
modulus operator, 57, 59
( ), 24, 31, 74–75
.
dot operator, 74, 75, 107, 113–114, 142, 184,
190
regular expression wildcard character, 827,
830–831
separator, 31
... (variable-length argument syntax), 152, 153
+
addition, 57
concatenation operator, 25–26, 148–149,
362–364, 377, 380
regular expression quantifier, 827, 830–831
++, 28–29, 58, 57, 60–62
?
regular expression quantifier, 827, 830–831
wildcard argument specifier, 328, 334, 347
?: (ternary operator), 71, 73–74
>, 26, 70
>>, 62, 66–68
>>>, 62, 68–69
>=, 70
; (semicolon), 24, 31, 85
~, 62, 63, 64–65
A
abs( ), 128, 420
abstract type modifier, 177–178, 181, 196
Abstract Window Toolkit (AWT), 285, 297, 299,
617, 663, 701
and applet architecture, 625
classes, table of some, 664–665
creating stand-alone windows with,
674–676
support for imaging, 755
support for text and graphics, 676
and Swing, 663, 859, 860
AbstractButton class, 883, 885, 886
AbstractCollection class, 448, 450, 457
AbstractList class, 448, 488
AbstractMap class, 468, 470, 472
AbstractQueue class, 448, 456
AbstractSequentialList class, 448, 451
997998
Java: The Complete Reference
AbstractSet class, 448, 451, 455, 458
accept( ), 560, 561, 613
Access control, 138–141
example program, 187–190
and packages, 183, 186–187
Access specifiers, 23, 138, 186–187
acos( ), 419
acquire( ), 790–793
ActionEvent class, 640–641, 704, 714, 738, 870,
881, 883, 890
ActionListener interface, 650, 704, 714, 738,
870, 883, 890
actionPerformed( ), 650, 704, 870, 871, 883, 890
Adapter classes, 659–660
add( ), 441, 442, 443–444, 453, 459, 667, 702,
706, 711, 713, 726, 730, 738, 866–867, 889, 901
addActionListener( ), 870
addAll( ), 441, 442, 443, 476
addCookie( ), 44, 920, 926
addElement( ), 488, 489
addFirst( ), 447–448, 452
addImage( ), 762, 763
addItem( ), 899
addLast( ), 447–448, 452, 453
addMouseListener( ), 655–618
addMouseMotionListener( ), 655–618
Addressing, Internet, 600
addTab( ), 891, 892
addTListener( ) 849–850
addTypeListener( ), 638, 639
AdjustmentEvent class, 640, 641–642, 717
AdjustmentListener interface, 650, 651, 717
adjustmentValueChanged( ), 651
Algorithms, collection, 438, 475–480
ALIGN, 630
allocate( ), 817, 819
ALT, 629
AND operator
bitwise (&), 62, 63, 64–65
Boolean logical (&), 71, 72
and bounded type declarations, 326
short-circuit (&&), 71, 72–73
Animation, cell, 783–785
AnnotatedElement interface, 278, 280, 436
Annotation interface, 272, 278, 435
Annotation(s), 13, 14, 272–284
applying, 272–273
built-in, 282–283
declaration, 272
marker, 280–281
member, default value for, 279–280
obtaining all, 277–278
restrictions on, 284
retention policy for, specifying, 273
single-member, 281–282
using reflection to obtain, 273–278
annotationType( ), 272
Annuity for a given investment, maximum
applet for finding, 23–955
formula to compute, 952
Annuity, initial investment needed for desired
applet for finding, 947–951
formula to compute, 947–948
Apache Software Foundation, 908
API packages, table of core Java, 813–815
append( ), 380, 434, 580, 722
Appendable interface, 434, 529, 574, 579, 586
appendCodePoint( ), 383
Applet, 8, 14, 296–299
architecture, 620, 625
basics, 617–620
colors, setting and obtaining, 623–624
examples for financial calculations, 932–959
executing, 297–299, 617, 628–630
and the Internet, 8–9
and main( ), 24, 106, 297, 299, 617
outputting to console, 636
passing parameters to, 630–643
request for repaint, 625–628
skeleton, 621–623
and socket connections, 603
as source and listener for events, 655–656
string output to, 625
Swing, 617, 618, 863, 871–873
viewer, 297–299, 617, 628, 667
Applet class, 297, 617–636, 650, 655, 667, 871
methods, table of, 618–620
applet package, 285, 297
APPLET tag, HTML, 298, 299, 618
full syntax for, 629–630
AppletContext interface, 617, 633, 634–635
methods, table of, 635
AppletStub interface, 617, 635
appletviewer, 298, 617
status window, using, 628
Application launcher (java), 22
and main( ), 23–24
ARCHIVE, 630
AreaAveragingScaleFilter class, 770
areFieldsSet, 509
Argument(s), 112, 116
command-line, 24, 150–151Index
index, 538–539
passing, 132–134
type. See Type argument(s)
variable-length. See Varargs
wildcard. See Wildcard arguments
Arithmetic operators, 57–62
ArithmeticException, 207, 208, 218
Array class, 436
Array(s), 24, 48–55, 143
boundary checks, 50
converting collections into, 441, 442,
450–451
copying with arraycopy( ), 409, 410–411
declaration syntax, alternative, 55
dynamic, 448–451, 457, 487
and the for-each loop, 92–97
and generics, 355–356
initializing, 50, 53–54
length instance variable of, 143–145
multidimensional, 51–55
one-dimensional, 48–51
of strings, 150
and valueOf( ), 375
and varargs, 152–153
ArrayBlockingQueue class, 808
arraycopy( ), 409, 411–412
ArrayDeque class, 457, 493
ArrayIndexOutOfBoundsException, 210, 218,
481, 482, 483
ArrayList class, 448–451, 463
Arrays class, 480–484
ArrayStoreException, 218, 481
ASCII character set, 37, 38, 41
and strings on the Internet, 360–361, 366
asin( ), 419
asList( ), 480
Assembly language, 4, 5
assert, 13, 306–309
Assertion, 306–309
AssertionError, 306
Assignment operator(s)
=, 25, 73
arithmetic compound (op=), 57, 59–60
bitwise compound, 60, 69–70
Boolean logical, 71
atan( ), 419
atan2( ), 419
Atomic operations, 811–812
AtomicInteger class, 811–812
AtomicLong class, 811
AudioClip interface, 617, 635
Autoboxing/unboxing, 13, 14, 265, 266–272, 319
Boolean and Character values, 270
and the Collections Framework, 439–440, 451
definition of, 266
and error prevention, 271
and expressions, 268–270
and methods, 267–268
when to use, 271–272
available( ), 563, 564–565, 595, 596
await( ), 795, 796, 797, 798, 808
AWT. See Abstract Window Toolkit
AWTEvent class, 640
bit mask constants, 749
B
B, 4
BASIC, 4
BCPL, 4
BeanInfo interface, 848, 850
Beans, Java. See Java Beans
Bell curve, 517
Bell Laboratories, 6
Berkeley UNIX, 599
Berners-Lee, Tim, 605
Beyond Photography, The Digital Darkroom
(Holzmann), 766
binarySearch( ), 480
BitSet class, 505–507
methods, table of, 505–506
Bitwise operators, 62–70
Blocks, code. See Code blocks
Boolean
literals, 40
logical operators, 71–73
Boolean class, 265, 270, 402
methods, table of, 402–403
boolean data type, 33, 34, 38–39
and relational operators, 70–71
booleanValue( ), 265, 402
Border interface, 878
BorderFactory class, 878
BorderLayout class, 664, 725–727, 870
Borenstein, Nat, 611
Boxing, 266
break statement, 81–83, 98–102
and the for-each loop, 94
as form of goto, 100–102
Buffer class, 816–817
methods, table of, 816
Buffer, NIO, 815–817
9991000
Java: The Complete Reference
BufferedInputStream class, 287, 569–571
BufferedOutputStream class, 287, 569, 571
BufferedReader class, 287, 289, 290–291,
583–585
BufferedWriter class, 287, 585
Buffering, double, 759–762
Button class, 704
extending, 749–750
ButtonGroup class, 889
ButtonModel interface, 861, 883
Buttons, Swing, 883–891
ButtonUI, 861
Byte class, 265, 390, 396, 397
methods defined by, table of, 391
byte data type, 33, 34, 35, 40
ByteArrayInputStream class, 287, 567–568
ByteArrayOutputStream class, 287,
568–569
ByteBuffer class, 817, 819, 821
get( ) and put( ) methods, table of, 817
Bytecode, 9–10, 12, 13, 14, 22, 314, 422
byteValue( ), 265, 386, 387, 388, 391, 392,
393, 395
C
C
history of, 4–5
and Java, 3, 5, 7, 10
C Programming Language, The (Kernighan and
Ritchie), 4
C++
history of, 5–6
and Java, 3, 7, 10
C# and Java, 8
Caches, 630
Calendar class, 507, 508, 509–512, 516
constants, 511
methods defined by, table of, 509–510
Call-by-reference, 132, 133–134
Call-by-value, 132–133, 134
call( ), 804
Callable interface, 788, 804, 805
cancel( ), 522, 523
Canvas class, 664, 667
capacity( ), 378, 489, 816
capacityIncrement Vector data member, 488
CardLayout class, 664, 730–732
CaretEvent class, 881
Case sensitivity and Java, 22, 23, 30
case statement, 81–83, 84
Casts, 45–47, 48, 316, 318, 319, 320, 321, 322
and casting one instance of a generic class
into another, 348
and erasure, 349–350
using instanceof with, 300–302
catch block(s), 205, 207–211
displaying exception description within, 209
using multiple, 209–211
cbrt( ), 419
ceil( ), 420
CGI (Common Gateway Interface), 10, 907–908
Channel(s), 815, 818
char data type, 33, 34, 37–38, 58
Character class, 265, 270, 398–402
methods, table of, 399–400, 401–402
support for 32-bit Unicode, 401–402
Character(s), 34, 37–38
changing case of, 375–376
classes (regular expressions), 827, 831
escape sequences, table of, 41
extraction from String objects, 365–366
literals, 40
supplemental, 401
Character.Subset class, 385, 400
Character.UnicodeBlock class, 385, 400
CharArrayReader class, 287, 582
CharArrayWriter class, 287, 582–583
charAt( ), 149–150, 365, 379, 433
CharBuffer class, 433, 817
CharSequence interface, 359, 381, 384, 433, 826
Charsets, 818–819
charValue( ), 265, 398
Check boxes, 620, 707–710
Swing, 887–889
checkAll( ), 763
Checkbox class, 707
extending, 750–751
CheckboxGroup class, 709–710
extending, 751–752
CheckboxMenuItem class, 737, 738
checked... methods, 476, 478
checkedCollection( ), 476, 478
checkedList( ), 476, 478
checkedMap( ), 476, 478
checkedSet( ), 476, 478
checkID( ), 762–763
Choice class, 711
extending, 752
Choice controls, 711–713
Class class, 273–274, 277, 278, 415–418, 833
methods, table of, 415–417Index
.class file, 22, 108
class keyword, 23, 105
CLASS retention policy, 273
Class(es), 105–124
abstract, 177–180, 181, 196
access levels of, 187
adapter, 659–660
and code, 21, 186
in collections, storing user-defined, 462–463
constructor. See Constructor(s)
controlling access to. See Access control
definition of, 17
encapsulation achieved through, 122
final, 181
general form of, 105–106
generic. See Generic class
inner, 145–148, 661–663
and interfaces, 192, 193, 194, 196
libraries, 21, 32
literal, 275
member. See Member, class
name and source file name, 22
nested, 145
packages as containers for, 183, 186
public, 187
scope, 43
ClassCastException, 218, 441, 442–443, 444,
445, 446, 464, 465, 466, 473, 478, 480, 483
ClassDefinition class, 435
ClassFileTransformer interface, 435
ClassLoader class, 418
ClassNotFoundException, 218, 595
CLASSPATH, 184, 185, 839
–classpath option, 185
clear( ), 441, 442, 465, 495, 505, 509, 816
Client/server model, 8, 10, 599
clone( ), 181, 412, 413–415, 432, 489, 495, 505,
508, 509, 514, 920
Cloneable interface, 413–415
CloneNotSupportedException, 218, 413
close( ), 294, 527, 549, 562, 563, 580, 594,
595, 596
Closeable interface, 561–562, 574, 578, 579, 586
COBOL, 4
CODE, 629, 630
Code base, 633
Code blocks, 26, 29–30, 42
static, 141–142
Code point, definition of, 401
Code unit, definition of, 401
CODEBASE, 629
codePointAt( ), 376, 383, 401
codePointBefore( ), 376, 383, 401
codePointCount( ), 376, 383
Collection interface, 440, 441
methods defined by, table of, 442
Collection-view, 439, 464–465
Collection(s), 315, 437–502
algorithms, 438, 475–480
into arrays, converting, 441, 442, 450–451
and autoboxing, 439–440, 451
classes, 448–458
Framework. See Collections Framework
interfaces, 438, 440–445
iterator, 438, 440, 458–462
and legacy classes and interfaces, 487
modifiable vs unmodifiable, 440
storing user-defined classes in, 462–463
and synchronization, 448, 479, 487
and type safety, 439, 475, 478
when to use, 502
Collections class, 438, 475–480
algorithms defined by, table of, 476–478
Collections Framework, 13, 92, 97, 267,
437–502
advantages of generics as applied to, 439,
484–487
changes to, 315, 439–440
overview, 438–439
Color class, 664, 682–684
constants 623–624
Combo boxes, Swing, 898–900
ComboBoxModel interface, 899
Comment, 22–23
documentation, 31, 991–996
Common Gateway interface (CGI), 10, 907–908
Comparable interface, 338, 433–434, 507, 559
Comparator interface, 440, 470, 472–473
comparator( ), 444, 456, 466
Comparators, 470, 472–475
compare( ), 387, 388, 473
compareAndSet( ), 789, 811
compareTo( ), 261, 262, 369–370, 387, 388, 391,
392, 393, 395, 400, 402, 432, 433–434, 508, 559
compareToIgnoreCase( ), 370
Compilation unit, 21
compile( ), 825–826
Compiler class, 422
Compiler, Java, 22
and main( ), 23–24
10011002
Java: The Complete Reference
Component class, 618, 621, 623, 624, 626,
639, 650, 655, 664, 666, 667, 670, 702, 756,
862, 863, 874
componentAdded( ), 651
ComponentEvent class, 640, 642, 643
componentHidden( ), 651
ComponentListener interface, 650, 651
componentMoved( ), 651
componentRemoved( ), 651
componentResized( ), 651
Components, Swing, 862–863
class names for, table of, 862
heavyweight, 859
lightweight, 860, 879
painting, 873–878
componentShown( ), 651
ComponentUI, 861
concat( ), 373
Concurrency utilities, 14, 787–812
vs traditional multithreading and
synchronization, 812
Concurrent API, 787
packages, 788–789
Concurrent collection classes, 788, 808
Concurrent program, definition of, 787
ConcurrentHashMap class, 788, 808
ConcurrentLinkedQueue class, 788, 808
ConcurrentSkipListMap class, 808
ConcurrentSkipListSet class, 808
Condition class, 808
connect( ), 604
Console class, 556, 587–589
methods, table of, 588
console( ), 409, 587
const keyword, 32
Constants, 31
Constructor class, 274, 277, 278, 436, 833–834
Constructor(s), 110, 117–120
in class hierarchy, order of calling, 170–171
default, 110, 119
enumeration, 259–261
factory methods versus overloaded, 601
object parameters for, 131–132
overloading, 128–130
parameterized, 119–120
and super( ), 163–166, 170, 314
this( ) and overloaded, 312–314
Container class, 618, 664, 666–667, 702, 723,
862, 863, 875
ContainerEvent class, 640, 642–643
ContainerListener interface, 650, 651
Containers, Swing, 862, 863
lightweight versus heavyweight, 863
Containment hierarchy, 862, 863
contains( ), 376, 441, 442, 453, 489, 495
containsAll( ), 441, 442
Content pane, 863, 866, 867
default layout manager of JFrame, 867, 870
contentEquals( ), 376
Context switching, 254
rules for, 224–225
continue statement, 102–103
Control statements. See Statements, control
Controls, 701–723
fundamentals, 701–702
convert( ), 807
Convolution filters, 772, 777
Cookie class, 917, 919–920
methods, table of, 920
CookieHandler class, 612
CookieManager class, 612
CookiePolicy interface, 612
Cookies, example servlet using, 925–927
CookieStore interface, 612
copyOf( ), 458, 480–481
copyOfRange( ), 481
CopyOnWriteArrayList class, 788, 808
CopyOnWriteArraySet class, 808
cos( ), 418
cosh( ), 419
countDown( ), 795, 796
CountDownLatch class, 788, 795–796
countStackFrames( ), 423
createImage( ), 756, 765, 770
createLineBorder( ), 878
CropImageFilter class, 770–772
Currency class, 524–525
methods, table of, 525
currentThread( ), 226, 227, 423
currentTimeMillis( ), 409, 410–411
CyclicBarrier class, 788, 796–799
D
Data type(s)
casting, 46–47, 48
class as, 105, 107, 109, 110
conversion, automatic, 33, 45–46, 126–127
conversion into string representation,
364–365, 374–375
primitive, 33–34, 264–265, 320
promotion of, 35, 47–48Index
simple, 33
wrappers for primitive, 264–266, 386–403
DatagramPacket class, 613, 614–615
Datagrams, 600, 613–616
server/client example, 615–616
DatagramSocket class, 613–614, 818
DataInput interface, 576, 577, 578, 595
DataInputStream class, 287, 576, 577
DataOutput interface, 576, 578, 593
DataOutputStream class, 287, 576–577
Date class, 507–509, 840
methods, table of, 508
DateFormat class, 507, 516, 525, 840–842
Deadlock, 423
Decrement operator (– –), 29, 57, 60–61
decrementAndGet( ), 789, 811
deepEquals( ), 482
deepHashCode( ), 483
deepToString( ), 483
default
clause for annotation member, 279
statement, 81–82
DefaultMutableTreeNode class, 901
DelayQueue class, 808
Delegation event model, 638–639
and Beans, 849
event listeners, 638, 639, 650–653
event sources, 638, 638–639, 649–650
using, 653–658
delete operator, 121
delete( ), 382, 558
deleteCharAt( ), 382
deleteOnExit( ), 558
delimiter( ), 547
Delimiters, 503, 590
Scanner class, 541, 547–548
@Deprecated built-in annotation, 282, 283
Deque interface, 440, 446–448, 451, 452, 457
methods, table of, 447
descendingIterator( ), 446, 447
destroy( ), 403, 407, 423, 425, 618, 621, 622, 623,
625, 871, 908, 910, 912, 913
Destructors versus finalize( ), 122
Dialog boxes, 742–748
file, 747–748
Dialog class, 742
Dictionary class, 438, 487, 493–494
abstract methods, table of, 493
digit( ), 400
Dimension class, 664, 668, 681
Directories as File objects, 556, 559–560
creating, 561
dispose( ), 742
DLL (dynamic link library), 303, 304, 305, 306
do-while loop, 86–88
Document base, 633
Document interface, 881
Document/view methodology, 522
@Documented built-in annotation, 282
doDelete( ), 921, 922
doGet( ), 921, 922, 923
doHead( ), 921, 922
Domain name, 600
Domain Naming Service (DNS), 600
doOptions( ), 921, 922
doPost( ), 921, 922, 924
doPut( ), 921, 922
Dot operator (.), 74, 75, 107, 113–114, 142,
184, 190
doTrace( ), 921, 922
Double buffering, 759–762
Double class, 265, 386–390
methods, table of, 388–389
double data type, 33, 36–37, 40
doubleValue( ), 265, 386, 387, 388, 391, 392,
393, 395
Download Manager, 965–990
compiling and running, 989
enhancing, suggestions for, 990
overview of, 966
Downloads, Internet
operation of, 966
resuming interrupted, 965
Drag-and-Drop API, 882
drawArc( ), 679–680
drawImage( ), 757, 760, 761–762
drawLine( ), 677, 874
drawOval( ), 678–679
drawPolygon( ), 680–681
drawRect( ), 677, 874
drawRoundRect( ), 678
drawString( ), 297, 618, 623, 625, 692
Dynamic link library (DLL), 303, 304, 305, 306
Dynamic method
dispatch, 174–175
lookup, 195
resolution, 193
E
E (double constant), 418
Early binding, 180
echoCharIsSet( ), 720
Edit control, 719
10031004
Java: The Complete Reference
element( ), 446
elementAt( ), 488, 489
elementCount Vector data member, 488
elementData[ ] Vector data member, 488
elements( ), 489, 493, 494, 495
ElementType enumeration, 283, 435
else, 77–80
empty( ), 491, 492
EMPTY_LIST static variable, 479
EMPTY_MAP static variable, 479
EMPTY_SET static variable, 479
EmptyStackException, 491, 493
enableEvents( ), 748–749, 753
Encapsulation, 16–17, 19, 20–21, 122–123
and access control, 138
and scope rules, 43
end( ), 826
endsWith( ), 368
ensureCapacity( ), 378, 450, 489
entrySet( ), 464, 465, 467, 469, 496
enum, 255, 432, 458, 472
Enum class, 261, 432
methods, table of, 432–433
EnumConstantNotPresentException, 218
enumerate( ), 423, 425, 429
Enumeration interface, 487, 489, 491, 503, 504
program demonstrating, 489–491
Enumeration(s), 14, 255–264, 491
= = relational operator and, 256, 262
as a class type in Java, 255, 259–261
constants, 255, 256, 259, 260, 261–262
constructor, 259–261
restrictions, 261
values in switch statements, using, 256–257
variable, declaring an, 256
EnumMap class, 468, 472
EnumSet class, 448, 458
methods, table of, 458
Environment properties, list of, 412
eolIsSignificant( ), 590–591
equals( ), 149–150, 181–182, 261–262, 272,
366–367, 387, 388, 391, 392, 393, 395, 400, 402,
412, 431, 432, 441, 442, 465, 467, 473, 474, 481,
494, 505, 508, 509, 602
versus = =, 368–369
equalsIgnoreCase( ), 367
Erasure, 318, 349–353, 354
and ambiguity errors, 353–354
bridge methods and, 351–353
err, 288, 409
Error class, 206, 215, 221, 587
Errors
ambiguity, 353–354
autoboxing/unboxing and prevention
of, 271
compile-time vs run-time, 321–322
generics and prevention of, 320–322
raw types and run-time, 341
run-time, 12, 205
Event
delegation model, definition of, 638
design patterns, 849–850
dispatching thread and Swing, 867–868,
871, 873
driven programs, 637
multicasting and unicasting, 638–639, 850
Event handling, 620, 637–662
and adapter classes, 659–660
event classes, 639–649
by extending AWT components, 638,
748–754
and inner classes, 660–662
keyboard, 656–658
mouse, 653–656
and Swing, 868–871
See also Delegation event model
EventListener interface, 553
EventListenerProxy class, 553
EventObject class, 553, 639, 640, 921
EventSetDescriptor class, 850, 851, 852, 854
Exception class, 206, 219–220, 221
Exception classes and generics, 356
Exception handling, 12, 88, 98, 205–222, 296
block, general form of, 205–206
and chained exceptions, 13, 220, 221–222
and creating custom exceptions, 219–221
and default exception handler, 206–207, 213
Exceptions, built-in run-time, 205, 206, 207, 217
checked, table of, 218
constructors for, 214
unchecked RuntimeException, table of, 218
exchange( ), 799, 801
Exchanger class, 788, 799–801
exec( ), 403, 404, 406–407
execute( ), 801
Executor interface, 788, 801, 802
Executors, 788
using, 801–806
Executors class, 788, 802
ExecutorService interface, 788, 801, 802, 804
exists( ), 557
exitValue( ), 403, 407Index
exp( ), 419
expm1( ), 419
Expressions
and autoboxing/unboxing, 268–270
regular. See Regular expressions
extends, 157, 158, 202, 325, 329
and bounded wildcard arguments, 331, 334
Externalizable interface, 593
F
false, 32, 39, 40, 71
FALSE, 402
Field class, 274, 277, 278, 436, 833–834
fields, 509
File class, 540, 556–561, 564, 574, 587
methods, demonstration of some, 557–558
File(s)
I/O, 293–296, 556–561
pointer, 578
source, 21–22, 106
FileChannel class, 818, 819, 821
FileDialog class, 747–748
FileFilter interface, 561
FileInputStream class, 287, 293–294, 564–565,
818, 819, 821
FilenameFilter interface, 560–561
FileNotFoundException, 294, 564, 566, 579
FileOutputStream class, 287, 293–294, 295,
565–567, 818
FileReader class, 287, 540, 579
FileWriter class, 287, 579, 580
fill( ), 482
fillArc( ), 679–680
fillInStackTrace( ), 219
fillOval( ), 678–679
fillPolygon( ), 680–681
fillRect( ), 677
fillRoundRect( ), 678
FilteredImageSource class, 765, 770
FilterInputStream class, 287, 569, 577
FilterOutputStream class, 287, 569, 576
FilterReader class, 287
FilterWriter class, 287
final
to prevent class inheritance, 181
to prevent method overriding, 180
variables, 143
finalize( ), 121–122, 181, 412
finally block, 205, 216–217
Financial calculations, applets and servlets for,
931–963
find( ), 826, 828–829, 830
findInLine( ), 548–549
findWithinHorizon( ), 549
Finger protocol, 600, 605
Firewall, 9
first( ), 444, 730
firstElement( ), 488, 489
firstKey( ), 465, 466
Float class, 265, 386–388, 390
methods, table of, 387–388
float data type, 33, 36, 40
Floating-point(s), 33, 36–37
literals, 40
floatValue( ), 265, 386, 387, 388, 391, 392,
393, 395
floor( ), 420
FlowLayout class, 664, 724–725, 870
flush( ), 527, 562, 563, 571, 580, 588, 594
Flushable interface, 561, 562, 574, 579, 586, 587
FocusEvent class, 640, 642, 643
focusGained( ), 651
FocusListener interface, 650, 651
focusLost( ), 651
Font class, 664, 686–687, 690, 691
methods, table of, 687
Font(s), 686–699
creating and selecting, 689–690
determining available, 687–688
information, obtaining, 690–691
metrics to manage text output, using,
691–699
terminology used to describe, 692
FontMetrics class, 664, 691–692, 693
methods, table of, 692
for loop, 27–30, 88–98
enhanced. See For-each version of the
for loop
variations, 91–92
For-each version of the for loop, 14, 89, 92–97
and arrays, 92–97
and the break statement, 94
and collections, 92–93, 97, 440, 461–462
general form, 92
and the Iterable interface, 434, 440, 461
and maps, 464
forDigit( ), 400
Format conversion specifiers, 526, 527–539
argument index with, using an, 538–539
and format flags, 535–537
and specifying minimum field width,
533–534
and specifying precision, 534–535
10051006
Java: The Complete Reference
suffixes for the time and date, table of,
531–532
table of, 528
uppercase versions of, 537–538
Format flags, 535–537
format( ), 376, 526–528, 576, 587, 588, 840
Formattable interface, 553
FormattableFlags class, 553
Formatter class, 525–539, 575
constructors, 526
methods, table of, 527
See also Format conversion specifiers
forName( ), 415, 833
FORTRAN, 4, 5
Frame class, 664, 666, 667–668, 669
Frame window(s), 667–676
creating stand-alone, 674–676
handling events in, 670–674
within applet, creating, 668–670
Frank, Ed, 6
freeMemory( ), 404, 405–406
FTP (File Transfer Protocol), 600, 605, 966
Future interface, 788, 804–805
G
Garbage collection, 12, 121, 122, 135, 405,
435, 763
gc( ), 404, 405–406, 409
Generic class
example program with one type parameter,
316–319
example program with two type
parameters, 322–324
general form, 324
hierarchies, 342–349
and instanceof, 345–348
overriding methods in a, 348–349
Generic constructors, 336–337
Generic interfaces, 316, 337–339
and classes, 338–339
Generic method, 316, 334–336. 355
Generics, 13, 14, 267, 315–356
and ambiguity errors, 353–354
and arrays, 355–356
and casts, 316
and the Collections Framework, 315, 439,
484–487, 501
and compatibility with pre-generics code,
339–342, 349
and exception classes, 356
restrictions on using, 354–356
type checking and, 319, 320–322
GenericServlet class, 910, 912, 914, 921
get( ), 443, 453, 464, 465, 468, 493, 494, 495, 505,
510, 612, 804–805, 807, 811
and buffers, 817
getActionCommand( ), 641, 704, 714, 883, 890
getAddListenerMethod( ), 854
getAddress( ), 602, 614
getAdjustable( ), 641
getAdjustmentType( ), 642, 717
getAlignment( ), 703
getAllByName( ), 601, 602
getAllFonts( ), 688
getAndSet( ), 789, 811, 812
getAnnotation( ), 274, 278, 415, 430
getAnnotations( ), 277, 278, 416, 430
getApplet( ), 635
getAppletContext( ), 618, 634
getApplets( ), 635
getAscent( ), 692, 693
getAttribute, 913, 914, 919, 927
getAttributeNames( ), 919, 927
getAudioClip( ), 618–619, 635
getAvailableFontFamilyNames( ), 687–688
getBackground( ), 624
getBeanInfo( ), 853
getBlue( ), 683
getButton(), 647
getByAddress( ), 602
getByName( ), 601
getBytes( ), 366, 566
getCause( ), 219, 221
getChannel( ), 818, 819, 821
getChars( ), 365–366, 379–380, 581
getChild( ), 643
getClass( ), 181, 273, 413, 415, 417–418, 835
getClickCount( ), 646
getCodeBase( ), 619, 633
getColor( ), 684
getComponent( ), 642
getConstructor( ), 274, 416
getConstructors( ), 416, 833
getContainer( ), 642–663
getContentLength( ), 607
getContentPane( ), 867, 870
getContents( ), 551
getContentType( ), 607, 608
getCookies( ), 918, 926
getData( ), 614
getDate( ), 607, 608Index
getDateInstance( ), 840
getDateTimeInstance( ), 842
getDeclaredAnnotations( ), 278, 416, 430
getDeclaredMethods( ), 416, 835
getDefault( ), 514, 516
getDescent( ), 693
getDirectionality( ), 400
getDirectory( ), 747
getDisplayCountry( ), 516
getDisplayLanguage( ), 516
getDisplayName( ), 516
getDocumentBase( ), 619, 633
getEchoChar( ), 720
getErrorStream( ), 403
getEventSetDescriptors( ), 850
getExpiration( ), 607
getExponent( ), 421
GetField inner class, 595
getField( ), 274, 416
GetFieldID( ), 305
getFields( ), 416, 833
getFile( ), 747
getFirst( ), 447, 452
getFollowRedirects( ), 610
getFont( ), 690–691
getForeground( ), 624
getFreeSpace( ), 558
getGraphics( ), 626, 681, 760
getGreen( ), 683
getHeaderField( ), 608
getHeaderFieldKey( ), 608
getHeaderFields( ), 608, 612
getHeight( ), 693, 875
getHostAddress( ), 602
getHostName( ), 602
getIcon( ), 880
getID( ), 423, 514, 640
getImage( ), 619, 635, 756–757
getInetAddress( ), 604, 614
getInitParameter( ), 912
getInitParameterNames( ), 912
getInputStream( ), 403, 407, 604, 608
getInsets( ), 727, 875
getInstance( ), 510, 512, 525
GetIntField( ), 305
getItem( ), 644, 711, 714, 738, 886, 888
getItemCount( ), 711, 714
getItemSelectable( ), 645, 714
getKey( ), 467, 469
getKeyChar( ), 645
getKeyCode( ), 645
getLabel( ), 704, 707, 737
getLast( ), 447, 452
getLastModified( ), 608
getLeading( ), 693
getLength( ), 614
getListenerType( ), 854
getLocale( ), 619
getLocalGraphicsEnvironment( ), 688
getLocalHost( ), 601
getLocalizedMessage( ), 219
getLocalPort( ), 604, 614
getLocationOnScreen( ), 647
getMaximum( ), 717
getMessage( ), 214, 219
getMethod( ), 274, 276, 417, 854
getMethodDescriptors( ), 850
getMethods( ), 417, 833
getMinimum( ), 717
getMinimumSize( ), 723
getModifiers( ), 641, 644, 835
getModifiersEx( ), 644
getName( ), 226, 228, 417, 423, 425, 430, 557,
854, 920, 922, 926
getNewState( ), 649
GetObjectClass( ), 305
getOffset( ), 615
getOldState( ), 649
getOppositeComponent( ), 643
getOppositeWindow( ), 649
getOutputStream( ), 403, 407, 604
getParameter( ), 619, 630, 631, 923, 924
getParent( ), 425, 557
getPath( ), 901, 920
getPoint( ), 646
getPort( ), 604, 614, 615
getPreferredSize( ), 723
getPriority( ), 226, 236, 423
getProperties( ), 409, 497
getProperty( ), 409, 412, 497, 499
getPropertyDescriptors( ), 850
getRed( ), 683
getRemoveListenerMethod( ), 854
getRequestMethod( ), 610
getResponseCode( ), 610
getResponseMethod( ), 610
getRGB( ), 684
getRuntime( ), 404
getScrollAmount( ), 648
getScrollType( ), 648
getSelectedCheckbox( ), 709
getSelectedIndex( ), 711, 713–714, 896
10071008
Java: The Complete Reference
getSelectedIndexes( ), 714
getSelectedItem( ), 711, 713, 899
getSelectedItems( ), 714
getSelectedText( ), 719, 722
getSelectedValue( ), 897
getServletConfig( ), 912, 913
getServletContext( ), 912
getServletInfo( ), 912. 913
getServletName( ), 912
getSession( ), 918, 921, 927
getSize( ), 668, 681
getSource( ), 639, 706, 890
getStackTrace( ), 219, 423, 431
getState( ), 423, 707, 738
getStateChange( ), 645, 714
getStream( ), 635
getSuperclass( ), 417–418
getText( ), 703, 719, 722, 880, 882, 883
getTimeInstance( ), 841
getTotalSpace( ), 558
getUsableSpace( ), 558
getValue( ), 467, 469, 642, 716–717, 920, 922, 926
getWheelRotation( ), 648
getWhen( ), 641
getWidth( ), 875
getWindow( ), 649
getWriter( ), 910
getX( ), 646
getXOnScreen( ), 647
getY( ), 646
getYOnScreen( ), 647
GIF image format, 755–756
Glass pane, 863
Gosling, James, 6
goto keyword, 32
Goto statement, using labeled break as form
of, 100–102
grabPixels( ), 767, 768
Graphics
context, 297, 622, 676
sizing, 681–682
Graphics class, 297, 622, 623, 665, 676, 760
drawing methods, 677–681
GraphicsEnvironment class, 665, 687–688
GregorianCalendar class, 509, 512–513, 516
GridBagConstraints class, 665, 732–735
constraint fields, table of, 733
GridBagLayout class, 665, 732–736
GridLayout class, 665, 728–729
group( ), 826
GZIP file format, 554
H
Hash code, 453
Hash table, 453
hashCode( ), 181, 272, 387, 388, 391, 392, 393,
395, 400, 403, 413, 430, 432, 465, 467, 483, 494,
505, 508
Hashing, 453
HashMap class, 468–469, 471, 472, 494
HashSet class, 448, 453–454
Hashtable class, 448, 487, 494–497
and iterators, 496
legacy methods, table of, 495
hasMoreElements( ), 487, 504
hasMoreTokens( ), 504
hasNext( ), 459, 460
hasNextX( ) Scanner methods, 541, 543
table of, 542
Headers, 608
HeadlessException, 702
headMap( ), 465, 466
headSet( ), 444
Heavyweight
components, 859
containers, 863
HEIGHT, 629
Hexadecimals, 40
as character values, 41
Hierarchical abstraction and classification, 16
and inheritance, 17, 157
High surrogate char, 401
Histogram, 768
Hoare, C.A.R., 225
Holzmann, Gerard J., 766
HotSpot technology, 10
HSB (hue-saturation-brightness) color
model, 683
HSBtoRGB( ), 683
HSPACE, 630
HTML (Hypertext Markup Language), 907
file for an applet, 298, 628
HTTP, 600, 606, 907
downloads, 966
GET requests, handling, 922–923
port, 600
POST requests, handling, 922, 924–925
requests, 908, 614
server example, caching proxy, 611–628
session, stateful, 612
and URLConnection class, 607
HttpCookie class, 612Index
HttpServlet class, 917, 921, 922
methods, table of, 921
HttpServletRequest interface, 917, 927
methods, table of, 918
HttpServletResponse interface, 917
methods, table of, 918–919
HttpSession interface, 917, 927
methods, table of, 919
HttpSessionBindingEvent class, 917, 922
HttpSessionBindingListener interface, 917, 919
HttpSessionEvent class, 917, 921
HttpURLConnection class, 610–612
hypot( ), 421
I
Icon interface, 880
Icons, Swing button, 883
Identifiers, 23, 30–31, 41
IdentityHashMap class, 468, 472
IEEEremainder( ), 421
if statement, 26–27, 29, 77–80, 137
and boolean variables, 78
nested, 79
switch statement versus, 84
if-else-if ladder, 79–80
IllegalAccessException, 215, 218
IllegalArgumentException, 218, 441, 443, 444,
445, 446, 458, 464, 465, 466, 481, 482, 483
IllegalFormatException, 528
IllegalMonitorStateException, 218
IllegalStateException, 218, 441, 446, 826, 917
IllegalThreadStateException, 218
Image class, 665, 755, 756–757
ImageConsumer interface, 767–769, 770
ImageFilter class, 770–782
ImageIcon class, 880
ImageObserver interface, 757, 758–759, 762
ImageProducer interface, 756, 765–767, 770
imageUpdate( ), 758, 762
flags, table of, 759
Images, 755–786
animation of, 783–785
creating, loading, displaying, 756–757
double buffering and, 759–772
stream model for, 770
Imaging, 765
IMG tag, 630
implements clause, 194
and generic interfaces, 338–339
import statement, 190–191
and static import, 309, 311
in, 288, 407, 409
Increment operator (++), 28–29, 57, 60–62
indexOf( ), 370–372, 383, 443, 488, 489
IndexOutOfBoundsException, 218, 443
Inet4Address class, 603
Inet6Address class, 603
InetAddress class, 601–603, 613
InetSocketAddress class, 613
infinity (IEEE floating-point specification
value), 390
InheritableThreadLocal class, 429
Inheritance, 17–19, 20–21, 138, 141, 157–182
and annotations, 284
and enumerations, 261
final and, 180–181
and interfaces, 183, 193, 202–203
multilevel, 167–170
multiple superclass, 159, 183
@Inherited built-in annotation, 282, 283
init( ), 619, 621, 622, 623, 624, 669, 908, 910, 912, 913
and Swing, 871, 873
initCause( ), 219, 221
Inline method calls, 180
Inner classes, 145–148, 660–662
anonymous, 662
InputEvent class, 640, 643–644, 645
InputStream class, 286, 287, 288, 289, 540, 541,
562, 564, 567, 569, 570, 572, 577, 595
methods, table of, 563
objects, concatenating, 573–574
InputStreamReader class, 288, 289
insert( ), 381, 722
Insets class, 727–728, 875
Instance of a class, 17, 105
See also Object(s)
Instance variables
accessing, 107, 113–114, 116
definition of, 17, 106
hiding, 121
static, 141–143
as unique to their object, 107, 108–109
using super to access hidden, 166–167
instanceof operator, 300–302, 463
and generic classes, 345–348
InstantiationException, 218
Instrumentation interface, 435
int, 25, 33, 34, 35
and integer literals, 40
Integer class, 265, 390, 396–398
constructors, 266
methods, table of, 393–394
10091010
Java: The Complete Reference
Integer(s), 33, 34–36, 62–63
literals, 39–40
interface keyword, 183, 192
and annotations, 272
Interface(s), 183, 192–202
general form of, 193
implementing, 194–196
inheritance of, 202–203
member, 196
nested, 196–197
reference variables, 195–196, 200
variables, 193, 200–202
Internet, 3, 6, 7, 8, 15, 599
addresses, obtaining, 603
addressing scheme, 600
and portability, 7, 8, 9
and security, 8–9
Internet Protocol (IP)
addresses, 600
definition of, 599
InterNIC, 604, 605
InterruptedException, 218, 228, 768
Introspection, 848–850, 853
Introspector class, 851–852, 853
intValue( ), 265, 386, 387, 388, 391, 392, 393, 395
Investment, future value of an
applet for finding, 940–943
formula to compute, 940
Investment required to achieve a future value
applet for finding, 943–947
formula to compute, 944
invokeAndWait( ), 868, 873
invokeLater( ), 868, 873
I/O, 24, 285–296, 555–598
channel-based, 3, 815
classes, list of, 555–556
console, 24, 88, 285, 288–293
error handling, 296, 565
file, 293–296, 556–561
formatted. See I/O, formatted
interfaces, list of, 556
new. See NIO
streams. See Stream(s)
I/O, formatted, 525–549
format conversion specifiers. See Format
conversion specifiers
using Formatter, 525–539. See also
Formatter class
using printf( ), 151, 539
using Scanner, 540–549. See also
Scanner class
io package. See java.io package
IOError, 587
IOException, 289, 294, 295, 562, 564, 565, 566,
572, 579, 581, 585, 593, 595, 612, 818
IPv4 (Internet Protocol, version 4), 600, 601
IPv6 (Internet Protocol, version 6), 600, 601
isAbsolute( ), 558
isAlive( ), 226, 234–236, 424
isAltDown( ), 644
isAltGraphDown( ), 644
isAnnotationPresent( ), 278, 280, 430
isBound( ), 604, 614, 854
isClosed( ), 604
isConnected( ), 604, 614
isConstrained( ), 854
isControlDown( ), 644
isDigit( ), 399, 401
isDirectory( ), 559
isEditable( ), 720, 722
isEmpty( ), 376, 441, 442, 465, 489, 493, 494,
495, 505
isEnabled( ), 737
isFile( ), 558
isHidden( ), 559
isInfinite( ), 387, 389, 390
isLeapYear( ), 512–513
isLetter( ), 399, 401
isMetaDown( ), 644
isMulticastAddress( ), 602
isNaN( ), 388, 389, 390
isPopupTrigger( ), 646–647
isPublic( ), 816, 835
isSelected( ), 886, 888, 890
isSet, 509
isShiftDown( ), 644
isTemporary( ), 643
isTimeSet, 509
ItemEvent class, 640, 644–645, 707, 711, 714,
738, 886, 888
ItemListener interface, 650, 651, 707, 711, 738,
886, 888
ItemSelectable interface, 645
itemStateChanged( ), 651, 707, 711, 869,
886, 888
Iterable interface, 434, 441, 461, 464, 488
Iteration statements, 77, 84–98
Iterator, 438, 440, 458–462
and maps, 464
Iterator interface, 438, 440, 458–459, 460, 486
methods, table of, 459
iterator( ), 434, 441, 442, 459, 460Index
J
J2SE 5, new features of, 13–14
Jakarta Project, 908
JApplet class, 617, 863, 871, 873
JAR files, 550
Java
API packages, table of core, 813–815
and C, 3, 5, 7, 11
and C++, 3, 7, 11
and C#, 8
design features (buzzwords), 10–13
history of, 3, 6–8, 13–14
and the Internet, 3, 6, 7–9, 12, 14, 599,
601, 965
as interpreted language, 9, 10, 12
keywords, 31–32
as strongly typed language, 10, 11, 33
versions of, 13–14
and the World Wide Web, 6, 7
Java Archive (JAR) files, 550
Java Beans, 417, 436, 813, 833, 847–857
advantages of, 848
API, 851–854
customizers, 851
demonstration program, 854–857
introspection, 848–850
serialization, 851
Java Community Process (JCP), 14
.java filename extension, 21
Java Foundation Classes (JFC), 860
java (Java application launcher). See
Application launcher (java)
Java Native Interface (JNI), 303
java package, 191
Java SE 6 (Java Platform, Standard
Edition 6), 14
Java Virtual Machine (JVM), 9–10, 12, 13, 14,
22, 23, 404, 422
java.applet package, 617
java.awt package, 637, 640, 664, 755, 870
classes, tables of some, 664–665
java.awt.Dimension class, 833
java.awt.event package, 637, 639, 640, 650, 659,
868, 870
event classes, table of, 640
java.awt.image package, 755, 765, 770, 786
java.beans package, 850, 851–854
classes, table of, 852–853
interfaces, tables of, 852
java.io package, 285, 286, 555–556, 825
java.io.Externalizable interface, 851
java.io.IOException, 88
java.io.Serializable interface, 851
java.lang package, 191, 217, 273, 282, 288, 359,
385–436
classes and interfaces, list of, 385
java.lang.annotation package, 272, 282, 435
java.lang.annotation.RententionPolicy
enumeration, 273
java.lang.image package, 767
java.lang.instrument package, 435
java.lang.management package, 435
java.lang.ref package, 435
java.lang.reflect package, 273, 278, 436, 813,
814, 833
classes, table of, 834
java.net package, 599, 612
classes and interfaces, list of, 600–601
java.nio package, 433, 555, 813, 814, 815
java.nio.channels package, 814, 815, 818, 819
java.nio.channels.spi package, 814, 815
java.nio.charset package, 814, 815, 818
java.nio.charset.spi package, 814, 815
java.rmi package, 813, 814, 837
java.text package, 813, 815, 840
java.util package, 437–438, 503, 637, 639
java.util.concurrent package, 554, 788, 806
java.util.concurrent.atomic package, 554, 788,
789, 811
java.util.concurrent.locks package, 554, 788,
789, 808, 809, 811
java.util.jar package, 554
java.util.logging package, 554
java.util.prefs package, 554
java.util.regex package, 554, 813, 815, 825
java.util.spi package, 554
java.util.zip package, 554
javac (Java compiler), 22
javadoc utility program, 991, 995
javah.exe, 304, 305
javax.imageio package, 786
javax.servlet package, 911–915
interfaces and classes, list of, 911, 912
javax.servlet.http package, 911, 917–922
interfaces and classes, list of, 917
javax.swing package, 862, 864, 865, 879, 901
javax.swing.event package, 868, 881, 896, 901
javax.swing.table package, 904
javax.swing.tree package, 901
JButton class, 863, 870, 883–885
JCheckBox class, 885, 887–889
10111012
Java: The Complete Reference
JComboBox class, 898–900
JComponent class, 862, 863, 871, 873, 875, 879
JDialog class, 863
JDK 6 (Java SE 6 Development Kit), 21
JFrame class, 863, 864, 866, 867, 877
JIT (Just-In-Time) compiler, 10
JLabel class, 864, 866, 879–881
JLayeredPane class, 863
JList class, 895–898
jni.h, 305
jni_md.h, 305
join( ), 226, 234–236, 424
Joy, Bill, 6
JPanel class, 863, 877, 891
JPEG image format, 755–756
JRadioButton class, 885, 889
JRootPane class, 863
JScrollBar class, 863
JScrollPane class, 893–895, 896, 901, 904
JTabbedPane class, 891–893
JTable class, 904–906
JTextComponent class, 881
JTextField class, 881–882
JToggleButton class, 885–887, 889
JToggleButton.ToggleButtonModel class, 886
JTree class, 900–903
Jump statements, 77, 98–104
Just In Time (JIT) compiler, 10
JVM (Java Virtual Machine), 9–10, 12, 13, 14,
22, 23, 404, 422
JWindow class, 863
K
Kernighan, Brian, 4
Key codes, virtual, 645, 657
KeyAdapter class, 659, 660
Keyboard events, handling, 656–658
KeyEvent class, 640, 642, 643, 645
KeyListener interface, 650, 651–652, 656
keyPressed( ), 651–652, 656, 657
keyReleased( ), 651–652, 656
keys( ), 493, 494, 495
keySet( ), 465, 497, 612
keyTyped( ), 651–652, 656, 657
Keywords, table of Java, 32
L
Label
AWT standard control, 702–703
Swing, 864
used with break statement, 100, 102–103
Label class, 702–703
last( ), 444, 730
lastElement( ), 488, 489
lastIndexOf( ), 370–372, 383, 443, 488, 489
lastKey( ), 465, 466
Late binding, 180
Layered pane, 863
Layout managers, 666, 701, 723–736
LayoutManager interface, 723
length instance variable of arrays, 143–145
length( ), 149–150, 362, 378, 433, 505
Lexer, 503
Libraries, class, 21, 32
Lightweight
components, 860
containers, 863
Lindholm, Tim, 6
LineNumberInputStream deprecated class, 556
LineNumberReader class, 288
LinkedBlockingDeque class, 808
LinkedBlockingQueue class, 808
LinkedHashMap class, 468, 471–472
LinkedHashSet class, 448, 454
LinkedList class, 448, 451–453
List class, 713
extending, 752–753
List controls, 713–715
List interface, 440, 441–443, 451, 453, 460, 488
methods, table of, 443
List, Swing, 895–908
list( ) and directories, 556, 559–561
listFiles( ), 561
ListIterator interface, 440, 458–459, 486
methods, table of, 459
listIterator( ), 443, 460
ListModel, 896
ListResourceBundle class, 551
ListSelectionEvent class, 896, 904
ListSelectionListener interface, 896
ListSelectionModel, 896, 904
Literals, 31, 39–41
class, 275
regular expression, 827
string, 362
Loan balance, applet to find, 955–959
Loan payments
applet to compute, 932–939
formula for calculating, 932
servlet to compute, 959–963
load( ), 404, 410, 498, 500–501
loadLibrary( ), 304, 404, 410
Locale class, 376, 515–516, 840, 841Index
Lock interface, 789, 808
methods, table of, 809
lock( ), 789, 808, 809
lockInterruptibly( ), 809
Locks, 808–811
log( )
math method, 419
servlet method, 913, 914
log10( ), 419
log1p( ), 419
Logical operators
bitwise, 63–65
Boolean, 71–73
long, 33, 34, 35–36
literal, 40
Long class, 265, 390, 396, 397
methods, table of, 395
longValue( ), 265, 386, 388, 389, 391, 392,
393, 395
Look and feels, 861
lookup( ), 838
loop( ), 635
Loop(s)
do-while, 86–88
for. See for loop
infinite, 92
nested, 97–98, 99–100, 101
with polling, event, 224, 242–243
while, 84–86
Low surrogate char, 401
M
main( ), 23–24, 106, 138, 141
and applets, 24, 297, 299, 617
and the java application launcher, 23–24
and command-line arguments, 24, 150–151
and Swing programs, 867–868
and windowed applications, 676
main (default name of main thread), 227
MalformedURLException, 606
Map interface, 464–465, 467, 468, 472, 493, 494
methods, table of, 465
map( ), 818, 821, 823
Map(s), 439, 464–472
classes, 468–472
interfaces, 464–467
Map.Entry interface, 464, 467
methods, table of, 467
MappedByteBuffer class, 817, 821
mark( ), 562, 563, 564, 567, 570, 572, 580,
584, 816
markSupported( ), 562, 563, 570, 572, 579,
580, 584
Matcher class, 825, 826–827
matcher( ), 826
matches( ), 376, 826, 828, 833
Math class, 42, 128, 418–421
rounding methods, table of, 420
and static import example, 309–311
max( ), 420, 477, 480
MAX_EXPONENT, 387
MAX_PRIORITY, 236, 422
MAX_RADIX, 398
MAX_VALUE, 387, 391, 398
MediaTracker class, 665, 755, 762–765
Member, class, 17, 106
access and inheritance, 159–160
access, table of, 187
static, 141
Member interface, 436, 833
Memory
allocation using new, 49, 50, 109–110
management, in Java, 12
and Runtime class, 405–406
MemoryImageSource class, 765–767, 770
Menu bars and menus, 701, 737–742
action command string of, 738
Menu class, 737, 738
MenuBar class, 737, 738
MenuItem class, 737, 738
MessageFormat class, 525
Metadata, 272
See also Annotation(s)
Method class, 274, 277, 278, 436, 833–834,
835, 854
Method(s), 17, 106, 111–120
abstract, 177–180
and autoboxing, 267–268
calling, 113, 115
dispatch, dynamic, 174–177
and the dot (.) operator, 107, 114
factory, 601
final, 143, 180
general form, 112
generic, 316, 334–336, 355
getter, 848
hidden, using super to access, 166–167, 172
interface, 193, 194
native, 302–306
10131014
Java: The Complete Reference
overloading, 125–130, 154–156, 173
overriding. See Overriding, method
and parameters, 112, 115–117
passing object to, 133–134
recursive, 135–137
resolution, dynamic, 193
returning object from, 134–135
returning a value from, 114–115
scope defined by, 43–45
setter, 848
static, 141–143
synchronized, 225, 239–241
varargs. See Varargs
MethodDescriptor class, 850, 851, 853, 854
MIME (Multipurpose Internet Mail
Extensions), 611, 612, 907, 910
min( ), 420, 477, 480
minimumLayoutSize( ), 723
MIN_EXPONENT, 387
MIN_NORMAL, 387
MIN_PRIORITY, 236, 422
MIN_RADIX, 398
MIN_VALUE, 387, 391, 398
mkdir( ), 561
mkdirs( ), 561
Model-Delegate architecture, 861–862
Model-View-Controller (MVC)
architecture, 861
Modifier class, 835
methods, table of, 836
Modulus operator (%), 57, 59
Monitor, 225, 238, 239
Mouse events, handling, 653–656
MouseAdapter class, 659
mouseClicked( ), 652, 659
mouseDragged( ), 652, 659
mouseEntered( ), 652
MouseEvent class, 640, 642, 643, 646–647
mouseExited( ), 652
MouseListener interface, 650, 652, 653
MouseMotionAdapter class, 659
MouseMotionListener interface, 639, 650, 652,
653, 659
mouseMoved( ), 652, 659
mousePressed( ), 652
mouseReleased( ), 652
MouseWheelEvent class, 640, 647–648
MouseWheelListener interface, 650,
652, 653
mouseWheelMoved( ), 652
Multitasking, 223, 225
Multithreaded programming, 7, 11, 12, 223–254
context switching. See Context switching
effectively using, 254
Observable class, Observer interface and, 522
and spurious wakeup, 243
and StringBuilder class, 384
and synchronization. See Synchronization
and threads. See Thread(s)
versus the concurrency utilities, 787, 812
versus single-threaded system, 224
MutableComboBoxModel, 899
MutableTreeNode interface, 901
Mutex, 238
MVC (Model-View-Controller)
architecture, 861
N
NAME, 629
Name-space collisions
between instance variables and local
variables, 121
packages and, 183–184, 312
name( ), 433
Naming class, 837, 838
NaN, 387, 390
nanoTime( ), 410, 411
native modifier, 302–303
Natural ordering, 433, 472
Naughton, Patrick, 6
NavigableMap interface, 464, 466, 470
methods, table of, 466–467
NavigableSet interface, 440, 444–445,
455, 456
methods, table of, 445
Negative numbers in Java, representation
of, 62, 63
NEGATIVE_INFINITY, 387
NegativeArraySizeException, 218, 481
.Net Framework, 8
Networking, 599–616
basics, 599–600
classes and interfaces, list of, 600–601
new, 49, 50, 109–110, 117, 119, 121, 135, 178
autoboxing and, 267
and enumerations, 256, 259
New I/O. See NIO
newCachedThreadPool( ), 802
newCondition( ), 808, 809
newFixedThreadPool( ), 802
newScheduledThreadPool( ), 802Index
next( ), 459, 460, 730
nextAfter( ), 420
nextBoolean( ), 517
nextBytes( ), 517
nextDouble( ), 202, 517, 545, 547
nextElement( ), 487, 504
nextFloat( ), 517
nextGaussian( ), 517
nextInt( ), 517
nextLong( ), 517
nextToken( ), 504, 591
nextUp( ), 420
nextX( ) Scanner methods, 541, 543, 545, 547
table of, 543
NIO, 813, 815–825
copying a file using, 824–825
packages, list of, 815
reading a file using, 819–822
writing to a file using, 822–824
NORM_PRIORITY, 236, 422
NoSuchElementException, 444, 446, 465,
543, 549
NoSuchFieldException, 218
NoSuchMethodException, 218, 274
NOT operator
bitwise unary (~), 62, 63, 64–65
Boolean logical unary (!), 71, 72
notepad, 406–407, 408
notify( ), 181, 243, 245–246, 252, 413, 808
notifyAll( ), 181, 243, 413
notifyObservers( ), 518, 519
NotSerializableException, 596
null, 32
Null statement, 85
NullPointerException, 214, 218, 441, 443, 444,
445, 446, 458, 464, 465, 466, 481, 494, 550
Number class, 265, 386
NumberFormat class, 525, 840
NumberFormatException, 218, 266, 631
O
Oak, 6
Object class, 181–182, 292, 316, 412
as data type, problems with using,
320–322, 485
methods, table of, 181, 412–413
Object reference variables
assigning, 111
declaring, 109
and cloning, 413
and dynamic method dispatch, 174–177
interface, 195–196
to superclass reference variable, assigning
subclass, 162
OBJECT tag, 618, 630
Object-oriented programming (OOP), 5, 6,
15–21
model in Java, 11
Object(s), 17, 105, 110
bitwise copy (clone) of, 413
creating, 107, 109–110
initialization with constructor, 117, 119
to method, passing, 133–134
monitor, implicit, 225, 239
as parameters, 130–132
returning, 134–135
serialization of. See Serialization
type at run time, determining, 300–302
Object.notify( ), 808
Object.wait( ), 808
ObjectInput interface, 595
methods defined by, table of, 595
ObjectInputStream class, 287, 595
methods defined by, table of, 596
ObjectOutput interface, 593
methods defined by, table of, 594
ObjectOutputStream class, 287, 593
methods defined by, table of, 594
Observable class, 518–522
methods, table of, 519
Observer interface, 518, 519–522
Octals, 40
as character values, 41
of( ), 458
offer( ), 446, 456
offerFirst( ), 446, 447, 452
offerLast( ), 446, 447, 452
offsetByCodePoints( ), 376, 383
openConnection( ), 607, 608, 610
Operator(s)
arithmetic, 57–62
assignment. See Assignment operator(s)
bitwise, 62–70
Boolean logical, 71–73
parentheses and, 74–75
precedence, table of, 75
relational, 39, 70–71
ternary, 73–74
OR operator (|)
bitwise, 62, 63, 64–65
Boolean, 71, 72
10151016
Java: The Complete Reference
OR operator, short-circuit (||), 71, 72–73
Ordinal value, 261
ordinal( ), 261, 262, 433
out output stream, 24, 288, 407, 409
out( ), 527, 529
OutputStream class, 286, 287, 292, 562, 565,
571, 574, 576, 586, 593
methods, table of, 563
OutputStreamWriter class, 288
Overloading methods, 125–130, 154–156, 173
@Override, built-in annotation, 282, 283
Overriding, method, 171–177
and dynamic method dispatch, 174–177
using final to prevent, 180
P
Package(s), 138, 183–192, 202
access to classes contained in, 186–190
core Java API, table of, 813–815
defining, 184
finding, 184–185
importing, 190–192
Swing, 863–864
Package class, 278, 429–430
methods, table of, 430
package statement, 184, 190
Paint mode, setting, 685–686
paint( ), 297, 621, 622, 623, 624, 625, 626, 670,
676, 758, 871, 874
Paintable area, computing, 875
paintBorder( ), 874
paintChildren( ), 874
paintComponent( ), 874, 878
Painting in Swing, 873–878
Panel class, 618, 665, 666, 667, 730
Panes, top-level Swing container, 863
PARAM NAME, 630
Parameter(s), 24, 43, 112, 115–117
applets and, 630–633
and constructors, 119–120
objects as, 130–132
and overloaded constructors, 130
and overloaded methods, 125
type. See Type parameter(s)
Parameterized types, 316, 317
parseByte( ), 391, 396–397
parseInt( ), 394, 396–397
parseLong( ), 396–397
parseShort( ), 392, 396–397
Parsing, 503
Pascal, 4
Passwords, reading, 587
Pattern class, 825–826
Pattern matching. See Regular expressions
PatternSyntaxException, 827
Payne, Jonathan, 6
peek( ), 446, 491, 492
peekFirst( ), 447, 452
peekLast( ), 447, 452
Peers, native, 859, 860
Persistence (Java Beans), 851
PI (double constant), 418
PipedInputStream class, 287
PipedOutputStream class, 287
PipedReader class, 288
PipedWriter class, 288
PixelGrabber class, 767–769, 770
play( ), 619, 635
Pluggable look and feel (PLAF), 860–861, 862
PNG file format, 756, 757
Point class, 646, 647
Pointers, 56, 109
poll( ), 446, 456
pollFirst( ), 447, 452
Polling, 224, 242–243
pollLast( ), 447, 452
Polygon class, 665, 681
Polymorphism, 19–21
and dynamic method dispatch, 174–177
and interfaces, 192, 195–196, 200
and overloaded methods, 125, 127, 128
pop( ), 446, 447, 491, 492
PopupMenu class, 742
Port, 599
Portability problem, 6–7, 8, 9, 12, 14
and data types, 34
and native methods, 306
and thread context switching, 225
POSITIVE_INFINITY, 387
pow( ), 309–311, 419
preferredLayoutSize( ), 723
previous( ), 459, 730
print( ), 26, 292, 364, 574, 587, 915
printf( )
function, C/C++, 525
method, Java, 151, 539, 575–576, 586, 587
println( ), 24, 26, 292, 364, 574, 575, 586, 587,
588, 915
printStackTrace( ), 219
PrintStream class, 287, 288, 292, 574–576
PrintWriter class, 288, 292–293, 586–587Index
PriorityBlockingQueue class, 808
PriorityQueue class, 448, 456
private access specifier, 23, 138–140, 186–187
and inheritance, 159–160
Process class, 403, 406, 407
methods, table of, 403
Process-based versus thread-based
multitasking, 223
processActionEvent( ), 750, 753
processAdjustmentEvent( ), 749, 753
ProcessBuilder class, 403, 407–408
methods, table of, 408
processComponentEvent( ), 749
processFocusEvent( ), 749
processItemEvent( ), 749, 750, 752, 753
processKeyEvent( ), 749
processMouseEvent( ), 749
processMouseMotionEvent( ), 749
processMouseWheelEvent( ), 749
processTextEvent( ), 749
Programming
multithreaded. See Multithreaded
programming
object-oriented. See Object-oriented
programming (OOP)
structured, 5
Properties class, 438, 487, 497–501
methods, table of, 498
Properties, environment, 412
Property, Java Bean, 848–849
bound and constrained, 850–851
PropertyChangeEvent, 850–851
PropertyChangeListener interface, 851
PropertyDescriptor class, 850, 851, 853, 854,
855–856
PropertyPermission class, 553
PropertyResourceBundle class, 550–551
PropertyVetoException, 851
protected access specifier, 122, 138, 187
public access specifier, 23, 138–139, 186–187
Push buttons, 620, 704–707
action command string of, 704, 705, 707
Swing, 870
push( ), 446, 447, 491, 492
Pushback, 571
PushbackInputStream, 287, 569, 571–572
PushbackReader class, 288, 585–586
put( ), 464, 465, 468, 472, 493, 494, 495
and buffers, 817, 823
putAll( ), 465, 472
PutField inner class, 593
Q
Query string, 923
Queue interface, 445–446, 451, 456
methods, table of, 446
R
Race condition, 240–241
Radio buttons, 709
Swing, 889–891
Radix, 390
radix( ), 549
Random class, 202, 516–518
methods, table of, 517
random( ), 421
RandomAccess interface, 440, 463
RandomAccessFile class, 287, 578, 818, 823
range( ), 458
Raw types, 339–342, 487
and erasure, 351
read( ), 286, 289–290, 294–295, 434–435, 563,
570, 572, 580, 585. 595, 596, 818, 819, 820
and end-of-file condition, 296
Readable interface, 434–435, 540, 579
ReadableByteChannel interface, 540
readBoolean( ), 577
readDouble( ), 577, 596
Reader class, 286, 289, 562, 579, 590
methods defined by, table of, 580
readExternal( ), 593
readInt( ), 577, 596
readLine( ), 290–291, 397, 587, 588, 915
readObject( ), 595, 596
readPassword( ), 587, 588
ReadWriteLock interface, 811
rebind( ), 837
receive( ), 613
Recursion, 135–137
ReentrantLock, 809
ReentrantReadWriteLock, 811
Reflection, 273, 436, 813, 833–836
regionMatches( ), 367–368
Regular expressions, 377, 541, 813, 825–833
syntax, 827
wildcards and quantifiers, 825, 827, 829–831
Relational operators, 39, 70–71
release( ), 790–793
Remote interface, 837
Remote method invocation (RMI), 12, 592, 813,
837–840
10171018
Java: The Complete Reference
RemoteException, 837
remove( ), 441, 442, 443, 446, 453, 459, 465, 493,
494, 495, 702, 867
removeActionListener( ), 870
removeAll( ), 441, 442, 702
removeAttribute( ), 919, 927
removeEldestEntry( ), 472
removeElement( ), 488, 489
removeElementAt( ), 488, 489
removeFirst( ), 447, 452
removeLast( ), 447, 452
removeTListener( ), 850
removeTypeListener( ), 639
renameTo( ), 558
repaint( ), 625–626, 670, 874
demonstration program, 626–628
replace( ), 373, 382–383
replaceAll( ), 376, 826–827, 831–832
replaceFirst( ), 376
replaceRange( ), 722
ReplicateScaleFilter class, 770
reset( ), 549, 563, 564, 567, 570, 572, 580,
584, 816
resetSyntax( ), 590
Resource bundles, 549–553
ResourceBundle class, 549–550
methods, table of, 550–551
ResourceBundle.Control class, 550
resume( ), 13, 249–252, 423, 429
retainAll( ), 441, 442
@Retention built-in annotation, 273, 282
RetentionPolicy enumeration, 273, 435
return statement, 103–104, 112
reverse( ), 381, 394, 396
reverseBytes( ), 392, 394, 396
reverseOrder( ), 477, 479
rewind( ), 816, 820, 823
RGB (red-green-blue) color model, default,
683, 766
RGBImageFilter class, 770, 772–782
RGBtoHSB( ), 683
Richards, Martin, 4
rint( ), 420
Ritchie, Dennis, 4
RMI compiler (rmic), 839
rmiregistry (RMI registry), 839
round( ), 420
Run-time
system, Java, 9. See also Java Virtual
Machine (JVM)
type information, 13, 300, 417
run( ), 226, 228, 422, 424, 522
overriding, 230, 232, 522
using flag variable with, 252–253
Runnable interface, 226, 422, 522, 868
implementing, 228–230, 232
Runtime class, 403, 404–407
executing other programs and, 406–407
memory management and, 405–406
methods, table of, 404–405
RUNTIME retention policy, 273, 274, 277
RuntimeException class, 206, 215, 217, 221
RuntimePermission class, 431
S
save( ), 497
scalb( ), 419
Scanner class, 540–549
constructors, 540–541
delimiters, 547–548
demonstration programs, 544–547
hasNextX( ) methods, table of, 542
how to use, 541–543
methods, miscellaneous, 548–549
nextX( ) methods, table of, 543
schedule( ), 523
ScheduledExecutorService interface, 802
ScheduledThreadPoolExecutor class, 788, 802
Scientific notation, 40
Scopes in Java, 42–45
Scroll bars, 716–718
Scroll pane, 893–895
Scrollbar class, 716–717
extending, 753–754
search( ), 491, 492
Security problem, 8, 9–10, 14
and native methods, 306
and servlets, 908
SecurityException, 218, 404, 409
SecurityManager class, 431
seek( ), 578
select( ), 711, 714, 719, 722
Selection statements, 77–84
Selectors, 818, 819
Semaphore, 238
and setting initial synchronization
state, 795
using, 789–795
Semaphore class, 788, 789–790
send( ), 613
Separable Model architecture, 861Index
Separators, 31
SequenceInputStream class, 287, 573–574
Serializable interface, 593
Serialization, 592–598
example program, 595–598
and Java Beans, 851
and static variables, 593
and transient variables, 593, 597
Server, 599
proxy, 601, 611, 630
ServerSocket class, 603, 612–613, 818
ServiceLoader class, 553
service( ), 908, 910, 912, 913
Servlet interface, 911, 912
methods, table of, 913
Servlet(s), 10, 14, 907–928
advantages of, 908
API, 911
example of simple, 910–911
financial calculation example, 959–963
life cycle of, 908
parameters, reading, 915–916
and portability, 10
and security, 908
and session tracking, 927–928
using Tomcat to develop, 908–909
ServletConfig interface, 911, 912
ServletContext interface, 911, 912
methods, table of, 913
ServletException class, 912, 915
ServletInputStream class, 912, 915
ServletOutputStream class, 912, 915
ServletRequest interface, 910, 911, 913, 915
methods, table of, 914
ServletResponse interface, 910, 911, 913
methods, table of, 914
Session tracking, 927–928
Set interface, 440, 443–444, 453, 458, 464, 467
Set-view, obtaining, 465, 468, 469, 496
set( ), 443, 453, 459, 506, 510, 811
setActionCommand( ), 707, 738, 883, 890
setAddress( ), 615
setAlignment( ), 703
setAttribute( ), 913, 919, 927
setBackground( ), 623, 683
setBlockIncrement( ), 717
setBorder( ), 877
setBounds( ), 667, 723
setChanged( ), 518, 519
setCharAt( ), 379
setColor( ), 684
setConstraints( ), 733
setContentType( ), 910
setData( ), 615
setDefault( ), 514, 516
setDefaultCloseOperation( ), 866
setDisabledIcon( ), 883
setEchoChar( ), 720
setEditable( ), 720, 722, 937
setEnabled( ), 737
setFollowRedirects( ), 610
setFont( ), 689
setForeground( ), 623, 683
setIcon( ), 880
SetIntField( ), 305
setLabel( ), 704, 707, 737
setLastModified( ), 559
setLayout( ), 723, 867
setLength( ), 378–379, 578, 615
setLocation( ), 667
setMaxAge( ), 920, 927
setName( ), 227, 228, 424
setPaintMode( ), 685
setPort( ), 615
setPreferredSize( ), 667
setPressedIcon( ), 883
setPriority( ), 236, 424
setReadOnly( ), 559
setRequestMethod( ), 610
setRolloverIcon( ), 883
setSelectedCheckbox( ), 709
setSelectedIcon( ), 883
setSelectionMode( ), 896
setSize( ), 489, 667, 668, 669, 866
setSoTimeout( ), 614
setStackTrace( ), 219
setState( ), 707, 738
setStream( ), 635
setText( ), 703, 719, 722, 880, 883, 937
setTitle( ), 668
setUnitIncrement( ), 717
setValue( ), 467, 716–717, 920
setValues( ), 716
setVisible( ), 668, 669, 867
setXORMode( ), 685
Sheridan, Mike, 6
Shift operators, bitwise, 62, 65–69
Short class, 265, 390, 396, 397
methods defined by, table of, 392
short data type, 33, 34, 35, 40
shortValue( ), 265, 386, 388, 389, 391, 392,
394, 396
10191020
Java: The Complete Reference
show( ), 730
showDocument( ), 633, 634, 635
showStatus( ), 620, 628, 635
shuffle( ), 477, 479
shutdown( ), 801, 804
Sign extension, 67
signal( ), 808
signum( ), 394, 396, 421
SimpleBeanInfo class, 850
SimpleDateFormat class, 516, 842–843
formatting string symbols, table of, 843
SimpleTimeZone class, 514–515
sin( ), 418
SingleSelectionModel, 891
sinh( ), 419
SIZE, 387, 391
size( ), 441, 442, 453, 465, 489, 493, 494, 495,
506, 819
skip( ), 549, 563, 564–565, 570, 580, 595
sleep( ), 226, 227, 228, 233, 424, 807
slice( ), 817
Slider box, 716
Socket class, 603–605, 612, 613, 818
Socket(s)
example program of client/server, 611–628
overview, 599
TCP/IP client, 603–605
TCP/IP server, 603, 612–613
SocketAddress class, 613
SocketChannel class, 818
SocketException, 613
sort( ), 482–483
SortedMap interface, 464, 465, 466
methods, table of, 466
SortedSet interface, 440, 444
methods, table of, 444
Source code file, naming, 21–22
SOURCE retention policy, 273
split( ), 376, 377, 832
sqrt( ), 42, 309–311, 419
Stack
definition of, 123
ways to implement a, 197
Stack class, 438, 448, 487, 491–493
methods, table of, 492
Stack frame, 431
Stack trace, 207, 441
StackTraceElement class, 431–432
methods, table of, 431–432
Standard Template Library (STL), 439
start( ), 226, 229, 230, 403, 408, 424, 620, 621,
622, 623, 624, 669, 826, 871
startsWith( ), 368
Statements, 24
null, 85
Statements, control
iteration, 77, 84–98
jump, 77, 98–104
selection, 77–84
static, 23, 141–143, 145, 309
member restrictions, 354–355
Static import, 14, 309–312
stop( ), 13, 251–252, 423, 620, 621, 622–623, 625,
635, 669, 871
store( ), 498, 500–501
Stream(s)
benefits, 598
buffered, 569–572
classes, byte, 286, 287, 562–578
classes, character, 286, 287–288, 562,
578–592
definition of, 286, 555
filtered, 569
predefined, 288
StreamTokenizer class, 590–592
strictfp, 302
StrictMath class, 422
String class, 24, 55–56, 148–150, 359, 433, 540
constructors, 359–362
String(s)
arrays of, 150
changing case of characters in, 375–376
comparison, 366–370
concatenating, 148–149, 362–364. 373, 380
creating, 359–362
extracting characters from, 365–366
length, obtaining, 149–150, 362
literals, 40–41, 362
modifying, 372–374
as objects, 41, 55–56, 148, 359
parsing a formatted input, 503
reading, 290–291
representations of numbers, converting,
390, 396–398
searching, 370–372
StringBuffer class, 148, 359, 361, 372,
377–384, 433
StringBufferInputStream deprecated class, 556
StingBuilder class, 359, 361, 372, 384, 433, 526
and synchronization, 384Index
StringIndexOutOfBounds exception, 218
StringReader class, 288
StringWriter class, 288
StringTokenizer class, 503–504
methods, table of, 504
stringWidth( ), 692, 693
Stroustrup, Bjarne, 6
Stubs (RMI), 838
Subclass, 18, 157, 158, 159, 175
subList( ), 443
subMap( ), 465, 466
submit( ), 804
subSequence( ), 377, 384, 433
subSet( ), 444, 445, 456
substring( ), 372–373, 383
Sun Microsystems, 6, 599
super, 141
and bounded wildcard arguments, 334
and methods or instance variables,
166–167, 172
super( ), 314
and superclass constructors, 163–166, 170
Superclass, 18, 157, 158, 159, 175
Supplemental character, definition of, 401
@SuppressWarnings built-in annotation,
282, 283
suspend( ), 13, 249–252, 423, 429
Swing, 13, 285, 299, 617, 663, 859–878, 879–906
applet, example of a simple, 871–873
application, example of a simple, 864–868
and the AWT, 663, 859, 860
component classes, list, 862
download manger using, 965–990
event handling, 868–871
history of, 859–860
and MVC architecture, 861
packages, list of, 864
and painting, 873–878
threading issues, 867–868, 871
Swing: A Beginner’s Guide (Schildt), 859
SwingConstants interface, 880
SwingUtilities class, 868
switch statement, 80–84
and auto-unboxing, 269–270
using enumeration constants to control, 81,
256–257
Synchronization, 12, 225, 238–242
and atomic operations, 811–812
and collections, 448, 479, 487
and deadlock, 247–249, 251
objects, using, 789–801
race condition and, 240–241
and StringBuilder class, 384
via synchronized block, 241–242, 479
via synchronized method, 239–241
versus concurrency utilities, 787, 812
synchronized modifier, 239
used with method, 239, 240–241
used with object, 241–242
synchronizedList( ), 478, 479
synchronizedSet( ), 478, 479
Synchronizers, 788
SynchronousQueue class, 808
System class, 24, 288, 409–412
methods, table of, 409–410
System.console( ), 409, 587
System.err standard error stream, 288
System.getProperties( ), 409, 497
System.in standard input stream, 288, 289,
541, 587
System.in.read( ), 88
System.out standard output stream, 24, 288,
292, 293, 539, 574, 575, 587
T
Tabbed panes, 891–893
TableColumnModel, 904
TableModel, 904
TableModelEvent class, 904
tailMap( ), 465, 466
tailSet( ), 444
tan( ), 418
tanh( ), 419
@Target built-in annotation, 282–283
TCP/IP, 12, 599–600
client sockets, 603–605
disadvantages of, 613
server sockets, 603, 612–613
See also Transmission Control Protocol (TCP)
Templates, C++, 316
Ternary operator (?:), 71, 73–74
Text area, 721–723
Text fields, 719–721, 937
Swing, 881–882, 937
Text formatting using java.text classes, 813,
840–843
Text output, managing, 691–699
TextArea class, 721–723
textChanged( ), 652
TextComponent class, 719, 722
TextEvent class, 640, 648
10211022
Java: The Complete Reference
TextField class, 719
TextListener interface, 650, 652
this, 120–121, 141
this( ), 312–314
Thompson, Ken, 4
Thread class, 13, 226, 422–424, 522
constructors, 229, 231, 422
extending, 230–232
methods, table of, 423–424
Thread(s)
creating, 228–233
daemon, 522
and deadlock, 247–249, 251
definition of, 223
executors to manage, using, 788, 801–806
group, 227, 424–429
main, 226–227, 230, 232, 233
messaging, 225, 242–247
pool, 802–804
possible states of, 224
priorities, 224–225, 236–238, 422
resuming, 249–253, 426
stopping, 249, 251–252
suspending, 226, 227, 228, 249–253, 426
and Swing, event dispatching, 867–868,
871, 873
synchronization. See Synchronization
ThreadGroup class, 424–429
methods, table of, 425–426
ThreadLocal class, 429
ThreadPoolExecutor class, 788, 802
throw, 205, 213–214
Throwable class, 206, 209, 219, 221, 431
methods defined by, table of, 219
obtaining object of, 213–214
throws, 205, 214–215, 217
Thumb, 716
Time. See Date class
timedJoin( ), 807
timedWait( ), 807
Timer class, 522–524
methods, table of, 523
TimerTask class, 522–524
methods, table of, 522
Timestamps, 641
TimeUnit enumeration, 788, 795, 805, 806–807
TimeZone class, 513–514
methods defined by, table of, 514
toArray( ), 441, 442, 450–451
toBinaryString( ), 394, 396, 397
toCharArray( ), 366
toDays( ), 807
toDegrees( ), 421
toHexString( ), 388, 389, 394, 396, 397
toHours( ), 807
Tokens, 503, 541, 590
toLowerCase( ), 375–376, 400, 401
Tomcat, 908–909
toMicros( ), 807
toMillis( ), 807
toMinutes( ), 807
toNanos( ), 807
toOctalString( ), 394, 396, 397
TooManyListenersException, 850
toRadians( ), 421
toSeconds( ), 807
toString( ), 181, 182, 209, 219, 220, 266, 272, 278,
292, 364–365, 375, 380, 388, 389, 391, 392, 394,
396, 397, 403, 413, 417, 424, 426, 430, 432, 433,
450, 483, 489, 495, 506, 507, 508, 525, 527, 528,
574, 575, 587, 602, 639, 834, 901
totalMemory( ), 405–406
toUpperCase( ), 375–376, 400
transient modifier, 299, 851
translatePoint( ), 646
Transmission Control Protocol (TCP), 601
definition of, 599
and stream-based I/O, 601
See also TCP/IP
TreeExpansionEvent class, 901
TreeExpansionListener interface, 901
TreeMap class, 468, 470–471, 472, 502
TreeModel, 901
TreeModelEvent class, 901
TreeModelListener interface, 901
TreeNode interface, 901
TreePath class, 901
Trees, Swing, 900–903
TreeSelectionEvent class, 901
TreeSelectionListener interface, 901
TreeSelectionModel, 901
TreeSet class, 448, 454, 455–456, 472, 502
trim( ), 373–374
trimToSize( ), 384, 450, 489
true, 32, 39, 40, 71
TRUE, 402
True and false in Java, 40, 71
Truncation, 46
try block(s), 205, 207–213, 216
nested, 211–213
tryLock( ), 789, 808, 809
Two’s complement, 62–63Index
TYPE, 387, 391, 398, 402, 403
Type argument(s), 318, 320, 324
and bounded types, 325–327
and class hierarchies, 342–343
Type conversion
automatic, 33, 45, 126–127
narrowing, 45
widening, 45
Type interface, 436
Type parameter(s)
and bounded types, 324–326
cannot create an instance of a, 354
and class hierarchies, 343–345
and erasure, 349–351, 354
and primitive types, 320
and static members, 354–355
and type safety, 320
used with a class, 317, 322, 324
used with a method, 318, 335, 336
Type safety
and arrays, 356
and collections, 475, 478
and generic methods, 336
and generics, 315, 316, 319, 320–322, 439,
475, 484, 485, 501
and raw types, 339–342
and wildcard arguments, 327–329, 331
Type-safe view, 478
Type(s)
bounded, 324, 327
casting, 46–47, 48
checking, 10, 11, 33
data. See Data type(s)
parameterized, 316, 317
promotion, 35, 47–48
wrappers, 264–266, 272, 320, 386–403
TypeNotPresentException, 218
U
UDP protocol, 599, 600, 613
UI delegate, 861, 862
ulp( ), 419, 420
UnavailableException class, 912, 915
Unboxing, 266
Unchecked warnings and raw types, 341–342
UnicastRemoteObject, 837
Unicode, 37, 38, 40, 286, 360, 361–362, 366,
400, 578
code points, table of methods providing
support for, 401–402
support for 32-bit, 401–402
Uniform Resource Identifier (URI), 612
Uniform Resource Locator (URL). See URL
(Uniform Resource Locator)
UNIX, 4, 599
UnknownHostException, 601, 602
unlock( ), 789, 808, 809
unmodifiable... collections methods, 478, 479
Unreachable code, 210–211
unread( ), 572, 585
UnsupportedOperationException, 218, 440,
441, 442, 459, 464, 478
update( ), 518, 519, 623, 625, 626, 676
overriding, 623
URI class, 612
URL (Uniform Resource Locator), 605–606,
612, 907
specification format, 606
URL class, 605–607, 610, 633
URLConnection class, 607–610
useDelimiter( ), 547
User Datagram Protocol (UDP), 599, 600, 613
useRadix( ), 549
UUID class, 553
V
value (annotation member name), 281, 282
VALUE (PARAM), 630
valueBound( ), 919
valueChanged( ), 896, 901
valueOf( ), 258–259, 364, 374–375, 380, 381, 388,
389, 391, 392, 394, 396, 403, 433
values( ), 258–259, 465
valueUnbound( ), 919
van Hoff, Arthur, 6
Varargs, 14, 151–156
and ambiguity, 155–156
and formatted I/O, 525
methods, overloading, 154–155
and Java’s printf( ), 151
parameter, 153–154, 458
Variable(s), 41–45
declaration, 25, 27, 41–42
definition of, 24, 42
dynamic initialization of, 42
enumeration, 256
final, 143
instance. See Instance variables
interface, 193, 200–202
object reference. See Object reference
variables
scope and lifetime of, 42–45
10231024
Java: The Complete Reference
Vector class, 438, 448, 449, 463, 487–490
methods, table of, 489
VetoableChangeListener interface, 851
void, 23, 112
Void class, 403
volatile modifier, 238, 299
VSPACE, 630
W
wait( ), 181, 243, 245–246, 252, 413, 808
waitFor( ), 403, 407
Warth, Chris, 6
wc( ), 589–592
WeakHashMap class, 468
Web browser
executing applet in, 298, 299, 617, 621,
628–629, 667
using status window of, 628
Web server and servlets, 907, 908
while loop, 84–86
Whitespace, 30, 78
from string, removing, 373–374
whitespaceChars( ), 591
Whois, 600, 604–605
WIDTH, 629
Wildcard arguments, 327–334
bounded, 329–334
used in creating an array, 356
used with instanceof, 347
Window
displaying information within, 676
frame. See Frame window(s)
fundamentals, 666–667
status, using, 628
Window class, 649, 665, 667, 742
windowActivated( ), 653
windowClosed( ), 653
windowClosing( ), 653, 668, 669
WindowConstants interface, 866
windowDeactivated( ), 653
windowDeiconified( ), 653
WindowEvent class, 640, 642, 648–649
WindowFocusListener interface, 650, 652
windowGainedFocus( ), 652
windowIconified( ), 653
WindowListener interface, 650, 653, 668
windowLostFocus( ), 652
windowOpened( ), 653
wordChars( ), 591
World Wide Web (WWW), 6, 7, 605
wrap( ), 817
Wrappers, primitive type, 264–266, 272, 320,
386–403
write( ), 286, 292, 295, 563, 580–581, 594, 818,
822, 823
writeBoolean( ), 576, 594
writeDouble( ), 576, 594
Writer class, 286, 288, 562, 579
methods defined by, table of, 580–581
writeExternal( ), 593
writeInt( ), 576
writeObject( ), 593
writeTo( ), 569
X
XOR (exclusive OR) operator (^)
bitwise, 62, 63, 64–65
Boolean, 71, 72
Y
Yellin, Frank, 6
Z
Zero crossing, 63
ZIP file format, 554